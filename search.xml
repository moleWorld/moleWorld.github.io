<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>mybatis</title>
      <link href="2021/05/13/mybatis/"/>
      <url>2021/05/13/mybatis/</url>
      
        <content type="html"><![CDATA[<h4 id="mybatis的中文官网地址"><a href="#mybatis的中文官网地址" class="headerlink" title="mybatis的中文官网地址"></a>mybatis的中文官网地址</h4><p><a href="https://mybatis.org/mybatis-3/zh/">https://mybatis.org/mybatis-3/zh/</a></p><h4 id="mybatis的主要核心部件"><a href="#mybatis的主要核心部件" class="headerlink" title="mybatis的主要核心部件"></a>mybatis的主要核心部件</h4><ul><li>SqlSession    表示和数据库交互的会话，完成必要的数据库增删改查功能</li><li>Executor       执行器，是mybatis的核心，负责sql语句的执行，缓存的查询</li><li>StatementHandler    封装了JDBC Statement操作，负责对JDBC statement的操作，如设置参数，或将结果集转换成List</li><li>ParameterHandler    负责对用户传递的参数转换成JDBC Statement所需要的参数</li><li>ResultSetHandler      负责将jdbc返回的结果集转换成List集合</li><li>TypeHandler              负责将java的数据类型和jdbc数据类型之间的转换</li><li>Configuration             配置mybatis的信息</li><li>SqlSource                    负责用户传递的paramterObject,动态的生成SQL语句，将信息封装到BoundSql中</li><li>BoundSql                    表示动态生成SQL语句以及相应的参数信息</li></ul><h4 id="mybatis-工作流程"><a href="#mybatis-工作流程" class="headerlink" title="mybatis 工作流程"></a>mybatis 工作流程</h4><ol><li>读取mybatis的配置信息，可以是xml的格式，也可以是基于Configuration的对象。</li><li>实例化SqlSessionFactoryBuilder,并通过build配置文件生成SqlSessionFactory实例</li><li>创建一个SqlSession会话，用于实现CRUD。</li><li>创建会话时也会创建一个新的Executor执行器，用于执行SQL或者查询缓存</li><li>执行完成，返回结果并关闭SqlSession会话。</li></ol><h4 id="mybatis的缓存"><a href="#mybatis的缓存" class="headerlink" title="mybatis的缓存"></a>mybatis的缓存</h4><h5 id="一级缓存SqlSession"><a href="#一级缓存SqlSession" class="headerlink" title="一级缓存SqlSession"></a>一级缓存SqlSession</h5><p>mybatis的一级缓存是默认开启的，是SqlSession级别的，即拿到这个链接到结束连接的过程中缓存是有效的。其特点有以下：</p><ul><li>映射语句文件中的所有 select 语句的结果将会被缓存。</li><li>映射语句文件中的所有 insert、update 和 delete 语句会刷新缓存。</li><li>缓存会使用最近最少使用算法（LRU, Least Recently Used）算法来清除不需要的缓存。</li><li>缓存不会定时进行刷新（也就是说，没有刷新间隔）。</li><li>缓存会保存列表或对象（无论查询方法返回哪种）的 1024 个引用。</li><li>缓存会被视为读/写缓存，这意味着获取到的对象并不是共享的，可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。</li></ul><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--可以设置缓存算法，刷新间隔、引用大小、只读表示等 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cache</span>  <span class="token attr-name">eviction</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>FIFO<span class="token punctuation">"</span></span>  <span class="token attr-name">flushInterval</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>60000<span class="token punctuation">"</span></span>  <span class="token attr-name">size</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>512<span class="token punctuation">"</span></span>  <span class="token attr-name">readOnly</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="二级缓存nameSpace"><a href="#二级缓存nameSpace" class="headerlink" title="二级缓存nameSpace"></a>二级缓存nameSpace</h5><p>mybatis的二级缓存也叫全局缓存，由于一级缓存的作用域只在sqlSession中（太窄了），所以诞生了二级缓存，它是基于nameSpace级别的缓存，相当于一个nameSpace对应一个二级缓存。mybatis的二级缓存需要手动开启。</p><p>二级缓存的工作机制：</p><ul><li>当一个会话查询到一条数据时首先会存储到一级缓存中</li><li>如果当前会话关闭，则一级缓存不存在了，则会把一级缓存的信息过渡到二级缓存</li><li>当我们再次在此nameSPace空间内查询时则会从二级缓存中获得内容</li><li>不同的nameSpace有不同的缓存集合</li></ul><h5 id="自定义缓存"><a href="#自定义缓存" class="headerlink" title="自定义缓存"></a>自定义缓存</h5><p>自定义缓存只需实现Cache就可以了！具体可查看官方文档！</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql</title>
      <link href="2021/05/12/mysql/"/>
      <url>2021/05/12/mysql/</url>
      
        <content type="html"><![CDATA[<h4 id="mysql中innodb和myisam"><a href="#mysql中innodb和myisam" class="headerlink" title="mysql中innodb和myisam"></a>mysql中innodb和myisam</h4><table><thead><tr><th></th><th>innodb</th><th>myisam</th></tr></thead><tbody><tr><td>事务</td><td>支持</td><td>不支持</td></tr><tr><td>外键</td><td>支持</td><td>不支持</td></tr><tr><td>全文索引</td><td>不支持</td><td>支持</td></tr><tr><td>锁级别</td><td>行级锁</td><td>表锁</td></tr><tr><td>表空间大小</td><td>较大，约为myisam的2倍</td><td>较小</td></tr><tr><td>索引</td><td>聚簇索引、索引就是数据，顺序存储，因此能缓存索引，也能缓存数据</td><td>非聚簇索引、索引和文件分开，随机存储，只能缓存索引</td></tr><tr><td>备份和恢复</td><td>拷贝数据文件、备份 binlog，或者用 mysqldump，数据量大时很慢</td><td>数据是以文件的形式存储，所以在跨平台的数据转移中会很方便</td></tr></tbody></table><blockquote><p>myisam：节约空间，速度快，如果不注重事务或读取操作较多时选择myisam，其他情况选择innodb。</p></blockquote><blockquote><p>innodb：安全性高、事务处理、多表多用户操作。</p></blockquote><p>mysql的数据库信息都存在data目录下：</p><ul><li>InnoDB基于磁盘的资源是InnoDB表空间数据文件和它的日志文件，InnoDB 表的大小只受限于操作系统文件的大小</li><li>MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型， .frm文件存储表定义，数据文件的扩展名为.MYD， 索引文件的扩展名是.MYI</li></ul><h4 id="mysql的事务ACID"><a href="#mysql的事务ACID" class="headerlink" title="mysql的事务ACID"></a>mysql的事务ACID</h4><ul><li>原子性(A)：事务是最小单位，不可再分</li><li>一致性©：事务要求所有的DML语句操作的时候，必须保证同时成功或者同时失败</li><li>隔离性(I)：事务A和事务B之间具有隔离性</li><li>持久性(D)：是事务的保证，事务终结的标志(内存的数据持久到硬盘文件中)</li></ul><blockquote><p>隔离存在的并发问题</p></blockquote><ul><li>脏读：事务A读取了事务B更新的数据，然后B回滚操作（即未提交），那么A读取到的数据是脏数据</li><li>不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。</li><li>幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</li></ul><blockquote><p>隔离级别的分类</p></blockquote><table><thead><tr><th>事务隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交（read-uncommitted）</td><td>是</td><td>是</td><td>是</td></tr><tr><td>不可重复读（read-committed）</td><td>否</td><td>是</td><td>是</td></tr><tr><td>可重复读（repeatable-read）</td><td>否</td><td>否</td><td>是</td></tr><tr><td>串行化（serializable）</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><p><strong>mysql默认的事务隔离级别为repeatable-read</strong></p><blockquote><p>mysql事务的常用方法</p></blockquote><pre class="line-numbers language-SHELl" data-language="SHELl"><code class="language-SHELl">set autocommit =0   #关闭自动提交set autocommit =1#开启自动提交Start Transaction#开启事务Commit #提交事务Rollback #回滚事务End Transaction#事务结束<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="索引-index"><a href="#索引-index" class="headerlink" title="索引 index"></a>索引 index</h4><h5 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h5><ul><li><strong>InnoDB使用的是B+Tree，每一个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的范围遍历。</strong></li><li><strong>B-Tree通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同，很适合查找范围数据。</strong></li><li><strong>B-Tree可以对&lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN，以及不以通配符开始的LIKE使用索引。</strong></li></ul><h5 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h5><blockquote><p>优点：</p></blockquote><ul><li>建立索引的列可以保证行的唯一性，生成唯一的rowId</li><li> 建立索引可以有效缩短数据的检索时间</li><li> 建立索引可以加快表与表之间的连接</li><li> 为用来排序或者是分组的字段添加索引可以加快分组和排序顺序</li></ul><blockquote><p>缺点：</p></blockquote><ul><li><p>创建索引和维护索引需要时间成本，这个成本随着数据量的增加而加大</p></li><li><p>创建索引和维护索引需要空间成本，每一条索引都要占据数据库的物理存储空间，数据量越大，占用空间也越大（数据表占据的是数据库的数据空间）</p></li><li><p>会降低表的增删改的效率，因为每次增删改索引需要进行动态维护，导致时间变长</p></li></ul><h5 id="常见的索引类型"><a href="#常见的索引类型" class="headerlink" title="常见的索引类型"></a>常见的索引类型</h5><ul><li><p>普通索引      index</p><p><strong>普通索引是最基本的索引，它没有任何限制。</strong></p></li><li><p>唯一索引     uniqe index</p><p><strong>唯一索引和普通索引类似，主要的区别在于，唯一索引限制列的值必须唯一，但允许存在空值（只允许存在一条空值）。</strong></p></li><li><p>主键索引     primary key</p><p><strong>主键索引是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引</strong></p></li><li><p>组合索引     index</p><p><strong>复合索引是在多个字段上创建的索引。复合索引遵守“最左前缀”原则，即在查询条件中使用了复合索引的第一个字段，索引才会被使用。因此，在复合索引中索引列的顺序至关重要。</strong></p></li><li><p>全文索引    fullText</p><p><strong>FULLTEXT 索引在 MySQL 5.6 版本之后支持 InnoDB，而之前的版本只支持 MyISAM 表。一般用于模糊查询</strong></p></li></ul><h5 id="索引失效场景"><a href="#索引失效场景" class="headerlink" title="索引失效场景"></a>索引失效场景</h5><ul><li>在where后使用or，导致索引失效（尽量少用or）</li><li>使用like ，like查询是以%开头</li><li>复合索引遵守“最左前缀”原则，即在查询条件中使用了复合索引的第一个字段，索引才会被使用</li><li>如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引</li><li>在索引字段上使用not，&lt;&gt;，!=。不等于操作符是永远不会用到索引的，因此对它的处理只会产生全表扫描</li><li>DATE_FORMAT()格式化时间，格式化后的时间再去比较，可能会导致索引失效。</li><li>is null， is not null也无法使用索引</li></ul><h5 id="什么情况下不适合建立索引"><a href="#什么情况下不适合建立索引" class="headerlink" title="什么情况下不适合建立索引"></a>什么情况下不适合建立索引</h5><ul><li>小数据量的表不超过10万</li><li>数据变动强的字段不建立索引</li><li>大字段不建立索引</li><li>有枚举类型的字段不建议索引，或者建立组合索引</li></ul>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot</title>
      <link href="2021/05/10/springboot/"/>
      <url>2021/05/10/springboot/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm</title>
      <link href="2021/05/10/jvm/"/>
      <url>2021/05/10/jvm/</url>
      
        <content type="html"><![CDATA[<h4 id="jvm（hotSpot）的体系结构"><a href="#jvm（hotSpot）的体系结构" class="headerlink" title="jvm（hotSpot）的体系结构"></a>jvm（hotSpot）的体系结构</h4><p><img src="https://i.loli.net/2021/05/10/pZ1nxflVTFqdOaC.png" alt="jvm体系结构.png"></p><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><h5 id="类加载器的种类"><a href="#类加载器的种类" class="headerlink" title="类加载器的种类"></a>类加载器的种类</h5><ul><li>启动类根加载器                      lib/rb.jar</li><li>扩展类加载器                          lib/exc/*.jar</li><li>应用程序加载器                     classpath</li></ul><h5 id="类加载器概念"><a href="#类加载器概念" class="headerlink" title="类加载器概念"></a>类加载器概念</h5><p>我们编写号类文件之后，通过类加载器class loader加载成class文件，class文件也可通过getClassload转换到class loader里，如果我们需要实例化，则一般常用new的方式实例化成具体的对象，对象也可通过getClass得到想要的class文件。其中class是抽象的，对象是具体的实现。每个对象都是一个实例化。</p><h4 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><p>双亲委派模型是为了保证Java核心库的类型安全。所有Java应用都至少需要引用java.lang.Object类，在运行时这个类需要被加载到Java虚拟机中。如果该加载过程由自定义类加载器来完成，可能就会存在多个版本的java.lang.Object类，而且这些类之间是不兼容的。</p><p>通过双亲委派模型，对于Java核心库的类的加载工作由启动类加载器来统一完成，保证了Java应用所使用的都是同一个版本的Java核心库的类，是互相兼容的。</p><h5 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h5><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的加载器都是如此，因此所有的类加载请求都会传给顶层的启动类加载器，只有当父加载器反馈自己无法完成该加载请求（该加载器的搜索范围中没有找到对应的类）时，子加载器才会尝试自己去加载。三种加载器的子父关系：启动类根加载器/扩展类加载器 /应用程序加载器      </p><h4 id="native关键字"><a href="#native关键字" class="headerlink" title="native关键字"></a>native关键字</h4><ul><li>凡是用native修饰的方法，说明java程序的作用范围达不到，需要调用底层的C语言</li><li>会进入本地方法栈调用本地方法接口JNI</li><li>JNI的作用是扩展java的应用，融合不同的语言为java使用</li><li>存储native方法的区域叫做native Method Stack即本地方法栈</li><li>在最终执行的时候会加载到本地方法库通过JNI进行调用</li></ul><h4 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h4><ul><li>它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域</li><li>在jvm规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致</li><li>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的java方法的JVM指令地址；或者，如果在执行native方法，则是未指定值（undefined）,因为程序计数器不负责本地方法栈。</li><li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成</li><li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令</li><li>它是唯一一个在java虚拟机规范中没有规定任何OOM（Out Of Memery）情况的区域,而且没有垃圾回收</li></ul><h4 id="方法区、元空间"><a href="#方法区、元空间" class="headerlink" title="方法区、元空间"></a>方法区、元空间</h4><ul><li>方法区（Method Area）与 Java 堆一样，是所有线程共享的内存区域。</li><li>JDK7 之前（永久代）用于存储已被虚拟机加载的类信息、常量、字符串常量、类静态变量、即时编译器编译后的代码等。即static、final、Class、常量池。</li><li>JDK8 彻底将永久代移除出 HotSpot JVM，将其原有的数据迁移至 Java Heap 或 Native Heap，取代它的是另一个内存区域被称为元空间(Metaspace）</li></ul><p>元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。</p><h4 id="栈stack"><a href="#栈stack" class="headerlink" title="栈stack"></a>栈stack</h4><ul><li>栈内存主管程序的运行和线程同步</li><li>线程结束，栈内存也就释放不存在垃圾回收机制</li><li>栈存储的有8大基本数据类型+对象引用+实例方法</li><li>栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活。</li><li>如果栈满则会抛出stackOverFlowError错误</li></ul><h4 id="堆heap"><a href="#堆heap" class="headerlink" title="堆heap"></a>堆heap</h4><ul><li><p>一个jvm只有一个堆内存，堆内存的大小是可以调节的。</p></li><li><p>类加载器读取类文件之后，会把类、方法、常亮放入堆中，保存我们引用类型的真实对象</p></li><li><p>堆分为：新生区（伊甸园区eden、from、to）、老年区</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">-Xms1024m -Xmx1024m -XX:+PrintGCDetails//自定义堆的内存空间为1024m，其中xms时初始化内存大小，xmx时最大分配内存· //新生代总内存   305664K,PSYoungGen      total 305664K, used 47186K [0x00000000eab00000, 0x0000000100000000, 0x0000000100000000)     //伊甸园区 使用率                                 eden space 262144K, 18% used [0x00000000eab00000,0x00000000ed914aa0,0x00000000fab00000)  //幸村一区、幸存0区的内次使用率                               from space 43520K, 0% used [0x00000000fd580000,0x00000000fd580000,0x0000000100000000)  to   space 43520K, 0% used [0x00000000fab00000,0x00000000fab00000,0x00000000fd580000)  //养老区的内存总数                             ParOldGen       total 699392K, used 0K [0x00000000c0000000, 0x00000000eab00000, 0x00000000eab00000)  //养老区内存使用率                                         object space 699392K, 0% used [0x00000000c0000000,0x00000000c0000000,0x00000000eab00000)  //元空间的 的逻辑内存，实际上存储在本地内存中                              Metaspace       used 3396K, capacity 4500K, committed 4864K, reserved 1056768K  class space    used 369K, capacity 388K, committed 512K, reserved 1048576K                                   -Xms16m -Xmx16m -XX:+PrintGCDetails      //自定义空间为16m，可以看出明显的差别                         PSYoungGen      total 4608K, used 851K [0x00000000ffb00000, 0x0000000100000000, 0x0000000100000000)  eden space 4096K, 8% used [0x00000000ffb00000,0x00000000ffb586f0,0x00000000fff00000)  from space 512K, 97% used [0x00000000fff00000,0x00000000fff7c7a0,0x00000000fff80000)  to   space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000) ParOldGen       total 11264K, used 786K [0x00000000ff000000, 0x00000000ffb00000, 0x00000000ffb00000)  object space 11264K, 6% used [0x00000000ff000000,0x00000000ff0c4a28,0x00000000ffb00000) Metaspace       used 3447K, capacity 4500K, committed 4864K, reserved 1056768K  class space    used 370K, capacity 388K, committed 512K, reserved 1048576K                                                                 //当运行的对象过多时会进行轻量级的GC清理和重量级的GC清理，如果重量级的GC清理也不成功，则会提示 java.lang.OutOfMemoryError: Java heap space内存溢出[GC (Allocation Failure) --[PSYoungGen: 3072K-&gt;3072K(3584K)] 14077K-&gt;14333K(14848K), 0.0025489 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]                                 [Full GC (Ergonomics) [PSYoungGen: 3072K-&gt;3071K(3584K)] [ParOldGen: 11208K-&gt;11208K(11264K)] 14280K-&gt;14279K(14848K), [Metaspace: 36735K-&gt;36735K(1083392K)], 0.0202492 secs] [Times: user=0.01 sys=0.00, real=0.02 secs] 2021-05-11 21:38:46.349 ERROR 8084 --- [  restartedMain] com.alibaba.druid.pool.DruidDataSource   : {dataSource-1} init errorjava.lang.OutOfMemoryError: Java heap space<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="垃圾回收GC"><a href="#垃圾回收GC" class="headerlink" title="垃圾回收GC"></a>垃圾回收GC</h4><p><strong>1、分代收集算法：</strong> 堆中的每个对象都会添加一个引用计数器。每当一个地方引用这个对象时，计数器值 <code>+1</code>；当引用失效时，计数器值 <code>-1</code>。任何时刻计数值为 <code>0</code> 的对象就是不可能再被使用的。这种算法无法解决<strong>对象之间相互引用的情况</strong>。</p><p><strong>2、复制算法：</strong>将可用内存分为两块，每次只用其中一块，当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已经使用过的内存空间一次性清理掉。这种算法适用于对象存活率低的场景，比如新生代。</p><p><strong>3、标记、清除、压缩算法：</strong>首先垃圾回收器此时会找出哪些内存在使用中，那些未使用，接着删除未使用对象并内存分配器会保留指向可用内存的引用，以供分配新对象，最后为了提升性能，删除了未引用对象后，还可以将剩下的已引用对象放在一起（压缩），这样就能更简单快捷地分配新对象了。一般可以设置N次标记清除之后，压缩一次。其中N最多15次。</p><p><strong>4、分代收集算法：</strong></p><ul><li>新生代的目标就是尽可能快速的收集掉那些生命周期短的对象，一般情况下，所有新生成的对象首先都是放在新生代的。新生代内存按照 8:1:1 的比例分为一个eden区和两个survivor(survivor0，survivor1)区，大部分对象在Eden区中生成。在进行垃圾回收时，先将eden区存活对象复制到survivor0区，然后清空eden区，当这个survivor0区也满了时，则将eden区和survivor0区存活对象复制到survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后交换survivor0区和survivor1区的角色（即下次垃圾回收时会扫描Eden区和survivor1区），即保持survivor0区为空，如此往复。特别地，当survivor1区也不足以存放eden区和survivor0区的存活对象时，就将存活对象直接存放到老年代。如果老年代也满了，就会触发一次FullGC，也就是新生代、老年代都进行回收。注意，新生代发生的GC也叫做MinorGC，MinorGC发生频率比较高，不一定等 Eden区满了才触发。</li><li>老年代存放的都是一些生命周期较长的对象，就像上面所叙述的那样，在新生代中经历了N次垃圾回收后仍然存活的对象就会被放到老年代中。此外，老年代的内存也比新生代大很多(大概比例是1:2)，当老年代满时会触发Major GC(Full GC)，老年代对象存活时间比较长，因此FullGC发生的频率比较低。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程</title>
      <link href="2021/05/05/duo-xian-cheng/"/>
      <url>2021/05/05/duo-xian-cheng/</url>
      
        <content type="html"><![CDATA[<h4 id="实现线程的方式有哪些"><a href="#实现线程的方式有哪些" class="headerlink" title="实现线程的方式有哪些"></a>实现线程的方式有哪些</h4><ul><li>实现Runnable接口</li><li>继承Thread类</li><li>实现Callable接口</li></ul><h5 id="继承Thread类的调用过程"><a href="#继承Thread类的调用过程" class="headerlink" title="继承Thread类的调用过程"></a>继承Thread类的调用过程</h5><ul><li>书写一个类继承Thread类让其具有多线程的功能，并实现run（）方法</li><li>启动线程，该类调用start（）方法进行调用</li></ul><h5 id="实现runnable接口的调用过程"><a href="#实现runnable接口的调用过程" class="headerlink" title="实现runnable接口的调用过程"></a>实现runnable接口的调用过程</h5><ul><li>书写一个类实现Runnable接口让其具有多线程的功能，并实现run()方法</li><li>启动线程，new Thread(类的对象)调用start()方法。</li></ul><h5 id="实现Callable接口的调用过程"><a href="#实现Callable接口的调用过程" class="headerlink" title="实现Callable接口的调用过程"></a>实现Callable接口的调用过程</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">//书写一个类实现Callable接口让其具有多线程的功能，并实现call（）方法，且需要自定义一个返回值类型//实例化对象CallableTest callableTest = new CallableTest();//创建一个线程池 1代表之启动一个线程ExecutorService executorService = Executors.newFixedThreadPool(1);//执行Future&lt;Boolean&gt; future = executorService.submit(callableTest);//获取结果boolean f1 = future.get();//关闭服务executorService.shutdown();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>线程启动之后，不一定立即执行，而是等待CPU调度，即多个线程执行时结果顺序是不一致的。推荐使用runnable接口，由于java的单继承概念，如果继承Thread类灵活性会很差。</p><p>实现callable接口相对于其他两个优点是有返回值且可以抛出异常，缺点是实现比较麻烦。</p><h4 id="线程中常用的方法"><a href="#线程中常用的方法" class="headerlink" title="线程中常用的方法"></a>线程中常用的方法</h4><h5 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h5><p>停止线程的方式不建议使用stop等方法，而是建立一个标志位，如果标志位不成立，则停止该线程，即用手动控制，避免死锁。</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">public class TestStop implements Runnable{    //设置一个标志位标识是否停止    private boolean flag =true;        @Override    public void run() {        int i=0;        while (flag){            System.out.println("new Thread"+i);        }    }    //如果运行此方法标识停止    private void stop(){       this.flag =false;    }    public static void main(String[] args) {        TestStop testStop = new TestStop();        new Thread(testStop).start();        for (int i = 0; i &lt; 500; i++) {            System.out.println("main"+i);            if(i==450){                testStop.stop();                System.out.println("线程停止了");            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="线程休眠sleep"><a href="#线程休眠sleep" class="headerlink" title="线程休眠sleep"></a>线程休眠sleep</h5><ul><li>sleep休眠的时间指的是毫秒数</li><li>sleep的时间达到后线程进入就绪状态</li><li>sleep一般应用于倒计时、网络延迟等</li><li>每个对象都会有一个锁，sleep不会释放锁</li></ul><h5 id="线程礼让yield"><a href="#线程礼让yield" class="headerlink" title="线程礼让yield"></a>线程礼让yield</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">//正常流程a线程开始执行、a线程结束执行、b线程开始执行、b线程结束执行//Thread.yield()可重新让cpu调度，即有可能礼让成功，有可能礼让失败public class YieldTest implements Runnable{    @Override    public void run() {        System.out.println(Thread.currentThread().getName()+"线程开始执行");        //礼让线程        Thread.yield();        System.out.println(Thread.currentThread().getName()+"线程结束执行");    }    public static void main(String[] args) {        YieldTest yieldTest = new YieldTest();        new Thread(yieldTest,"a").start();        new Thread(yieldTest,"b").start();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="线程插队join"><a href="#线程插队join" class="headerlink" title="线程插队join"></a>线程插队join</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">//即线程在执行过程中如果添加Thread.join，则需强制执行该对象所在的线程public class JoinTest implements Runnable {    @Override    public void run() {        for (int i = 0; i &lt; 1000; i++) {            System.out.println("vip"+i);        }    }    public static void main(String[] args) throws InterruptedException {        JoinTest joinTest = new JoinTest();        Thread thread  =   new Thread(joinTest);        thread.start();        for (int i = 0; i &lt; 500; i++) {            if(i==200){                thread.join();            }            System.out.println("main"+i);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="线程状态观测"><a href="#线程状态观测" class="headerlink" title="线程状态观测"></a>线程状态观测</h5><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">//锁定状态Thread.State blocked1 = Thread.State.BLOCKED;//新生状态  运行start方法Thread.State blocked2 =Thread.State.NEW;//运行状态运行run方法Thread.State blocked3 =Thread.State.RUNNABLE;//死亡状态  最后结束时的状态Thread.State blocked4 =Thread.State.TERMINATED;//睡眠状态 sleep方法Thread.State blocked5 =Thread.State.TIMED_WAITING;//等待状态 wait方法Thread.State blocked6 =Thread.State.WAITING;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">//设置线程的优先级t3.setPriority（数值），最小为1，最大为10，超过抛出异常，优先级高的不一定最先执行，但大概率会优先执行public class PriorityTest implements Runnable{    @Override    public void run() {        System.out.println(Thread.currentThread().getName()+"-&lt;&lt;"+Thread.currentThread().getPriority());    }    public static void main(String[] args) {        System.out.println(Thread.currentThread().getName()+"-&lt;&lt;"+Thread.currentThread().getPriority());        PriorityTest priorityTest = new PriorityTest();        Thread t1 = new Thread(priorityTest);        Thread t2 = new Thread(priorityTest);        Thread t3 = new Thread(priorityTest);        Thread t4 = new Thread(priorityTest);        Thread t5 = new Thread(priorityTest);        t1.start();        t2.setPriority(2);        t2.start();        t3.setPriority(Thread.MAX_PRIORITY);        t3.start();        t4.setPriority(9);        t4.start();        t5.setPriority(Thread.MIN_PRIORITY);        t5.start();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="线程守护"><a href="#线程守护" class="headerlink" title="线程守护"></a>线程守护</h5><ul><li>线程分为守护线程和用户线程，我们平常用的都是用户线程</li><li>虚拟机必须确保用户线程执行完毕</li><li>虚拟机不必等待守护线程执行完毕</li><li>守护线程一般用作操作日志、垃圾回收、监控内存等</li><li>设置线程为守护线程的方式是Thread.setDaemon(true);</li></ul><pre class="line-numbers language-none"><code class="language-none">//设置线程的优先级t3.setPriority（数值），最小为1，最大为10，超过抛出异常，优先级高的不一定最先执行，但大概率会优先执行public class PriorityTest implements Runnable{    @Override    public void run() {        System.out.println(Thread.currentThread().getName()+"-&lt;&lt;"+Thread.currentThread().getPriority());    }    public static void main(String[] args) {        System.out.println(Thread.currentThread().getName()+"-&lt;&lt;"+Thread.currentThread().getPriority());        PriorityTest priorityTest = new PriorityTest();        Thread t1 = new Thread(priorityTest);        Thread t2 = new Thread(priorityTest);        Thread t3 = new Thread(priorityTest);        Thread t4 = new Thread(priorityTest);        Thread t5 = new Thread(priorityTest);        t1.start();        t2.setPriority(2);        t2.start();        t3.setPriority(Thread.MAX_PRIORITY);        t3.start();        t4.setPriority(9);        t4.start();        t5.setPriority(Thread.MIN_PRIORITY);        t5.start();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="线程同步锁synchronized"><a href="#线程同步锁synchronized" class="headerlink" title="线程同步锁synchronized"></a>线程同步锁synchronized</h5><ul><li>锁的对象是变换的对象，即this信息。</li><li>用synchronized修饰的方法或者代码块表示同步信息，即一个线程进入某个方法之后，其他线程只能等待当前线程结束才能访问</li><li>上锁的功能都是修改的功能</li><li>由于每个线程都需要上锁，造成资源浪费</li><li>如果线程内部存在调用且也是同步方法时可能会造成死锁</li></ul><h5 id="显式锁lock"><a href="#显式锁lock" class="headerlink" title="显式锁lock"></a>显式锁lock</h5><ul><li>lock是显式锁即需要加锁和解锁的过程，synchronized是隐式锁即出了锁定域自动解锁</li><li>lock只能锁定代码块，synchronized能锁定方法和代码块</li><li>lock锁的性能更好</li></ul><h5 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h5><h6 id="死锁产生的4个必要条件"><a href="#死锁产生的4个必要条件" class="headerlink" title="死锁产生的4个必要条件"></a>死锁产生的4个必要条件</h6><ul><li>互斥条件：一个资源每次只能被一个进程使用</li><li>请求和保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放</li><li>不可剥夺条件：进程已获得的资源，在未使用完成，不能强行剥夺</li><li>循环等待条件：若干进程之间形成一种头尾相接的循环等待关系</li></ul>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注解</title>
      <link href="2021/05/03/zhu-jie/"/>
      <url>2021/05/03/zhu-jie/</url>
      
        <content type="html"><![CDATA[<h4 id="Qualifier-如果项目中自定义的注解跟底层一样，则可使用次注解来标识项目中运用。"><a href="#Qualifier-如果项目中自定义的注解跟底层一样，则可使用次注解来标识项目中运用。" class="headerlink" title="@Qualifier    如果项目中自定义的注解跟底层一样，则可使用次注解来标识项目中运用。"></a>@Qualifier    如果项目中自定义的注解跟底层一样，则可使用次注解来标识项目中运用。</h4>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>精句</title>
      <link href="2021/05/03/jing-ju/"/>
      <url>2021/05/03/jing-ju/</url>
      
        <content type="html"><![CDATA[<h4 id="知其然并知其所以然，授人以鱼不如授人以渔！学习需慢慢来，不能太过急躁。"><a href="#知其然并知其所以然，授人以鱼不如授人以渔！学习需慢慢来，不能太过急躁。" class="headerlink" title="知其然并知其所以然，授人以鱼不如授人以渔！学习需慢慢来，不能太过急躁。"></a>知其然并知其所以然，授人以鱼不如授人以渔！学习需慢慢来，不能太过急躁。</h4>]]></content>
      
      
      <categories>
          
          <category> 感悟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis进阶</title>
      <link href="2021/05/03/redis-shi-wu/"/>
      <url>2021/05/03/redis-shi-wu/</url>
      
        <content type="html"><![CDATA[<h3 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h3><p>Redis事务本质是一种命令的集合，一个事务中的所有命令都会被序列化，且按照顺序执行！</p><p>Redis事务没有隔离级别的概念，即没有mysql的脏读等事情发生</p><p>Redis的单条命令是具有原子性的，多条命令不具有原子性</p><ul><li>开启事务（multi）</li><li>命令入队（。。。。。）</li><li>执行事务（exec）</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#一个完整的事务执行过程</span></span><br><span class="line">127.0.0.1:6379&gt; MULTI<span class="comment">#开启一个事务</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k1 v1<span class="comment">#在事务中执行操作</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2 v2 </span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span><span class="comment">#执行事务</span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) <span class="string">"v2"</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#如果在事务中做了取消操作，则所有操作都不会执行，此时具有原子性</span></span><br><span class="line">127.0.0.1:6379&gt; MULTI<span class="comment">#开启事务</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k1 v1 <span class="comment">#执行操作</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; DISCARD<span class="comment">#取消事务</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">(nil)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#编译时异常，即系统检测出的异常，此时具有原子性</span></span><br><span class="line">27.0.0.1:6379&gt; MULTI<span class="comment">#开启事务</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k1 v1<span class="comment">#执行正确操作</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; getset k1<span class="comment">#执行错误操作</span></span><br><span class="line">(error) ERR wrong number of arguments <span class="keyword">for</span> <span class="string">'getset'</span> <span class="built_in">command</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span> <span class="comment">#执行事务时提示所有操作都未成功</span></span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#运行时异常，即系统运行过程中才检测到异常，此时不具有原子性</span></span><br><span class="line">127.0.0.1:6379&gt; MULTI<span class="comment">#开启事务</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k1 v1<span class="comment">#执行正确操作</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; incr k1<span class="comment">#执行错误操作，向String中自增</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span><span class="comment">#执行事务，则提示第三步错误，其他都正常运行</span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) (error) ERR value is not an <span class="built_in">integer</span> or out of range</span><br><span class="line">4) <span class="string">"v2"</span></span><br></pre></td></tr></tbody></table></figure><h3 id="redis的监控"><a href="#redis的监控" class="headerlink" title="redis的监控"></a>redis的监控</h3><blockquote><p>乐观锁是什么</p></blockquote><p>无论什么时候都认为不会出现问题，所以不用上锁，更新数据的适合判断一下是否有人修改过数据即可。</p><blockquote><p>悲观锁是什么</p></blockquote><p>无论什么时候都认为会出现问题，所以执行过程中都会增加一个锁。效率过慢</p><blockquote><p>redis的乐观锁用watch进行表示</p></blockquote><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#一个正常的操作</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> money 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> out 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch money<span class="comment">#开启监控</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; decrby money 60<span class="comment">#减少60</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; INCRBY out 60<span class="comment">#增加60</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 40</span><br><span class="line">2) (<span class="built_in">integer</span>) 60</span><br></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#一个错误信息的执行过程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#线程1</span></span><br><span class="line">127.0.0.1:6379&gt; WATCH money<span class="comment">#监控money</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; DECRby money 10<span class="comment">#对money进行操作</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; INCRBY out 10</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span> <span class="comment">#执行事务不成功</span></span><br><span class="line">(nil)</span><br><span class="line"><span class="comment">#线程2</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> money 1000<span class="comment">#线程2修改了监控的money</span></span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; UNWATCH<span class="comment">#取消所有监控信息</span></span><br><span class="line">OK</span><br></pre></td></tr></tbody></table></figure><h3 id="设置redis的密码"><a href="#设置redis的密码" class="headerlink" title="设置redis的密码"></a>设置redis的密码</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config <span class="built_in">set</span> requirepass 123456<span class="comment">#设置redis的密码</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exit</span></span><br><span class="line">root@5a78b143c447:/data<span class="comment"># redis-cli</span></span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line">127.0.0.1:6379&gt; auth 123456<span class="comment">#密码认证</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br></pre></td></tr></tbody></table></figure><h3 id="RDB（redis-database）持久化"><a href="#RDB（redis-database）持久化" class="headerlink" title="RDB（redis database）持久化"></a>RDB（redis database）持久化</h3><blockquote><p>触发机制产生dump.rdb文件</p></blockquote><ul><li>配置文件中设置的save规则如果满足条件即可触发，例如save 900 1 （如果900s内存在一次更改或添加操作）</li><li>执行flushAll命令，也会触发持久化配置产生rdb文件</li><li>退出redis也可产生rdb文件。</li></ul><blockquote><p>如何恢复rdb文件</p></blockquote><p>找到rdb文件需识别的目录，启动redis的适合会自动加载</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get dir<span class="comment">#输出此命令可查看rdb文件所在目录</span></span><br><span class="line">1) <span class="string">"dir"</span></span><br><span class="line">2) <span class="string">"/etc"</span></span><br></pre></td></tr></tbody></table></figure><p><strong>优点</strong></p><ol><li>适合大规模的数据恢复</li><li>对数据的完整性不高</li></ol><p><strong>缺点</strong></p><ol><li>需要一定的时间间隔进程操作，如果redis意外down了，则最后一次修改的数据就持久化不成功。</li><li>fork进行的时候，暂用一定的内存空间。</li></ol><h3 id="AOF（append-only-file）持久化"><a href="#AOF（append-only-file）持久化" class="headerlink" title="AOF（append only file）持久化"></a>AOF（append only file）持久化</h3><p>由于redis的默认持久化方式为RDB，需修改配置文件中的APPENDONLY 为YES则表示AOF持久化</p><p>AOF持久化产生的文件名为appendOnly.aof文件</p><p>AOF持久化的方式有三种：</p><ul><li>appendfSync    always        每次修改都会sync，比较消耗性能</li><li>appendfSync    everysec    每秒执行一次sync，可能会丢失这1s的数据，默认的方式</li><li>appendfSync    no               不执行sync，操作系统回自己同步数据，速度最快</li></ul><p><strong>优缺点</strong></p><ol><li>相对于rdb的方式，数据的完整性更好</li><li>相对于rdb的方式，aof的文件远大于rdb文件，修复速度也比rdb慢</li><li>运行效率也比rdb慢</li></ol><h3 id="Redis消息队列"><a href="#Redis消息队列" class="headerlink" title="Redis消息队列"></a>Redis消息队列</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 消息接收者</span></span><br><span class="line">127.0.0.1:6379&gt; SUBSCRIBE wei <span class="comment">#设置接收数据的频道wei</span></span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">"subscribe"</span></span><br><span class="line">2) <span class="string">"wei"</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line">1) <span class="string">"message"</span><span class="comment">#下三步则为接收到数据信息</span></span><br><span class="line">2) <span class="string">"wei"</span></span><br><span class="line">3) <span class="string">"123232"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#消息发送者</span></span><br><span class="line">127.0.0.1:6379&gt; PUBLISH wei 123232<span class="comment">#发送到wei频道信息</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></tbody></table></figure><h3 id="Redis的主从复制"><a href="#Redis的主从复制" class="headerlink" title="Redis的主从复制"></a>Redis的主从复制</h3><blockquote><p>主从复制的概念</p></blockquote><p>主从复制试讲一台Redis服务器复制到其他服务器，前者称为主节点（master/leader),后者称为从节点（slave/follower）;数据的复制是单向的，只能从主节点到从节点，其中master为主，slave为从。</p><blockquote><p>主从复制的作用是什么</p></blockquote><ol><li>数据冗余：实现了数据的热备份，是持久化之外的一种数据冗余模式</li><li>故障恢复：当主节点出现问题时，可以有从节点提供服务，实现快速的故障恢复，实际上是一种服务的冗余。</li><li>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，从节点提供读服务，分担服务器负载。</li><li>高可用：除了上述作用外，主从复制还采用了哨兵和集群模式，实现了redis的高可用。</li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; INFO replication<span class="comment">#查看当前redis的机器信息</span></span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master<span class="comment">#角色信息（主机）</span></span><br><span class="line">connected_slaves:0<span class="comment">#从机数量</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master<span class="comment">#主机标识</span></span><br><span class="line">connected_slaves:1<span class="comment">#链接的从机数目</span></span><br><span class="line">slave0:ip=47.101.169.95,port=6379,state=online,offset=14,lag=0<span class="comment">#从机的基本信息</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave<span class="comment">#从机</span></span><br><span class="line">master_host:47.100.3.247<span class="comment">#连接到的主机信息</span></span><br><span class="line">master_port:6379</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><blockquote><p>哨兵模式的概念</p></blockquote><p>主从切换技术的方法是：当主服务器down后，需要手动选择一台服务器作为主服务器，需要人工干预，费时费力，并且还会造成一段时间的不可用，因此产生一个全新的自动化模式sentinel来解决这个问题。如果主机down，从机则会根据一定的算法选择从机做为主机。如果主机在连接则只能作为从机，主机还是原来推举出来的。</p><blockquote><p>哨兵的作用</p></blockquote><ul><li>通过发送命令，检测主服务器和从服务器的运行状态</li><li>当master宕机，会自动将slave转换为master，然后通知其他服务器，修改配置文件，让他们切换主机。</li><li>哨兵也可能存在down的可能，因此会布置多个哨兵互相监控。</li></ul><blockquote><p>哨兵配置</p></blockquote><p>1、配置sentinel.conf</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sentinel monitor myredis host port  1   </span></span><br><span class="line">sentinel monitor myredis 47.100.3.247 6379  1<span class="comment">#1表示主机挂了，slave投票谁最多谁成为主机</span></span><br><span class="line"><span class="comment">#具体的配置后续再了解，目前只配置最基础的配置</span></span><br></pre></td></tr></tbody></table></figure><p>2、启动哨兵</p><figure class="highlight cmd"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel sentinel.conf</span><br></pre></td></tr></tbody></table></figure><p><strong>优点：</strong></p><ol><li>哨兵集群，基于主从复制模式，所有的主从配置有点都拥有</li><li>主从可以切换，故障可以转移，系统的可用性会更好</li><li>哨兵模式是主从模式的升级，手动改为自动更加的健壮</li></ol><p><strong>缺点：</strong></p><ol><li>哨兵模式的扩容非常麻烦</li><li>配置相对来说比较麻烦</li></ol>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis特殊数据类型</title>
      <link href="2021/05/03/redis-te-shu-shu-ju-lei-xing/"/>
      <url>2021/05/03/redis-te-shu-shu-ju-lei-xing/</url>
      
        <content type="html"><![CDATA[<h3 id="geospatial地理位置"><a href="#geospatial地理位置" class="headerlink" title="geospatial地理位置"></a>geospatial地理位置</h3><p>应用场景: 朋友圈定位、附近的距离、地理位置的计算</p><p>常用命令：</p><p>geoadd 添加经纬度信息</p><p>geopos 查询经纬度信息</p><p>geodist 查询两个位置直接的直线距离</p><p>geoRadius    查询某个坐标下（经度、维度）的所有位置信息</p><p>georadiusBymember    查询某个坐标下（集合内的数据）的位置信息</p><p>geohash    返回某个城市的一维数据，11位</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#顺序为key、经度、维度、城市</span></span><br><span class="line"><span class="comment">#有效的经度从-180度到180度。</span></span><br><span class="line"><span class="comment">#有效的纬度从-85.05112878度到85.05112878度。</span></span><br><span class="line"><span class="comment">#如果超过则会提示如下错误</span></span><br><span class="line">127.0.0.1:6379&gt; GEOADD china:city 116.405289 39.904987 beijing<span class="comment">#添加地理位置信息</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; GEOADD china:city 117.190186 39.125595 tianqing 114.502464  38.045475 shijiazhuang 126.642464 45.756966 haerbing 121.472641 31.231707 shanghai</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; GEOADD china:city 113.374375 23.368923 guangzhou</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">"china:city"</span></span><br><span class="line">127.0.0.1:6379&gt; GEOADD china:city    23.368923  113.374375  guangzhou<span class="comment">#位置信息添加错误提示</span></span><br><span class="line">(error) ERR invalid longitude,latitude pair 23.368923,113.374375</span><br><span class="line">127.0.0.1:6379&gt; GEOPOS china:city beijing tianqing<span class="comment">#查看当前经纬度的值</span></span><br><span class="line">1) 1) <span class="string">"116.40528827905654907"</span></span><br><span class="line">   2) <span class="string">"39.90498588819134085"</span></span><br><span class="line">2) 1) <span class="string">"117.19018846750259399"</span></span><br><span class="line">   2) <span class="string">"39.12559461779084558"</span></span><br><span class="line"><span class="comment">#获取两人之间的距离</span></span><br><span class="line">127.0.0.1:6379&gt; GEODIST china:city beijing tianqing km<span class="comment">#获取两地之间的距离，单位为km</span></span><br><span class="line"><span class="string">"109.7753"</span></span><br><span class="line"><span class="comment">#查询附近的人key、经度、维度、半径、单位、直接距离、总数</span></span><br><span class="line">127.0.0.1:6379&gt; GEORADIUS china:city 100 30 1000 km withdist count 3<span class="comment">#查询某个经纬度内半径为1000km的地点3个位置</span></span><br><span class="line">(empty array)</span><br><span class="line"><span class="comment">#查询以某个集合内的位置作为基础半径内的位置信息</span></span><br><span class="line">127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city beijing 500 km withdist</span><br><span class="line">1) 1) <span class="string">"shijiazhuang"</span></span><br><span class="line">   2) <span class="string">"264.2750"</span></span><br><span class="line">2) 1) <span class="string">"tianqing"</span></span><br><span class="line">   2) <span class="string">"109.7753"</span></span><br><span class="line">3) 1) <span class="string">"beijing"</span></span><br><span class="line">   2) <span class="string">"0.0000"</span></span><br><span class="line"><span class="comment">#获取某个城市的一维字符串</span></span><br><span class="line">127.0.0.1:6379&gt; GEOHASH china:city beijing</span><br><span class="line">1) <span class="string">"wx4g0b7xru0"</span></span><br><span class="line">127.0.0.1:6379&gt; GEOHASH china:city shanghai guangzhou</span><br><span class="line">1) <span class="string">"wtw3sjt9vs0"</span></span><br><span class="line">2) <span class="string">"ws0sgyhty70"</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>地理位置的底层实现是根据zset进行操作的。</p></blockquote><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZRAnge china:city 0 -1<span class="comment">#查询所有的经纬度信息</span></span><br><span class="line">1) <span class="string">"guangzhou"</span></span><br><span class="line">2) <span class="string">"shanghai"</span></span><br><span class="line">3) <span class="string">"shijiazhuang"</span></span><br><span class="line">4) <span class="string">"tianqing"</span></span><br><span class="line">5) <span class="string">"beijing"</span></span><br><span class="line">6) <span class="string">"haerbing"</span></span><br><span class="line">127.0.0.1:6379&gt; zrem china:city beijing<span class="comment">#删除某个经纬度信息</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ZRAnge china:city 0 -1</span><br><span class="line">1) <span class="string">"guangzhou"</span></span><br><span class="line">2) <span class="string">"shanghai"</span></span><br><span class="line">3) <span class="string">"shijiazhuang"</span></span><br><span class="line">4) <span class="string">"tianqing"</span></span><br><span class="line">5) <span class="string">"haerbing"</span></span><br></pre></td></tr></tbody></table></figure><h3 id="Hyperloglog数据类型"><a href="#Hyperloglog数据类型" class="headerlink" title="Hyperloglog数据类型"></a>Hyperloglog数据类型</h3><p>优点：占用的内存是固定的，可以存取2的64个不同的元素，只需要12kb的内存。</p><p>缺点：是有0.81%的错误率，一般可以忽略不计。</p><p>目的：处理集合中不同的元素总数，跟set的用途一致。</p><ul><li>pfadd         添加元素</li><li>pfcount      计算元素总数</li><li>pfmegre    合并两个元素为一个全新的元素</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PFADD key a b c d e f g h i j k<span class="comment">#向集合中添加元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT key<span class="comment">#查看当前集合的元素总数</span></span><br><span class="line">(<span class="built_in">integer</span>) 11</span><br><span class="line">127.0.0.1:6379&gt; PFADD key1 f f  n f e p o <span class="comment">#重复元素的按1计算</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT key1</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; PFMERGE key2 key key1<span class="comment">#合并两个key的元素为最新的key</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT key2</span><br><span class="line">(<span class="built_in">integer</span>) 14</span><br></pre></td></tr></tbody></table></figure><h3 id="BItMaps数据类型"><a href="#BItMaps数据类型" class="headerlink" title="BItMaps数据类型"></a>BItMaps数据类型</h3><p>表示位运算，一般应用场景是统计某个事情的真总数，以判断是否成立，例如：统计某员工一个月内的打卡次数</p><ul><li>setbit     key   offset  0/1           给某个key设置一个事件，用0表示假、1表示真</li><li>getbit     key   offset                   获取这个key值的事件状态即0/1</li><li>bitcount     key                            查询某个key的真事件的总数</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setbit key 1 0<span class="comment">#设置某个元素的某种事件值是0或者1</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit key 2 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit key 2 0</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit key 2<span class="comment">#获取该元素的事件状态</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit key 3 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; BITCOUNT key<span class="comment">#获取某个元素的为1的时间总数</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit key 3 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; BITCOUNT key</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis常用命令</title>
      <link href="2021/04/29/redis-chang-yong-ming-ling/"/>
      <url>2021/04/29/redis-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<h3 id="redis的命令查找网址"><a href="#redis的命令查找网址" class="headerlink" title="redis的命令查找网址"></a>redis的命令查找网址</h3><p><a href="http://www.redis.cn/commands.html">http://www.redis.cn/commands.html</a></p><h3 id="redis的基本命令"><a href="#redis的基本命令" class="headerlink" title="redis的基本命令"></a>redis的基本命令</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; FLUSHALL#清空所有数据库</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set name '123'#设置key为name的值</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set age 1#设置key为age的值</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name#获取key为name的值，如果不存在key值则返回nil。</span><br><span class="line">"123"</span><br><span class="line">127.0.0.1:6379&gt; gea age</span><br><span class="line">(error) ERR unknown command `gea`, with args beginning with: `age`, </span><br><span class="line">127.0.0.1:6379&gt; get age#获取key为age的值</span><br><span class="line">"1"</span><br><span class="line">127.0.0.1:6379&gt; EXISTS naem#查询是否存在此key值，存在返回1，否则返回0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; EXISTS name</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; move name 1#移除key值，成功返回1，失败返回0</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; keys *#查询当前存在的key值</span><br><span class="line">1) "age"</span><br><span class="line">127.0.0.1:6379&gt; EXPIRE age 15#设置key值得过期时间</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl name</span><br><span class="line">(integer) -2</span><br><span class="line">127.0.0.1:6379&gt; ttl age#查看当前key的剩余时间，如果key值不存在则返回-2</span><br><span class="line">(integer) 7</span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(integer) -2</span><br><span class="line">127.0.0.1:6379&gt; type age#查看key值得返回类型</span><br><span class="line">String</span><br></pre></td></tr></tbody></table></figure><h3 id="String基本数据类型"><a href="#String基本数据类型" class="headerlink" title="String基本数据类型"></a>String基本数据类型</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; FLUSHALL</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; set key1 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">"1"</span><br><span class="line">127.0.0.1:6379&gt; EXISTS key1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; EXISTS key1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; EXISTS key2</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; APPEND key1 2#给某个key追加一个值，如果当前值不存在则创建当前key，返回的当前value的长度</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) "key1"</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">"12"</span><br><span class="line">127.0.0.1:6379&gt; STRLEN key1#查看当前key的长度</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; append key1 '321321'</span><br><span class="line">(integer) 8</span><br><span class="line">127.0.0.1:6379&gt; STRLEN key1</span><br><span class="line">(integer) 8</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">"12321321"</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set view 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get view</span><br><span class="line">"0"</span><br><span class="line">127.0.0.1:6379&gt; incr view#给某个字段字段增加1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; incr view</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; incr view</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; decr view#给某个字段自动减少1</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; INCRBY view 10#给某个字段增加10</span><br><span class="line">(integer) 12</span><br><span class="line">127.0.0.1:6379&gt; INCRBY view 10</span><br><span class="line">(integer) 22</span><br><span class="line">127.0.0.1:6379&gt; decrby view 5#给某个字段减少5</span><br><span class="line">(integer) 17</span><br><span class="line">127.0.0.1:6379&gt; incr key1#如果自增的数据不是Integer类型则提示错误</span><br><span class="line">(error) ERR value is not an integer or out of range</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key1 abcde</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">"abcde"</span><br><span class="line">127.0.0.1:6379&gt; GETRANGE key1 0 3#获取下表0-3的数据</span><br><span class="line">"abcd"</span><br><span class="line">127.0.0.1:6379&gt; GETRANGE key1 0 -1 #获取全部的数据</span><br><span class="line">"abcde"</span><br><span class="line">127.0.0.1:6379&gt; SETRANGE key1 0 111#从下表为0开始替换数据，长度为值得长度</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; get key1 </span><br><span class="line">"111de"</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; clear</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) "key1"</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">"111de"</span><br><span class="line">127.0.0.1:6379&gt; SETNX key1 'abcde'#设置某个值如果存在则不替换，不存在则添加</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">"111de"</span><br><span class="line">127.0.0.1:6379&gt; SETEX key1 30 abcde#设置某个值存在即替换，不存在则添加，且设置其过去时间为30s.</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">"abcde"</span><br><span class="line">127.0.0.1:6379&gt; ttl key1#查看剩余时间，如果过期或者不存在则返回0</span><br><span class="line">(integer) 22</span><br><span class="line">127.0.0.1:6379&gt; ttl key1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; FLUSHdb</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3#设置多个key/value值</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) "k3"</span><br><span class="line">2) "k2"</span><br><span class="line">3) "k1"</span><br><span class="line">127.0.0.1:6379&gt; mset k1 v1 k4 v4#设置多个，如果存在则替换，不存在则添加</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) "k3"</span><br><span class="line">2) "k2"</span><br><span class="line">3) "k1"</span><br><span class="line">4) "k4"</span><br><span class="line">127.0.0.1:6379&gt; MSETNX k1 v1 k5 v5#设置多个，如果存在则全部失败，因为redis具有原子性。</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) "k3"</span><br><span class="line">2) "k2"</span><br><span class="line">3) "k1"</span><br><span class="line">4) "k4"</span><br><span class="line">127.0.0.1:6379&gt; get k5</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; GETSET db redis#获取key值并设置key值，返回值为实现get的key值</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get db</span><br><span class="line">"redis"</span><br><span class="line">127.0.0.1:6379&gt; getset db mysql</span><br><span class="line">"redis"</span><br><span class="line">127.0.0.1:6379&gt; get db</span><br><span class="line">"mysql"</span><br></pre></td></tr></tbody></table></figure><h3 id="List基本数据类型"><a href="#List基本数据类型" class="headerlink" title="List基本数据类型"></a>List基本数据类型</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; FLUSHdb</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; LPUSH list a b c#从左侧插入一直list，返回的是当前集合的长度</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; lpush list d e</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; RPUSH list f g#从右侧插入一个list</span><br><span class="line">(integer) 7</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1 #获取list的所有值</span><br><span class="line">1) "e"</span><br><span class="line">2) "d"</span><br><span class="line">3) "c"</span><br><span class="line">4) "b"</span><br><span class="line">5) "a"</span><br><span class="line">6) "f"</span><br><span class="line">7) "g"</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 1  5#获取list下标为1-5的值</span><br><span class="line">1) "d"</span><br><span class="line">2) "c"</span><br><span class="line">3) "b"</span><br><span class="line">4) "a"</span><br><span class="line">5) "f"</span><br><span class="line">127.0.0.1:6379&gt; RPOP list #移除右边的第一个元素</span><br><span class="line">"g"</span><br><span class="line">127.0.0.1:6379&gt; RPOP list 2#移除右边的2个元素</span><br><span class="line">1) "f"</span><br><span class="line">2) "a"</span><br><span class="line">127.0.0.1:6379&gt; LPOP list 2#移除左边边的2个元素</span><br><span class="line">1) "b"</span><br><span class="line">2) "c"</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) "e"</span><br><span class="line">2) "d"</span><br><span class="line">127.0.0.1:6379&gt; LINDEX list 1#获取当前集合下标为1的元素</span><br><span class="line">"d"</span><br><span class="line">127.0.0.1:6379&gt; LLEN list#获取list集合的长度</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) "e"</span><br><span class="line">2) "d"</span><br><span class="line">127.0.0.1:6379&gt; LPUSH list e#王list中添加一个重复元素</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; LREM list 2 e#删除list中为e的元素，且值的个数为2</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) "d"</span><br><span class="line">127.0.0.1:6379&gt; FLUSHdb </span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; clear</span><br><span class="line">127.0.0.1:6379&gt; lpush list hello1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; lpush list hello2</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; lpush list hello2</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; lpush list hello3</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; lpush list hello4</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; LREM list 1 hello 2</span><br><span class="line">(error) ERR wrong number of arguments for 'lrem' command</span><br><span class="line">127.0.0.1:6379&gt; LREM list 1 hello2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) "hello4"</span><br><span class="line">2) "hello3"</span><br><span class="line">3) "hello2"</span><br><span class="line">4) "hello1"</span><br><span class="line">127.0.0.1:6379&gt; LPUSH list hello5</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) "hello5"</span><br><span class="line">2) "hello4"</span><br><span class="line">3) "hello3"</span><br><span class="line">4) "hello2"</span><br><span class="line">5) "hello1"</span><br><span class="line">127.0.0.1:6379&gt; LTRIM list 1 2#截取当前key的下标为1到2的值</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) "hello4"</span><br><span class="line">2) "hello3"</span><br><span class="line">127.0.0.1:6379&gt; RPOPLPUSH list mylist#截取list右侧第一个元素把他存入到mylist的最左侧</span><br><span class="line">"hello3"</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1#查看list的所有值</span><br><span class="line">1) "hello4"</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1#查看mylist的所有值</span><br><span class="line">1) "hello3"</span><br><span class="line">127.0.0.1:6379&gt; FLUSHdb</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; EXISTS list#查看是否存在当前key值</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; lset list 0 redis#往当前key值中set一个下标为0的数据，如果不存在则提示错误，存在则替换</span><br><span class="line">(error) ERR no such key</span><br><span class="line">127.0.0.1:6379&gt; LPUSH list mysql</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; lset list 0 redis</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) "redis"</span><br><span class="line">127.0.0.1:6379&gt; lset list 1 redis</span><br><span class="line">(error) ERR index out of range</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#############################################</span></span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) "redis"</span><br><span class="line">127.0.0.1:6379&gt; lpush list myql</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) "myql"</span><br><span class="line">2) "redis"</span><br><span class="line">127.0.0.1:6379&gt; LINSERT list before 'mysql' mysql1</span><br><span class="line">(integer) -1</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) "myql"</span><br><span class="line">2) "redis"</span><br><span class="line">127.0.0.1:6379&gt; LINSERT list after 'mysql' mysql1</span><br><span class="line">(integer) -1</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) "myql"</span><br><span class="line">2) "redis"</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) "list"</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) "myql"</span><br><span class="line">2) "redis"</span><br><span class="line">127.0.0.1:6379&gt; LINSERT list after "redis" "mysql1"#往某个key得之前或之后插入一个值，值不能是下标为0的数据。</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) "myql"</span><br><span class="line">2) "redis"</span><br><span class="line">3) "mysql1"</span><br><span class="line">127.0.0.1:6379&gt; LINSERT list before "redis" "mysql1"</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; LRANGE list 0 -1</span><br><span class="line">1) "myql"</span><br><span class="line">2) "mysql1"</span><br><span class="line">3) "redis"</span><br><span class="line">4) "mysql1"</span><br><span class="line">127.0.0.1:6379&gt; LINSERT list before "mysql" "mysql1"</span><br><span class="line">(integer) -1</span><br><span class="line">127.0.0.1:6379&gt; LINSERT list after "mysql" "mysql1"</span><br><span class="line">(integer) -1</span><br></pre></td></tr></tbody></table></figure><h3 id="Set基本数据类型"><a href="#Set基本数据类型" class="headerlink" title="Set基本数据类型"></a>Set基本数据类型</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd key hello#向key值添加一个元素，如果存在，则返回0，如果不存在则返回1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd key world</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd key world</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS key#查看key的所有元素</span><br><span class="line">1) "world"</span><br><span class="line">2) "hello"</span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER key hellp#查看当前key是否存在某个值，如果存在则返回1，不存在则返回0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER key hello</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; scard key#查看当前key的所有值</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; SREM key hello#移除某个元素，如果原有元素存在则返回1，原有元素不存在则返回0</span><br><span class="line">(integer) 1</span><br><span class="line">27.0.0.1:6379&gt; SMEMBERS key</span><br><span class="line">1) "world"</span><br><span class="line">127.0.0.1:6379&gt; Sadd key 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; Sadd key 2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; Sadd key 3</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS key</span><br><span class="line">1) "3"</span><br><span class="line">2) "1"</span><br><span class="line">3) "world"</span><br><span class="line">4) "2"</span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER key#随机抽取一个key值</span><br><span class="line">"world"</span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER key</span><br><span class="line">"world"</span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER key</span><br><span class="line">"1"</span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER key</span><br><span class="line">"2"</span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER key</span><br><span class="line">"world"</span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER key</span><br><span class="line">"3"</span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER key 2#随机抽取指定个数key值</span><br><span class="line">1) "3"</span><br><span class="line">2) "2"</span><br><span class="line">127.0.0.1:6379&gt; SPOP key#随机删除一个元素，也可跟个数</span><br><span class="line">"2"</span><br><span class="line">127.0.0.1:6379&gt; SPOP key</span><br><span class="line">"1"</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS key</span><br><span class="line">1) "3"</span><br><span class="line">2) "world"</span><br><span class="line">127.0.0.1:6379&gt; FLUSHdb</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; sadd key 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd key 2 3 4 5</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; SMOVE key key1 2#把某个key的值移动另外一个key中</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) "key"</span><br><span class="line">2) "key1"</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS key</span><br><span class="line">1) "1"</span><br><span class="line">2) "3"</span><br><span class="line">3) "4"</span><br><span class="line">4) "5"</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS key1</span><br><span class="line">1) "2"</span><br><span class="line">127.0.0.1:6379&gt; sadd key1 1 3 4</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS key#查询key的value值</span><br><span class="line">1) "1"</span><br><span class="line">2) "3"</span><br><span class="line">3) "4"</span><br><span class="line">4) "5"</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS key1</span><br><span class="line">1) "1"</span><br><span class="line">2) "2"</span><br><span class="line">3) "3"</span><br><span class="line">4) "4"</span><br><span class="line">127.0.0.1:6379&gt; sdiff key key1#以key为基准，求两个key的差集</span><br><span class="line">1) "5"</span><br><span class="line">127.0.0.1:6379&gt; SINTER key key1#求两个集合的交集</span><br><span class="line">1) "1"</span><br><span class="line">2) "3"</span><br><span class="line">3) "4"</span><br><span class="line">127.0.0.1:6379&gt; SUNION key key1#求两个集合的并集</span><br><span class="line">1) "1"</span><br><span class="line">2) "2"</span><br><span class="line">3) "3"</span><br><span class="line">4) "4"</span><br><span class="line">5) "5"</span><br></pre></td></tr></tbody></table></figure><h3 id="Hash的基本命令（key-key-value"><a href="#Hash的基本命令（key-key-value" class="headerlink" title="Hash的基本命令（key-(key-value)"></a>Hash的基本命令（key-(key-value)</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset hash key 1#向某个key值中添加一个key/value键值对 其中外层key为hash,内层key为key，value为1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hset hash key 1 key1 2 key2 3#向key值hash中添加多个元素</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; HGET hash key#获取hash中的key的值</span><br><span class="line">"1"</span><br><span class="line">127.0.0.1:6379&gt; HMGET hash key key1 key2#获取多个值</span><br><span class="line">1) "1"</span><br><span class="line">2) "2"</span><br><span class="line">3) "3"</span><br><span class="line">127.0.0.1:6379&gt; HGETALL hash#获取hash的所有key、value信息</span><br><span class="line">1) "key"</span><br><span class="line">2) "1"</span><br><span class="line">3) "key1"</span><br><span class="line">4) "2"</span><br><span class="line">5) "key2"</span><br><span class="line">6) "3"</span><br><span class="line">127.0.0.1:6379&gt; HDEL hash key key1#删除hash的key和key1的值</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; HGETALL hash</span><br><span class="line">1) "key2"</span><br><span class="line">2) "3"</span><br><span class="line">127.0.0.1:6379&gt; HLEN hash#获取hash的键值对总数</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; HEXISTS hash key1#查看hash中是否存在某个key值，如果存在返回1，如果不存在返回0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; HGETALL hash</span><br><span class="line">1) "key2"</span><br><span class="line">2) "3"</span><br><span class="line">127.0.0.1:6379&gt; HEXISTS hash key2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; HKEYS hash#获取hash里面所有的key值</span><br><span class="line">1) "key2"</span><br><span class="line">127.0.0.1:6379&gt; HVALS hash#获取hash中所有value值</span><br><span class="line">1) "3"</span><br><span class="line">127.0.0.1:6379&gt; hset hash key3 5</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; HKEYS hash</span><br><span class="line">1) "key2"</span><br><span class="line">2) "key3"</span><br><span class="line">127.0.0.1:6379&gt; HVALS hash</span><br><span class="line">1) "3"</span><br><span class="line">2) "5"</span><br><span class="line">127.0.0.1:6379&gt; HINCRBY hash key3 5#给hash的key3值增加5</span><br><span class="line">(integer) 10</span><br><span class="line">127.0.0.1:6379&gt; HINCRBY hash key3 -1#给hash的key3值增加-1</span><br><span class="line">(integer) 9</span><br><span class="line">127.0.0.1:6379&gt; HSETNX hash key3 8#如果存在则给某个key添加至，不存在则返回0.</span><br><span class="line">(integer) 0</span><br></pre></td></tr></tbody></table></figure><h3 id="Hset的基础类型"><a href="#Hset的基础类型" class="headerlink" title="Hset的基础类型"></a>Hset的基础类型</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd salary 800 lk#向某个元素添加至，其中key为salary,800为位置，即排序的标准</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd salary 900 wl 1000 ml</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf +inf#查看所有的value值，</span><br><span class="line">1) "lk"</span><br><span class="line">2) "wl"</span><br><span class="line">3) "ml"</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf 900 withscores #查看小于900的value值，显示score</span><br><span class="line">1) "lk"</span><br><span class="line">2) "800"</span><br><span class="line">3) "wl"</span><br><span class="line">4) "900"</span><br><span class="line">127.0.0.1:6379&gt; ZRAnge salary 0 -1#查询所有key值，无排序，按插入顺序</span><br><span class="line">1) "lk"</span><br><span class="line">2) "wl"</span><br><span class="line">3) "ml"</span><br><span class="line">127.0.0.1:6379&gt; ZRem salary lw#移除某个元素，如果存在返回1，不存在返回0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; ZRem salary lk</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; ZRAnge salary 0 -1</span><br><span class="line">1) "wl"</span><br><span class="line">2) "ml"</span><br><span class="line">127.0.0.1:6379&gt; ZCARD salary#获取集合中的个数</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGE salary 0 -1 withscores#按socre从大到小排序</span><br><span class="line">1) "ml"</span><br><span class="line">2) "1000"</span><br><span class="line">3) "wl"</span><br><span class="line">4) "900"</span><br><span class="line">127.0.0.1:6379&gt; ZCOUNT salary 0 900#获取集合内的总数</span><br><span class="line">(integer) 1</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis简介</title>
      <link href="2021/04/29/redis-jian-jie/"/>
      <url>2021/04/29/redis-jian-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="NoSQL简介"><a href="#NoSQL简介" class="headerlink" title="NoSQL简介"></a>NoSQL简介</h3><ul><li>NoSQL的全称     not only SQL</li><li>方便扩展，数据之间没有关系</li><li>大数据高性能（读取11万次每秒，写8万次每秒）</li><li>数据类型多种多样且不需要事先设计数据库的表，有更好的扩展性    </li></ul><h3 id="传统的数据库和NoSQL的区别"><a href="#传统的数据库和NoSQL的区别" class="headerlink" title="传统的数据库和NoSQL的区别"></a>传统的数据库和NoSQL的区别</h3><h4 id="传统数据库："><a href="#传统数据库：" class="headerlink" title="传统数据库："></a>传统数据库：</h4><ul><li>结构化组织</li><li>数据都存储在表中</li><li>需要用sql进行查询</li><li>严格的一致性</li><li>数据定义语言</li></ul><h4 id="NoSQL："><a href="#NoSQL：" class="headerlink" title="NoSQL："></a>NoSQL：</h4><ul><li>不仅仅是数据库</li><li>没有固定的查询语言</li><li>键值对存储、列存储、文档存储、图形数据库等</li><li>最终一致性</li><li>CAP定理和BASE理论</li><li>高性能、高可用、高扩展</li></ul><h3 id="NoSQL的4种存储方式"><a href="#NoSQL的4种存储方式" class="headerlink" title="NoSQL的4种存储方式"></a>NoSQL的4种存储方式</h3><ul><li>k-v键值对    常见的有redis、Tair、Memcache</li><li>文档数据库：MongoDB</li><li>列存储数据库：HBase、分布式文件系统</li><li>图形数据库：Neo4j</li></ul><p><img src="https://i.loli.net/2021/04/29/RtrZoQSJaFqiGUs.png" alt="nosql分类.png"></p><h3 id="Redis的概述"><a href="#Redis的概述" class="headerlink" title="Redis的概述"></a>Redis的概述</h3><p>英文官网：    <a href="https://redis.io/">https://redis.io/</a></p><p>中文官网：    <a href="http://www.redis.cn/">http://www.redis.cn/</a></p><h4 id="redis是什么"><a href="#redis是什么" class="headerlink" title="redis是什么"></a>redis是什么</h4><p>Redis（Remote Dictionary Server )，即远程字典服务。</p><p>是一个开源的使用ANSI <a href="https://baike.baidu.com/item/C%E8%AF%AD%E8%A8%80">C语言</a>编写、支持网络、可基于内存亦可持久化的日志型、Key-Value<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93/103728">数据库</a>，并提供多种语言的API。</p><h4 id="redis能做什么"><a href="#redis能做什么" class="headerlink" title="redis能做什么"></a>redis能做什么</h4><ul><li>内存存储，持久化，常用的持久化是RDB、AOF</li><li>效率高用于缓存</li><li>发布订阅系统</li><li>地图信息分析</li><li>计时器、计数器</li><li>………………</li></ul><h4 id="redis的特性"><a href="#redis的特性" class="headerlink" title="redis的特性"></a>redis的特性</h4><ul><li>多样的数据类型</li><li>持久化</li><li>集群</li><li>事务</li></ul><h4 id="redis数据库"><a href="#redis数据库" class="headerlink" title="redis数据库"></a>redis数据库</h4><p>redis有16个数据库，默认数据库是0号数据库</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; select 3#切换数据库到3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; dbsize#显示当前数据库的key值数量</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379[3]&gt; set key 1#设置一个值</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; get key#获取值</span><br><span class="line">"1"</span><br><span class="line">127.0.0.1:6379[3]&gt; select 1    #切换到1号数据库</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[1]&gt; get key#得到的数据为nil，也即是在3号数据库设置的值在1号数据库查不到</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379[1]&gt; keys *#查询当前数据库的所有key值</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379[1]&gt; FLUSHALL#清空所有数据库的值</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[1]&gt; FLUSHdb #清空当前数据库的值</span><br><span class="line">OK</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="redis的原理"><a href="#redis的原理" class="headerlink" title="redis的原理"></a>redis的原理</h4><p>redis是单线程的，redis是基于内存操作的，CPU不是redis的性能瓶颈，redis的性能瓶颈是由内存和网络带宽决定的。</p><p>redis是用c语言编写的，每秒大概100000QPS，性能不比Memcache差。</p><p>由于redis的数据都存储在内存中，所以单线程操作更加快速。多线程操作会存在CPU之间的切换消耗资源。对于内存系统，没有CPU切换效率最高。</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker常用命令汇总</title>
      <link href="2021/04/28/docker-chang-yong-ming-ling-hui-zong/"/>
      <url>2021/04/28/docker-chang-yong-ming-ling-hui-zong/</url>
      
        <content type="html"><![CDATA[<h4 id="普通指令"><a href="#普通指令" class="headerlink" title="普通指令"></a>普通指令</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动docker</span></span><br><span class="line">systemctl start docker </span><br><span class="line"><span class="comment">#停止docker</span></span><br><span class="line">systemctl stop docker</span><br><span class="line"><span class="comment">#重启docker</span></span><br><span class="line">systemctl restart docker</span><br><span class="line"><span class="comment">#查看版本</span></span><br><span class="line">docker version</span><br><span class="line"><span class="comment">#查看docker信息</span></span><br><span class="line">docker info</span><br><span class="line"><span class="comment">#帮助</span></span><br><span class="line">docker --<span class="built_in">help</span></span><br></pre></td></tr></tbody></table></figure><h4 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看已安装的镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查询镜像</span></span><br><span class="line">docker search 镜像名   #例如：docker search tomcat</span><br><span class="line"><span class="meta">#</span><span class="bash"> 拉取镜像</span></span><br><span class="line">docker pull 镜像名#例如：docker pull tomcat:8.5 如果后面不跟版本后则默认下载最新版本</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除镜像</span></span><br><span class="line">docker rmi 镜像名#例如 docker rmi tomcat</span><br><span class="line">docker rmi -f  镜像id#镜像id是创建镜像的唯一表示</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除所有镜像</span></span><br><span class="line">docker rmi -f ${docker images -qa}  #即查询出所有镜像并删除</span><br><span class="line"><span class="meta">#</span><span class="bash"> 打包一个镜像</span></span><br><span class="line">docker commit -a 作者信息 -m="要提交的信息" 镜像id  要生产的镜像名称</span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行一个镜像,运行成功之后则生成一个容器</span></span><br><span class="line">docker run -it -p 外部端口号:内部端口号 镜像名称  </span><br></pre></td></tr></tbody></table></figure><h4 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 通过镜像生成容器的常用命令</span></span><br><span class="line">--name  #给容器起一个名字</span><br><span class="line">-d#表示后台运行</span><br><span class="line">-it#表示进入控制台运行与-d功能相同</span><br><span class="line">-P#随机分配一个端口号不常用</span><br><span class="line">-p#端口映射外部端口：内部端口</span><br><span class="line">-v#卷挂载宿主机路径：内部路径   用途是挂载文件是同步的，即可通过修改外部文件已到达修改内部文件的目的</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查询docker正在运行的容器</span></span><br><span class="line">docker ps   #后续的常用参数</span><br><span class="line">-a #查看所有容器</span><br><span class="line">-l#最近创建的容器</span><br><span class="line">-n#最近创建的n个容器</span><br><span class="line"><span class="meta">#</span><span class="bash"> 退出容器</span></span><br><span class="line">exit #退出并停止</span><br><span class="line">ctrl+p+Q#退出但不停止</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动、停止、重启、杀死容器</span></span><br><span class="line">docker start/stop/restart/kill 容器id或容器名</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除容器</span>   </span><br><span class="line">docker rm 容器id或容器名#只能删除已停止的容器</span><br><span class="line">docker rm -f  容器id或容器名#强制删除容器</span><br><span class="line">docker rm -f ${docker ps -qa}  #删除所有容器</span><br><span class="line"><span class="meta">#</span><span class="bash">重新进入容器</span></span><br><span class="line">docker attach 容器id或容器名#这种方式太慢</span><br><span class="line">docker exex -it 容器id或容器名 /bin/bash #进入正在执行的容器并进行交互</span><br><span class="line"><span class="meta">#</span><span class="bash"> 拷贝文件从内部到外部</span></span><br><span class="line">docker cp 容器id或容器名:文件路径 宿主机路径</span><br></pre></td></tr></tbody></table></figure><h4 id="日志命令"><a href="#日志命令" class="headerlink" title="日志命令"></a>日志命令</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f -t --tail 10   容器id或容器名</span><br><span class="line">-t    #表示显示时间</span><br><span class="line">-f#最新的日志打印</span><br><span class="line">--tail #行数</span><br><span class="line">-n#全部打印</span><br><span class="line"></span><br><span class="line">docker top 容器id或容器名    #查看容器内的进程</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker进阶</title>
      <link href="2021/04/21/docker-jin-jie/"/>
      <url>2021/04/21/docker-jin-jie/</url>
      
        <content type="html"><![CDATA[<h4 id="容器卷技术"><a href="#容器卷技术" class="headerlink" title="容器卷技术"></a>容器卷技术</h4><p>容器卷技术的目的是为了持久化和同步操作！容器件也可以进行同步。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">容器与本地数据挂载</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 一、命令挂载</span></span><br><span class="line">docker run -it -v  linux文件目录:容器目录 容器id /bin/bash#把linux目录和容器目录进行同步</span><br><span class="line"><span class="meta">#</span><span class="bash"> 二、dockerFile 挂载</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1、建立dockerFile文件  其中书写指令是必须都大写</span></span><br><span class="line">FROM centos#要挂载的镜像</span><br><span class="line">VOLUME ["volume01","volume2"]#要挂载的卷</span><br><span class="line">CMD echo "----end----"</span><br><span class="line">CMD /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、运行文件</span></span><br><span class="line">docker build -f 创建的dockerFile目录 -t 生成的名字</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">容器之间挂载 把两容器关联起来</span></span><br><span class="line">docker run -it --name 新建容器 --volume-from 要挂载的容器  moer/centos:1.0</span><br></pre></td></tr></tbody></table></figure><h4 id="Dockerfile构建过程"><a href="#Dockerfile构建过程" class="headerlink" title="Dockerfile构建过程"></a>Dockerfile构建过程</h4><h6 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h6><p>1、每个指令必须的大写</p><p>2、指令的执行顺序从上到下</p><p>3、#表示注释</p><p>4、每个指令都会提交一个镜像，层层提交。</p><h4 id="DokcerFile的基础命令"><a href="#DokcerFile的基础命令" class="headerlink" title="DokcerFile的基础命令"></a>DokcerFile的基础命令</h4><p><img src="https://i.loli.net/2021/04/22/9BiAIRS7wEUqkPD.jpg" alt="docker命令.jpg"></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FROM #基础镜像</span><br><span class="line">MAINRAINER#姓名+邮箱</span><br><span class="line">RUN#运行命令</span><br><span class="line">ADD#添加分层镜像</span><br><span class="line">WORKDIR#工作目录</span><br><span class="line">VOLUME#挂载卷</span><br><span class="line">EXPOSE#暴露端口号</span><br><span class="line">CMD#指定容器运行的适合要启动的命令，只有最后一个命令生效，不可追加</span><br><span class="line">ENTRYPOINT#指定容器运行的适合要启动的命令，可以追加命令</span><br><span class="line">ENV#构建的时候设置环境变量</span><br><span class="line">COPY#把一个镜像拷贝进去类似ADD</span><br></pre></td></tr></tbody></table></figure><h6 id="docker-网络"><a href="#docker-网络" class="headerlink" title="docker 网络"></a>docker 网络</h6><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker network ls   #查看所有的docker网络</span><br><span class="line">b6fbe2727cc1        bridge              bridge              local</span><br><span class="line">e8ea254fb069        host                host                local</span><br><span class="line">4956a8e7920a        none                null                local</span><br><span class="line"><span class="meta">#</span><span class="bash">其中bridge 是桥接模式（默认）host是主机模式  none不配置网络</span></span><br></pre></td></tr></tbody></table></figure><h6 id="springboot项目打包成Docker镜像"><a href="#springboot项目打包成Docker镜像" class="headerlink" title="springboot项目打包成Docker镜像"></a>springboot项目打包成Docker镜像</h6><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、编写成功Springboot项目</span><br><span class="line"></span><br><span class="line">2、达成jar包</span><br><span class="line"></span><br><span class="line">3、编写dockerFile进行发布</span><br><span class="line"></span><br><span class="line">4、构建镜像</span><br><span class="line"></span><br><span class="line">5、发布运行</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>序列化</title>
      <link href="2021/04/20/xu-lie-hua/"/>
      <url>2021/04/20/xu-lie-hua/</url>
      
        <content type="html"><![CDATA[<h4 id="java序列化和反序列化是什么？"><a href="#java序列化和反序列化是什么？" class="headerlink" title="java序列化和反序列化是什么？"></a>java序列化和反序列化是什么？</h4><p>序列化：把对象转换为字节序列的过程称为对象的序列化。</p><p>反序列化：把字节序列恢复为对象的过程称为对象的反序列化。</p><h4 id="为什么要用java序列化，它的作用是什么？"><a href="#为什么要用java序列化，它的作用是什么？" class="headerlink" title="为什么要用java序列化，它的作用是什么？"></a>为什么要用java序列化，它的作用是什么？</h4><p>1、 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中。</p><p>2、在网络上传送对象的字节序列。</p><h4 id="实现java序列化的方式？"><a href="#实现java序列化的方式？" class="headerlink" title="实现java序列化的方式？"></a>实现java序列化的方式？</h4><p>javaBean实现Serializable接口。</p><h4 id="为什么实现序列化的时要设置-serialVersionUID"><a href="#为什么实现序列化的时要设置-serialVersionUID" class="headerlink" title="为什么实现序列化的时要设置 serialVersionUID"></a>为什么实现序列化的时要设置 serialVersionUID</h4><p>如果一个M实体在序列化的时候存在A、B、C三个字段，则反序列化的时候也会返回这三个字段。由于需求的变化导致M实体增加了字段D，由于序列化的内容只有三个字段，在进行反序列化的时则会提示异常。故需设置标识来保证反序列化时serialVersionUID是否改变。</p><h4 id="javaBean中的字段不被序列化可以吗？"><a href="#javaBean中的字段不被序列化可以吗？" class="headerlink" title="javaBean中的字段不被序列化可以吗？"></a>javaBean中的字段不被序列化可以吗？</h4><p>使用Transient修饰关键字可以保证字段不被序列化，被反序列化时如果类型为int则默认值为0，对象型的默认值为null。</p><h4 id="static修饰的字段为什么不被序列化"><a href="#static修饰的字段为什么不被序列化" class="headerlink" title="static修饰的字段为什么不被序列化"></a>static修饰的字段为什么不被序列化</h4><p>由于static修饰的字段存在于静态方法区，而不是堆内存中，故不被序列化</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><h6 id="使用序列化的目的是把javaBean信息存入到磁盘中，方便进行网络中传输，特别是现在微服务盛行的时代。"><a href="#使用序列化的目的是把javaBean信息存入到磁盘中，方便进行网络中传输，特别是现在微服务盛行的时代。" class="headerlink" title="使用序列化的目的是把javaBean信息存入到磁盘中，方便进行网络中传输，特别是现在微服务盛行的时代。"></a>使用序列化的目的是把javaBean信息存入到磁盘中，方便进行网络中传输，特别是现在微服务盛行的时代。</h6><h6 id="目前最常见的实现序列化的方式时实现Serializable接口，并且要设置serialVersionUID的版本号以便对象更改时反序列化出错。"><a href="#目前最常见的实现序列化的方式时实现Serializable接口，并且要设置serialVersionUID的版本号以便对象更改时反序列化出错。" class="headerlink" title="目前最常见的实现序列化的方式时实现Serializable接口，并且要设置serialVersionUID的版本号以便对象更改时反序列化出错。"></a>目前最常见的实现序列化的方式时实现Serializable接口，并且要设置serialVersionUID的版本号以便对象更改时反序列化出错。</h6><h6 id="对于敏感信息不想被序列化可以用Transient关键字进行隐藏，或者用static关键字设置为静态字段。"><a href="#对于敏感信息不想被序列化可以用Transient关键字进行隐藏，或者用static关键字设置为静态字段。" class="headerlink" title="对于敏感信息不想被序列化可以用Transient关键字进行隐藏，或者用static关键字设置为静态字段。"></a>对于敏感信息不想被序列化可以用Transient关键字进行隐藏，或者用static关键字设置为静态字段。</h6>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合</title>
      <link href="2021/04/20/ji-he/"/>
      <url>2021/04/20/ji-he/</url>
      
        <content type="html"><![CDATA[<h4 id="数组和集合的区别？"><a href="#数组和集合的区别？" class="headerlink" title="数组和集合的区别？"></a>数组和集合的区别？</h4><blockquote><p>数组是同一类型的数据汇总，长度是固定的，可以通过下标的形式获取值，存入值。</p></blockquote><blockquote><p>集合是具有某种特质的抽象对象汇成的集体。</p></blockquote><blockquote><p>相对来说数组适用于简单固定的数据操作，而集合不仅适用于简单的数据操作，也可操作复杂的数据信息。</p></blockquote><blockquote><p>对简单数据操作来说数组更方便快捷。</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组的三种创建方式</span></span><br><span class="line"><span class="keyword">int</span>[] createOne = <span class="keyword">new</span> <span class="keyword">int</span>[]{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>};</span><br><span class="line"><span class="keyword">int</span>[] createTwo = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>};</span><br><span class="line"><span class="keyword">int</span>[] createThree = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="comment">//数组存储值方式，获取值方式</span></span><br><span class="line">createThree[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">System.out.println(createThree[<span class="number">0</span>]);</span><br><span class="line">createThree[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">System.out.println(createThree[<span class="number">0</span>]);</span><br></pre></td></tr></tbody></table></figure><h4 id="谈谈你对集合的理解"><a href="#谈谈你对集合的理解" class="headerlink" title="谈谈你对集合的理解"></a>谈谈你对集合的理解</h4><blockquote><p>集合分为Collection和Map两个大的方向，Collection有包含了Set不重复集合、List可重复集合两种。</p></blockquote><h4 id="Set集合描述"><a href="#Set集合描述" class="headerlink" title="Set集合描述"></a>Set集合描述</h4><blockquote><p>Set是存储无序元素集合，且集合内的元素不会重复。</p></blockquote><blockquote><p>Set接口的实现方式有很多，例如HashSet、TreeSet、LinkedHashSet等</p></blockquote><p>HashSet的特点是无重复、无序，存储位置是通过特定的hash算法进行获得，存储方式时数组结构，如果两个元素hashCode()相等但equals()不相等时，存储的方式时在数组的基础上增加链表。如果两则均相等则表示重复，具体存储方式可了解hashMap的存储方式。</p><p>TreeSet的特点是自然排序，无重复，存储机构是红黑树的形式，判断两个元素是否重复（重写了Comparable的CompareTo方法来判断返回值是否为0，如果0则表示重复）</p><p>LinkedHashSet的特点是按插入顺序排序，无重复，判断是否重复的方式跟HashSet一致。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常见的集合操作</span></span><br><span class="line">Set&lt;String&gt; setOne = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;();</span><br><span class="line">Set&lt;String&gt; setTwo = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">Set&lt;String&gt; setThree = <span class="keyword">new</span> TreeSet&lt;String&gt;();</span><br><span class="line"><span class="comment">//添加元素</span></span><br><span class="line">setOne.add(<span class="string">"ea"</span>);</span><br><span class="line">setOne.add(<span class="string">"a"</span>);</span><br><span class="line">setOne.add(<span class="string">"dc"</span>);</span><br><span class="line">setOne.add(<span class="string">"nb"</span>);</span><br><span class="line">setOne.add(<span class="string">"md"</span>);</span><br><span class="line">setTwo.add(<span class="string">"ea"</span>);</span><br><span class="line">setTwo.add(<span class="string">"a"</span>);</span><br><span class="line">setTwo.add(<span class="string">"dc"</span>);</span><br><span class="line">setTwo.add(<span class="string">"nb"</span>);</span><br><span class="line">setTwo.add(<span class="string">"md"</span>);</span><br><span class="line">setThree.add(<span class="string">"ea"</span>);</span><br><span class="line">setThree.add(<span class="string">"a"</span>);</span><br><span class="line">setThree.add(<span class="string">"dc"</span>);</span><br><span class="line">setThree.add(<span class="string">"nb"</span>);</span><br><span class="line">setThree.add(<span class="string">"md"</span>);</span><br><span class="line"><span class="comment">//遍历元素</span></span><br><span class="line">setOne.forEach(set-&gt;System.out.print(set+<span class="string">"   "</span>));</span><br><span class="line">System.out.println(<span class="string">"LinkedHashSet的遍历结果"</span>);</span><br><span class="line">setTwo.forEach(set-&gt;System.out.print(set+<span class="string">"   "</span>));</span><br><span class="line">System.out.println(<span class="string">"HashSet的遍历结果"</span>);</span><br><span class="line">setThree.forEach(set-&gt;System.out.print(set+<span class="string">"   "</span>));</span><br><span class="line">System.out.println(<span class="string">"TreeSet的遍历结果"</span>);</span><br><span class="line"><span class="comment">//删除元素</span></span><br><span class="line">setOne.remove(<span class="string">"d"</span>);</span><br><span class="line"><span class="comment">//查看集合是否有值</span></span><br><span class="line">setOne.isEmpty();</span><br><span class="line"><span class="comment">//查看集合的个数</span></span><br><span class="line"> setOne.size();</span><br><span class="line"><span class="comment">//查看是否包含元素</span></span><br><span class="line">setOne.contains(<span class="string">"d"</span>);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">这是上述三种集合遍历的结果，可看出三种集合的排序方式</span></span><br><span class="line">ea   a   dc   nb   md   LinkedHashSet的遍历结果</span><br><span class="line">a   nb   md   ea   dc   HashSet的遍历结果</span><br><span class="line">a   dc   ea   md   nb   TreeSet的遍历结果</span><br></pre></td></tr></tbody></table></figure><h4 id="List集合描述"><a href="#List集合描述" class="headerlink" title="List集合描述"></a>List集合描述</h4><blockquote><p>List集合是存储有序的集合，且集合内的元素是可重复的。</p></blockquote><blockquote><p>List接口的实现方式有ArrayList,Vector,LinkedList三种方式</p></blockquote><p>ArrayList底层实现方式是数组的结构，方便查找。</p><p>Vector底层实现方式也是数组结构，与ArrayList不同之处在于它是线程安全的，所以性能消耗更大，不建议使用</p><p>LinkedList底层实现方式时双向链表结构，方便插入、删除。</p><p>由于ArrayList插入方式大部分都是尾插法，与LinkedList相比两则在数据插入时ArrayList的效率更高。</p><p>再删除时，ArrayList删除的数据更靠后或数据量很小时移动的次数也会很少，两则的效率差不太多，故使用场景中ArrayList运用比较广泛。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常见的集合操作</span></span><br><span class="line">List&lt;String&gt; listOne = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">List&lt;String&gt; listTwo = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">listOne.add(<span class="string">"aaa"</span>);</span><br><span class="line">listOne.add(<span class="string">"bbb"</span>);</span><br><span class="line">listOne.add(<span class="string">"ccc"</span>);</span><br><span class="line">listTwo.add(<span class="string">"aaa"</span>);</span><br><span class="line">listTwo.add(<span class="string">"bbb"</span>);</span><br><span class="line">listTwo.add(<span class="string">"ccc"</span>);</span><br><span class="line"><span class="comment">//遍历操作</span></span><br><span class="line">listOne.forEach(System.out::print);</span><br><span class="line"><span class="comment">//集合大小</span></span><br><span class="line">System.out.println(listOne.size());</span><br><span class="line"><span class="comment">//是否为空</span></span><br><span class="line">System.out.println(listOne.isEmpty());</span><br><span class="line"><span class="comment">//是否包含某个数据</span></span><br><span class="line">System.out.println(listOne.contains(<span class="string">"aaa"</span>));</span><br><span class="line"><span class="comment">//通过下标获取元素</span></span><br><span class="line">System.out.println(listOne.get(<span class="number">0</span>));</span><br><span class="line"><span class="comment">//移除某个元素</span></span><br><span class="line">System.out.println(listOne.remove(<span class="string">"aaa"</span>));</span><br><span class="line"><span class="comment">//替换某个元素</span></span><br><span class="line">System.out.println(listOne.set(<span class="number">1</span>,<span class="string">"aaaaaaa"</span>));</span><br><span class="line"><span class="comment">//截取集合</span></span><br><span class="line">System.out.println(listOne.subList(<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line"><span class="comment">//获取某个元素的下标</span></span><br><span class="line">System.out.println(listOne.indexOf(<span class="string">"bbb"</span>));</span><br></pre></td></tr></tbody></table></figure><h4 id="Map集合描述"><a href="#Map集合描述" class="headerlink" title="Map集合描述"></a>Map集合描述</h4><blockquote><p>Map是一个key/value的键值对集合，key不可重复，value可重复的。</p></blockquote><blockquote><p>Map接口的实现方式有HashMap、HashTable、TreeMap、LinkedHashMap</p></blockquote><p>HashMap是我们最常用且最快速的，key底层数据结构是数组+链表+红黑树形式的，key/value都可为null。</p><p>HashTable和HashMap是线程安全的，效率较慢，故不经常用，且key/value都不允许为null。</p><p>TreeMap的存储是根据比较器进行排序，跟TreeSet的数据结构层上一致，key不可以为null。</p><p>LinkedHashMap是按存储的先后位置进行确定的，key/value都可为null。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt;  mapOne = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line"><span class="comment">//添加数据</span></span><br><span class="line">mapOne.put(<span class="string">"aaa"</span>,<span class="string">"aaaaaaaaaaa"</span>);</span><br><span class="line"><span class="comment">//遍历数据</span></span><br><span class="line">mapOne.forEach((str,str1)-&gt;{</span><br><span class="line">    System.out.println(str1);</span><br><span class="line">});</span><br><span class="line"><span class="comment">//根据key值获取value</span></span><br><span class="line">System.out.println(mapOne.get(<span class="string">"aaa"</span>));</span><br><span class="line"><span class="comment">//判断集合是否为null</span></span><br><span class="line">System.out.println( mapOne.isEmpty());</span><br><span class="line"><span class="comment">//查看集合的大小</span></span><br><span class="line">System.out.println( mapOne.size());</span><br><span class="line"><span class="comment">//查看集合是否包含某个key值</span></span><br><span class="line">System.out.println( mapOne.containsKey(<span class="string">"aaa"</span>));</span><br><span class="line"><span class="comment">//查看集合是否包含某个value值</span></span><br><span class="line">System.out.println( mapOne.containsValue(<span class="string">"aaaaaaa"</span>));</span><br><span class="line"><span class="comment">//移除某个key值</span></span><br><span class="line">System.out.println( mapOne.remove(<span class="string">"aaaaaaa"</span>));</span><br><span class="line"><span class="comment">//替换某个key的value值</span></span><br><span class="line">System.out.println( mapOne.replace(<span class="string">"aaa"</span>,<span class="string">"bbbbbbb"</span>));</span><br><span class="line"><span class="comment">//清除value的值</span></span><br><span class="line">mapOne.clear();</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用排序算法</title>
      <link href="2021/04/20/chang-yong-pai-xu-suan-fa/"/>
      <url>2021/04/20/chang-yong-pai-xu-suan-fa/</url>
      
        <content type="html"><![CDATA[<h6 id="1、选择排序"><a href="#1、选择排序" class="headerlink" title="1、选择排序"></a>1、选择排序</h6><p><img src="https://i.loli.net/2021/04/20/eu9IyhmdiEcTHBx.gif" alt="选择排序.gif"></p><p>选择排序就是每趟排序从中找出最小的一个放在最前面，直至最后排序完成。</p><p>通俗的讲：假设有N条数据，首先第一趟排序从1-N中找出最小的一个，然后把1的数据的和最小的数据进行交换，第二趟则从2-N中找出最小的一个，再让2与最小的数据进行交换。以此类推，直到N-1趟结束。由此可推断比较次数为N+（N-1）+…..+2+1;</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span>[]  chooseArray  = {<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">16</span>,<span class="number">2</span>,<span class="number">18</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">29</span>,<span class="number">11</span>};</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ele:chooseArray) {</span><br><span class="line">            System.out.print(ele+<span class="string">","</span>);</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"排序前的遍历数据"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;chooseArray.length-<span class="number">1</span>;i++){</span><br><span class="line">            <span class="keyword">int</span> start = chooseArray[i];  <span class="comment">//每次循环的开始数据</span></span><br><span class="line">            <span class="keyword">int</span> index = i;   <span class="comment">//获取每次循环的最小下标</span></span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;    <span class="comment">//交换是临时存放值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> ele:chooseArray) {</span><br><span class="line">                System.out.print(ele+<span class="string">","</span>);</span><br><span class="line">            }</span><br><span class="line">            System.out.println(<span class="string">"每一次调用过程数据遍历"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;chooseArray.length;j++){</span><br><span class="line">                <span class="keyword">if</span> (start&gt;chooseArray[j]){ <span class="comment">//如果开始值大于当前值</span></span><br><span class="line">                    start=chooseArray[j];  <span class="comment">//把当前值赋予开始值，并与后续的值进行循环大小比较</span></span><br><span class="line">                    index=j;   <span class="comment">//并记录当前下标</span></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(index!=i){   <span class="comment">//如果本次循环下标不等于index则表示当前循环的最小值非开始值</span></span><br><span class="line">                temp = chooseArray[i]; <span class="comment">//把开始值赋给临时值</span></span><br><span class="line">                chooseArray[i]=start; <span class="comment">//把最小值赋给开始位置</span></span><br><span class="line">                chooseArray[index] =temp; <span class="comment">//把临时值赋给最小值的下标位置</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ele:chooseArray) {</span><br><span class="line">            System.out.print(ele+<span class="string">","</span>);</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"排序后的遍历数据"</span>);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">每一趟排序后遍历的结果</span></span><br><span class="line">10,11,12,16,2,18,9,5,4,29,11,每一次调用过程数据遍历</span><br><span class="line">2,11,12,16,10,18,9,5,4,29,11,每一次调用过程数据遍历</span><br><span class="line">2,4,12,16,10,18,9,5,11,29,11,每一次调用过程数据遍历</span><br><span class="line">2,4,5,16,10,18,9,12,11,29,11,每一次调用过程数据遍历</span><br><span class="line">2,4,5,9,10,18,16,12,11,29,11,每一次调用过程数据遍历</span><br><span class="line">2,4,5,9,10,18,16,12,11,29,11,每一次调用过程数据遍历</span><br><span class="line">2,4,5,9,10,11,16,12,18,29,11,每一次调用过程数据遍历</span><br><span class="line">2,4,5,9,10,11,11,12,18,29,16,每一次调用过程数据遍历</span><br><span class="line">2,4,5,9,10,11,11,12,18,29,16,每一次调用过程数据遍历</span><br><span class="line">2,4,5,9,10,11,11,12,16,29,18,每一次调用过程数据遍历</span><br><span class="line">2,4,5,9,10,11,11,12,16,18,29,排序后的遍历数据</span><br></pre></td></tr></tbody></table></figure><h6 id="2、冒泡排序"><a href="#2、冒泡排序" class="headerlink" title="2、冒泡排序"></a>2、冒泡排序</h6><p><img src="https://i.loli.net/2021/04/20/YTl5X36ZAFVebE9.png" alt="冒泡排序.png"></p><p>冒泡排序是相邻的两个数据进行比较，如果前者大于后者，两则进行交换。每趟比较之后最后一个则为最大数值。</p><p>通俗的讲：假设有N条数据，第一趟则先让第一条与第二条比较，如果第一条大于第二条则两条数据进行交换，否则不进行交互，即值大的放后面，然后第二条在于第三条进行比较得出比较大的值放第三条的位置，以此类推得出最大的一条放在最后面。第二趟还是第一条与第二条相比，得出最大与第三条相比，知道N-1次（最后一条已经为最大了）。由此可推断比较次数为N+（N-1）+…..+2+1。</p><p>冒泡排序可中途进行打断，即当发现排序过程中已经排序成功则可进行break打断当前循环，以减少资源浪费。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">  <span class="keyword">int</span>[]  bubbleArray  = {<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">16</span>,<span class="number">2</span>,<span class="number">18</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">29</span>,<span class="number">11</span>};</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;bubbleArray.length-<span class="number">1</span>;i++){</span><br><span class="line">        <span class="keyword">boolean</span> changeFlag = <span class="keyword">false</span>;  <span class="comment">//控制后续如果值无改变可调出循环代表已排序完成</span></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ele:bubbleArray) {</span><br><span class="line">            System.out.print(ele+<span class="string">","</span>);</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"第"</span>+i+<span class="string">"趟排序前数据"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;bubbleArray.length-<span class="number">1</span>-i;j++){</span><br><span class="line">            <span class="keyword">if</span> (bubbleArray[j]&gt;bubbleArray[j+<span class="number">1</span>]){ <span class="comment">//如果第j条数据大于后一条数据</span></span><br><span class="line">                temp=bubbleArray[j];    <span class="comment">//则把第j条数据赋给临时数据</span></span><br><span class="line">                bubbleArray[j]=bubbleArray[j+<span class="number">1</span>];  <span class="comment">//把后条数据赋给第j条数据</span></span><br><span class="line">                bubbleArray[j+<span class="number">1</span>] =temp; <span class="comment">//再把临时数据赋给第j+1条</span></span><br><span class="line">                changeFlag=<span class="keyword">true</span>; <span class="comment">//说明有排序的动作</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(!changeFlag){ <span class="comment">//如果无排序的动作则进行打断当前循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">当前做了8次循环，如果不打断则会循环数组的11-1=10次</span></span><br><span class="line">10,11,12,16,2,18,9,5,4,29,11,第0趟排序前数据</span><br><span class="line">10,11,12,2,16,9,5,4,18,11,29,第1趟排序前数据</span><br><span class="line">10,11,2,12,9,5,4,16,11,18,29,第2趟排序前数据</span><br><span class="line">10,2,11,9,5,4,12,11,16,18,29,第3趟排序前数据</span><br><span class="line">2,10,9,5,4,11,11,12,16,18,29,第4趟排序前数据</span><br><span class="line">2,9,5,4,10,11,11,12,16,18,29,第5趟排序前数据</span><br><span class="line">2,5,4,9,10,11,11,12,16,18,29,第6趟排序前数据</span><br><span class="line">2,4,5,9,10,11,11,12,16,18,29,第7趟排序前数据</span><br></pre></td></tr></tbody></table></figure><h6 id="3、插入排序"><a href="#3、插入排序" class="headerlink" title="3、插入排序"></a>3、插入排序</h6><p><img src="https://i.loli.net/2021/04/20/IlVLMqed8s1Y9rU.png" alt="插入排序.png"></p><p>插入排序是每次拿出一个值与已排序好的进行比较，直至排序完成。</p><p>通俗的讲：假设有N条数据，第一趟让第二条数据与第一条比较如果大于则不交换，小于则进行交换，第二趟则让第三条数据与第二条相比较，如果大于则表明，第三条比第一条也大，无需比较，如果小于则让第三条与第一条进行比较，如果小于则第一条、第二条后移一位，第三条存放第一位数据，如果大于则第一条不变，第二条与第三条交换位置。这样可以保证每次循环过后前面的数据都是排序完成的。由此可推断比较的次数为1+2+……+N-1。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span>[]  insertArray  = {<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">16</span>,<span class="number">2</span>,<span class="number">18</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">29</span>,<span class="number">11</span>};</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;insertArray.length;i++){</span><br><span class="line">        <span class="keyword">int</span> temp = insertArray[i];   <span class="comment">//把要比较的值存入临时</span></span><br><span class="line">        <span class="keyword">int</span> j ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ele:insertArray) {</span><br><span class="line">            System.out.print(ele+<span class="string">","</span>);</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"每趟比较前的遍历数据"</span>);</span><br><span class="line">        <span class="keyword">for</span> (j=i;j&gt;<span class="number">0</span>&amp;&amp;insertArray[j-<span class="number">1</span>]&gt;temp;j--){ <span class="comment">//如果临时值小于要循环的数值，</span></span><br><span class="line">            insertArray[j] =insertArray[j-<span class="number">1</span>]; <span class="comment">//需要把当前值往后移位以保证空出一个位置存放临时值</span></span><br><span class="line">        }</span><br><span class="line">        insertArray[j] =temp; <span class="comment">//把临时值存放到循环比较的j的位置</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ele:insertArray) {</span><br><span class="line">        System.out.print(ele+<span class="string">","</span>);</span><br><span class="line">    }</span><br><span class="line">    System.out.println(<span class="string">"排序完成遍历数据"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">10,11,12,16,2,18,9,5,4,29,11,每趟比较前的遍历数据</span><br><span class="line">10,11,12,16,2,18,9,5,4,29,11,每趟比较前的遍历数据</span><br><span class="line">10,11,12,16,2,18,9,5,4,29,11,每趟比较前的遍历数据</span><br><span class="line">10,11,12,16,2,18,9,5,4,29,11,每趟比较前的遍历数据</span><br><span class="line">2,10,11,12,16,18,9,5,4,29,11,每趟比较前的遍历数据</span><br><span class="line">2,10,11,12,16,18,9,5,4,29,11,每趟比较前的遍历数据</span><br><span class="line">2,9,10,11,12,16,18,5,4,29,11,每趟比较前的遍历数据</span><br><span class="line">2,5,9,10,11,12,16,18,4,29,11,每趟比较前的遍历数据</span><br><span class="line">2,4,5,9,10,11,12,16,18,29,11,每趟比较前的遍历数据</span><br><span class="line">2,4,5,9,10,11,12,16,18,29,11,每趟比较前的遍历数据</span><br><span class="line">2,4,5,9,10,11,11,12,16,18,29,排序完成遍历数据</span><br></pre></td></tr></tbody></table></figure><h6 id="4、快速排序"><a href="#4、快速排序" class="headerlink" title="4、快速排序"></a>4、快速排序</h6><p><img src="https://i.loli.net/2021/04/20/ylPKqaMvrUeJ3Gc.gif" alt="快速排序.gif"></p><p>暂不书写，过程有点复杂，理解排序流程即可。</p><p>选取一个参数为基准，依次进行比较，如果比这个基准大放在不动，如果比这个基准小则移动到前面。</p><h6 id="5、归并排序"><a href="#5、归并排序" class="headerlink" title="5、归并排序"></a>5、归并排序</h6><p><img src="https://i.loli.net/2021/04/20/9dbEuieFLRTmfg8.png" alt="归并排序.png"></p><p>归并排序采用的是归并的思想，即把长的的数组等分分割成小的数组进行排序，最后在一步一步的合成排序。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>{</span><br><span class="line">      <span class="keyword">int</span> []arr = {<span class="number">9</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>};</span><br><span class="line">      sort(arr);</span><br><span class="line">      System.out.println(Arrays.toString(arr));</span><br><span class="line">   }</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>{</span><br><span class="line">      <span class="keyword">int</span> []temp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];<span class="comment">//在排序前，先建好一个长度等于原数组长度的临时数组</span></span><br><span class="line">   }</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> []temp)</span></span>{</span><br><span class="line">      <span class="keyword">if</span>(left&lt;right){</span><br><span class="line">         <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">         sort(arr,left,mid,temp);<span class="comment">//左边归并排序，使得左子序列有序</span></span><br><span class="line">         sort(arr,mid+<span class="number">1</span>,right,temp);<span class="comment">//右边归并排序，使得右子序列有序</span></span><br><span class="line">         merge(arr,left,mid,right,temp);<span class="comment">//将两个有序子数组合并操作</span></span><br><span class="line">         System.out.println(Arrays.toString(arr));</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right,<span class="keyword">int</span>[] temp)</span></span>{</span><br><span class="line">      <span class="keyword">int</span> i = left;<span class="comment">//左序列指针</span></span><br><span class="line">      <span class="keyword">int</span> j = mid+<span class="number">1</span>;<span class="comment">//右序列指针</span></span><br><span class="line">      <span class="keyword">int</span> t = <span class="number">0</span>;<span class="comment">//临时数组指针</span></span><br><span class="line">      <span class="keyword">while</span> (i&lt;=mid &amp;&amp; j&lt;=right){</span><br><span class="line">         <span class="keyword">if</span>(arr[i]&lt;=arr[j]){</span><br><span class="line">            temp[t++] = arr[i++];</span><br><span class="line">         }<span class="keyword">else</span> {</span><br><span class="line">            temp[t++] = arr[j++];</span><br><span class="line">         }</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">while</span>(i&lt;=mid){<span class="comment">//将左边剩余元素填充进temp中</span></span><br><span class="line">         temp[t++] = arr[i++];</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">while</span>(j&lt;=right){<span class="comment">//将右序列剩余元素填充进temp中</span></span><br><span class="line">         temp[t++] = arr[j++];</span><br><span class="line">      }</span><br><span class="line">      t = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//将temp中的元素全部拷贝到原数组中</span></span><br><span class="line">      <span class="keyword">while</span>(left &lt;= right){</span><br><span class="line">         arr[left++] = temp[t++];</span><br><span class="line">      }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><h6 id="6、希尔排序"><a href="#6、希尔排序" class="headerlink" title="6、希尔排序"></a>6、希尔排序</h6><p><img src="https://i.loli.net/2021/04/20/LDpPkswzXVyTYjf.png" alt="希尔排序.png"></p><p>希尔排序(Shell’s Sort)是插入排序的一种又称“缩小增量排序”（Diminishing Increment Sort），是直接插入排序算法的一种更高效的改进版本。即把数组按组进行比较，分组步数为数组的长度除以2的n次方，直至余数为1的时候，进行全局排序，可查看下图。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>{</span><br><span class="line">         <span class="keyword">int</span> []arr = {<span class="number">9</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>};</span><br><span class="line">         shellSort(arr);</span><br><span class="line">         System.out.println(Arrays.toString(arr));</span><br><span class="line">  } </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arrays)</span> </span>{</span><br><span class="line">    <span class="comment">//增量每次都/2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> step = arrays.length / <span class="number">2</span>; step &gt; <span class="number">0</span>; step /= <span class="number">2</span>) {</span><br><span class="line">        <span class="comment">//从增量那组开始进行插入排序，直至完毕</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = step; i &lt; arrays.length; i++) {</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">int</span> temp = arrays[j];</span><br><span class="line">            <span class="comment">// j - step 就是代表与它同组隔壁的元素</span></span><br><span class="line">            <span class="keyword">while</span> (j - step &gt;= <span class="number">0</span> &amp;&amp; arrays[j - step] &gt; temp) {</span><br><span class="line">                arrays[j] = arrays[j - step];</span><br><span class="line">                j = j - step;</span><br><span class="line">            }</span><br><span class="line">            arrays[j] = temp;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>swagger总结</title>
      <link href="2021/04/20/swagger-zong-jie/"/>
      <url>2021/04/20/swagger-zong-jie/</url>
      
        <content type="html"><![CDATA[<h4 id="Swagger简介"><a href="#Swagger简介" class="headerlink" title="Swagger简介"></a>Swagger简介</h4><h6 id="swagger即是一个接口文档生成工具，也是一个接口调用工具，主要目的是解决前后端的即时交互问题。"><a href="#swagger即是一个接口文档生成工具，也是一个接口调用工具，主要目的是解决前后端的即时交互问题。" class="headerlink" title="swagger即是一个接口文档生成工具，也是一个接口调用工具，主要目的是解决前后端的即时交互问题。"></a>swagger即是一个接口文档生成工具，也是一个接口调用工具，主要目的是解决前后端的即时交互问题。</h6><h6 id="swagger的配置："><a href="#swagger的配置：" class="headerlink" title="swagger的配置："></a>swagger的配置：</h6><ul><li>ApiInfo   文档的简介</li><li>enable    是否启动swagger   以便保证生产环境不启动</li><li>select ().apis ()  可扫描的路径</li><li>select().paths()  可匹配的路径     </li><li>build是固定结束格式</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span>  <span class="comment">//开启swagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>{</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">(Environment environment)</span></span>{</span><br><span class="line">        <span class="comment">//读取application.yml读取的环境</span></span><br><span class="line">        Profiles profiles = Profiles.of(<span class="string">"dev"</span>,<span class="string">"test"</span>);</span><br><span class="line">        <span class="comment">//判断运行的环境是否是可读取的环境</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = environment.acceptsProfiles(profiles);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(<span class="keyword">new</span> ApiInfo(<span class="string">"小婉Swagger"</span>,   <span class="comment">//title</span></span><br><span class="line">                                <span class="string">"当一个闲鱼"</span>,<span class="comment">//description</span></span><br><span class="line">                                <span class="string">"v.1.0"</span>,<span class="comment">//版本</span></span><br><span class="line">                                <span class="string">"47.100.69.105"</span>,    <span class="comment">//服务器地址</span></span><br><span class="line">                                <span class="keyword">new</span> Contact(</span><br><span class="line">                                        <span class="string">"小婉"</span>,</span><br><span class="line">                                        <span class="string">"47.100.69.105"</span>,</span><br><span class="line">                                        <span class="string">"wlkjava@163.com"</span></span><br><span class="line">                                ),     <span class="comment">//个人介绍</span></span><br><span class="line">                                <span class="string">"Apache 2.0"</span>,</span><br><span class="line">                                <span class="string">"http://www.apache.org/licenses/LICENSE-2.0"</span>,</span><br><span class="line">                                <span class="keyword">new</span> ArrayList()</span><br><span class="line">                                )</span><br><span class="line">                        )</span><br><span class="line">                <span class="comment">//右上角的命名path</span></span><br><span class="line">                .groupName(<span class="string">"learn"</span>)</span><br><span class="line">                <span class="comment">//设置swagger是否启动</span></span><br><span class="line">                .enable(flag)</span><br><span class="line">                .select()</span><br><span class="line">                <span class="comment">//RequestHandlerSelectors.basePackage扫描包下的所有接口</span></span><br><span class="line">                <span class="comment">//RequestHandlerSelectors.any扫描所有接口    具体的可查看源码</span></span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">"com.example.swagger.controller"</span>))</span><br><span class="line">                <span class="comment">//匹配所有符合的路径</span></span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h6 id="swagger的常用注解"><a href="#swagger的常用注解" class="headerlink" title="swagger的常用注解"></a>swagger的常用注解</h6><ul><li>@ApiModel    用在实体类上的注解</li><li>@ApiModelProperty        用在字段上的注解</li><li>@ApiOperation                 用在方法上的注解</li><li>@ApiParam                       用在入参上的注解</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ApiModel(value = "用户信息表")</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = "用户名")</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@ApiModelProperty(value = "密码")</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210123111636040.png" alt="image-20210123111636040"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiOperation("测试")</span></span><br><span class="line"><span class="meta">@PostMapping(value = "/test")</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(<span class="meta">@ApiParam(value ="用户名")</span> String  userName)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> userName;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>1、swagger在一些比较难理解的属性或者接口上增加注释信息 （替换了平常书写接口文档的office、wps等）</p><p>2、接口文档实时更新（更易于前后端对接、其各部分之间的对接）</p><p>3、在线测试工具（替换了接口测试工具，如POSTMan等）</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> swagger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射基础</title>
      <link href="2021/04/20/fan-she-ji-chu/"/>
      <url>2021/04/20/fan-she-ji-chu/</url>
      
        <content type="html"><![CDATA[<blockquote><h6 id="正常方式-引入包名、类名-————————-gt-new对象————————-gt-取得实例化对象"><a href="#正常方式-引入包名、类名-————————-gt-new对象————————-gt-取得实例化对象" class="headerlink" title="正常方式: 引入包名、类名_————————>new对象————————>取得实例化对象"></a>正常方式: 引入包名、类名_————————&gt;new对象————————&gt;取得实例化对象</h6></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.annotation.example.demo.controller;import com.annotation.example.demo.entity.Student; //引入类名public class Reflection {    public void test(){        Student student = new Student();  //new对象        student.getAddress(); //获取对象信息    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h6 id="反射方式：-实例化对象—————————-gt-getClass-方法—————————-gt-获取完整的包类信息"><a href="#反射方式：-实例化对象—————————-gt-getClass-方法—————————-gt-获取完整的包类信息" class="headerlink" title="反射方式：  实例化对象—————————>getClass()方法—————————>获取完整的包类信息"></a>反射方式：  实例化对象—————————&gt;getClass()方法—————————&gt;获取完整的包类信息</h6></blockquote><blockquote><h6 id="全路径信息—————————-gt-forName-方法—————————-gt-获取完整的包类信息"><a href="#全路径信息—————————-gt-forName-方法—————————-gt-获取完整的包类信息" class="headerlink" title="全路径信息—————————>forName()方法—————————>获取完整的包类信息"></a>全路径信息—————————&gt;forName()方法—————————&gt;获取完整的包类信息</h6></blockquote><blockquote><h6 id="类名————————————-gt-class——————————————-gt-获取完整的包类信息"><a href="#类名————————————-gt-class——————————————-gt-获取完整的包类信息" class="headerlink" title="类名————————————>.class——————————————>获取完整的包类信息"></a>类名————————————&gt;.class——————————————&gt;获取完整的包类信息</h6></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void main(String[] args) throws ClassNotFoundException {    // 方式1----通过全路径获取student信息    Class c= Class.forName("com.annotation.example.demo.entity.Student");    System.out.println(c.hashCode());    //方式2----通过new对象的getClass()方法获取student信息    Student student = new Student();    Class c2 = student.getClass();    System.out.println(c2.hashCode());    //方式3----通过类名获取student信息    Class c1 = Student.class;    System.out.println(c1.hashCode());}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h6 id="反射获取基本信息：更多方法可自行测试查看"><a href="#反射获取基本信息：更多方法可自行测试查看" class="headerlink" title="反射获取基本信息：更多方法可自行测试查看"></a>反射获取基本信息：更多方法可自行测试查看</h6></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException {    // 方式1----通过全路径获取student信息    Class c= Class.forName("com.annotation.example.demo.entity.Student");    System.out.println(c.hashCode());    //获得包名+类名    System.out.println(c.getName());    //获得类名    System.out.println(c.getSimpleName());    //获取public的信息    Field[] fields = c.getFields();    for (Field field : fields) {        System.out.println(field);    }    //获取全部的信息    Field[] declaredFields = c.getDeclaredFields();    for (Field field : declaredFields) {        System.out.println(field);    }    //获取具体某一个的字段    Field name = c.getDeclaredField("name");    System.out.println(name);    //获取本类的方法及其父类的额所有方法    Method[] methods = c.getMethods();    for (Method method : methods) {        System.out.println(method);    }    //只获取本类的基本信息    Method[] declaredMethods = c.getDeclaredMethods();    for (Method declaredMethod : declaredMethods) {        System.out.println(declaredMethod);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h6 id="常用的获取对象信息的方式"><a href="#常用的获取对象信息的方式" class="headerlink" title="常用的获取对象信息的方式"></a>常用的获取对象信息的方式</h6></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void main(String[] args) throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException {    Class c = Student.class;    //通过newInstance的方式获取对象信息    Student student = (Student) c.newInstance();    student.setName("小婉");    System.out.println(student.getName());    //通过构造器创建对象    Constructor declaredConstructor = c.getDeclaredConstructor(String.class, String.class, int.class);    Student student1 = (Student) declaredConstructor.newInstance("小婉", "驻马店", 30);    System.out.println(student1);    //通过获取方法获得对象信息    Student student2 = (Student) c.newInstance();    Method setName = c.getDeclaredMethod("setName", String.class);   setName.invoke(student2, "小婉");    System.out.println(student2.getName());    //通过反射操作属性    Student student3 = (Student) c.newInstance();    Field name1 = c.getDeclaredField("name");    //不能直接操作私有属性,关闭安全检测，如果反射运用比较多，可以关闭检测提高性能    name1.setAccessible(true);    name1.set(student3,"小婉");    System.out.println(student3.getName());}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h6 id="获取参数类型及返回值类型步骤"><a href="#获取参数类型及返回值类型步骤" class="headerlink" title="获取参数类型及返回值类型步骤"></a>获取参数类型及返回值类型步骤</h6></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void main(String[] args) throws NoSuchMethodException {    Method method = Reflection2.class.getMethod("test1", Map.class, List.class); //获取test1的方法    Type[] types = method.getGenericParameterTypes(); //获取方法内所有的参数    for (Type type : types) {  //便利参数        System.out.println(type); //输出参数        if (type instanceof ParameterizedType){   //查看参数是否属于参数化类型            Type[] typeArguments = ((ParameterizedType) type).getActualTypeArguments();  //把参数强转为参数化类型在获取具体的参数            for (Type typeArgument : typeArguments) {                System.out.println(typeArgument);   //便利参数并打印            }        }    }    Method method1 = Reflection2.class.getMethod("test2");    Type genericReturnType = method1.getGenericReturnType();   //获取返回参数类型    System.out.println(genericReturnType);    if (genericReturnType instanceof ParameterizedType){   //查看参数是否属于参数化类型        Type[] typeArguments = ((ParameterizedType) genericReturnType).getActualTypeArguments();  //把参数强转为参数化类型在获取具体的参数        for (Type typeArgument : typeArguments) {            System.out.println(typeArgument);   //便利参数并打印        }    }}public void test1(Map&lt;String, Student&gt; map, List&lt;Student&gt; list){    System.out.println("test1");}public Map&lt;String,Student&gt; test2(){    System.out.println("test2");    return null;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h6 id="获取注解的值及参数信息"><a href="#获取注解的值及参数信息" class="headerlink" title="获取注解的值及参数信息"></a>获取注解的值及参数信息</h6></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Reflection3 {    public static void main(String[] args) throws NoSuchFieldException {        classAnnotation annotation = Student2.class.getAnnotation(classAnnotation.class);        System.out.println(annotation.value());        Field name = Student2.class.getDeclaredField("name");        filedAnnotation annotation1 = name.getAnnotation(filedAnnotation.class);        System.out.println(annotation1.id());        System.out.println(annotation1.length());        //db_student//db_id//10      }}@Data@classAnnotation("db_student")class Student2{    @filedAnnotation(id="db_id",length = 10)    private String name;    @filedAnnotation(id="db_address",length = 19)    private String address;    @filedAnnotation(id="db_age",length = 3)    private int age;}/** * 类注解 */@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@interface classAnnotation{    String value();}/** * 字段注解 */@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@interface filedAnnotation{    String id();    int length();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全局捕获日志</title>
      <link href="2021/04/20/quan-ju-bu-huo-ri-zhi/"/>
      <url>2021/04/20/quan-ju-bu-huo-ri-zhi/</url>
      
        <content type="html"><![CDATA[<h6 id="问题：记录所有方法运行时间用来判断哪些方法的书写不规范导致运行时间过长，如果超过规定的秒数-2000ms-则存储到日志表，以便后续优化。"><a href="#问题：记录所有方法运行时间用来判断哪些方法的书写不规范导致运行时间过长，如果超过规定的秒数-2000ms-则存储到日志表，以便后续优化。" class="headerlink" title="问题：记录所有方法运行时间用来判断哪些方法的书写不规范导致运行时间过长，如果超过规定的秒数(2000ms)则存储到日志表，以便后续优化。"></a>问题：记录所有方法运行时间用来判断哪些方法的书写不规范导致运行时间过长，如果超过规定的秒数(2000ms)则存储到日志表，以便后续优化。</h6><p>一、引入常用jar包</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--web依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--lombok --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--测试依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--aop依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--日志依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--swagger依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--swagger图形页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mybatisPlus依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mybatisPlus生成代码依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mybatisPlus生成模板前端模板依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.freemarker<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>freemarker<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.30<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mysql依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--热部署依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--druid连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.29<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--hutool工具类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>二、书写aop切入方法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspectConfig</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> LogOverTimeMapper logOverTimeMapper;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置切入点的值为LogAnnotation注解</span></span><br><span class="line">    <span class="comment">//如果嫌注解麻烦，可以配置具体的类上例如：@Pointcut("execution(* com.example.aop.controller.TestController.*(..)) ||     @annotation(com.example.aop.annotation.LogAnnotation)")</span></span><br><span class="line">    <span class="meta">@Pointcut(value = "@annotation(com.example.aop.annotation.LogAnnotation)")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用环绕通知，在方法的执行前后分别记录一个时间相减</span></span><br><span class="line">    <span class="meta">@Around("pointCut()")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doLog</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span></span>{</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        Object object=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            object=proceedingJoinPoint.proceed();</span><br><span class="line">        } <span class="keyword">catch</span> (Throwable throwable) {</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">            log.info(throwable.getMessage());</span><br><span class="line">        }<span class="keyword">finally</span> {</span><br><span class="line">            <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">            <span class="comment">//如果最后时间减去开始时间大于2000ms则插入日志表</span></span><br><span class="line">            <span class="keyword">if</span> ((endTime-startTime)&gt;<span class="keyword">new</span> Long(<span class="number">2000</span>)){</span><br><span class="line">                LogOverTime logOverTime = <span class="keyword">new</span> LogOverTime();</span><br><span class="line">                logOverTime.setLastDate( LocalDateTime.now());</span><br><span class="line">                logOverTime.setLastName(<span class="string">"admin"</span>);</span><br><span class="line">                logOverTime.setMethod(proceedingJoinPoint.getSignature().toShortString());</span><br><span class="line">                logOverTime.setRunMillisecond(<span class="keyword">new</span> Integer((<span class="keyword">int</span>) (endTime-startTime)));</span><br><span class="line">                logOverTimeMapper.insert(logOverTime);</span><br><span class="line">            }</span><br><span class="line">            log.info(proceedingJoinPoint.getSignature().toShortString() + <span class="string">"方法执行了："</span> + (endTime - startTime) + <span class="string">"ms"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>三、书写注解LogAnnotation</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(value = ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(value = RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> LogAnnotation {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>四、书写实体类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode(callSuper = false)</span></span><br><span class="line"><span class="meta">@ApiModel(value="LogOverTime对象", description="方法超时日志表")</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogOverTime</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = "主键自增")</span></span><br><span class="line">    <span class="meta">@TableId(value = "id", type = IdType.AUTO)</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = "方法")</span></span><br><span class="line">    <span class="keyword">private</span> String method;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = "运行时间")</span></span><br><span class="line">    <span class="keyword">private</span> Integer runMillisecond;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = "最后修改时间")</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime lastDate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = "最后修改人")</span></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>五、书写Mapper</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此Mapper用的增强mybatis（mybatis_plus）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LogOverTimeMapper</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">LogOverTime</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>六、书写测试类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping("/testApi")</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@LogAnnotation</span></span><br><span class="line">    <span class="meta">@PostMapping("/test1")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testAop</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"123132"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@LogAnnotation</span></span><br><span class="line">    <span class="meta">@PostMapping("/test2")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAop2</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义注解</title>
      <link href="2021/04/20/zi-ding-yi-zhu-jie/"/>
      <url>2021/04/20/zi-ding-yi-zhu-jie/</url>
      
        <content type="html"><![CDATA[<h6 id="Target-：用于描述注解的使用范围"><a href="#Target-：用于描述注解的使用范围" class="headerlink" title="@Target ：用于描述注解的使用范围"></a>@Target ：用于描述注解的使用范围</h6><h6 id="Retention：-表示需在该级别保存注释信息，用于描述生命周期，常用的有（SOURCE-lt-CLASS-lt-RUNTIME）"><a href="#Retention：-表示需在该级别保存注释信息，用于描述生命周期，常用的有（SOURCE-lt-CLASS-lt-RUNTIME）" class="headerlink" title="@Retention： 表示需在该级别保存注释信息，用于描述生命周期，常用的有（SOURCE<CLASS<RUNTIME）"></a>@Retention： 表示需在该级别保存注释信息，用于描述生命周期，常用的有（SOURCE&lt;CLASS&lt;RUNTIME）</h6><h6 id="Document-说明该注解被包含在javadoc中"><a href="#Document-说明该注解被包含在javadoc中" class="headerlink" title="@Document : 说明该注解被包含在javadoc中"></a>@Document : 说明该注解被包含在javadoc中</h6><h6 id="inherited：说明之类可以继承父类中的注解"><a href="#inherited：说明之类可以继承父类中的注解" class="headerlink" title="@inherited：说明之类可以继承父类中的注解"></a>@inherited：说明之类可以继承父类中的注解</h6><h6 id="注解参数的注意事项，如果注解的参数只有一个且为value时，可以省略value参数。"><a href="#注解参数的注意事项，如果注解的参数只有一个且为value时，可以省略value参数。" class="headerlink" title="注解参数的注意事项，如果注解的参数只有一个且为value时，可以省略value参数。"></a>注解参数的注意事项，如果注解的参数只有一个且为value时，可以省略value参数。</h6><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotations(name="微录客",schools = {"北京大学","清华大学"})</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAnnotation</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyAnnotations(name="微录客",schools = {"北京大学","清华大学"})</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(value = {ElementType.METHOD,ElementType.TYPE})</span>       <span class="comment">//  描述在方法、包、类上等等</span></span><br><span class="line"><span class="meta">@Retention(value = RetentionPolicy.RUNTIME )</span>   <span class="comment">//表示该注释的生命周期为</span></span><br><span class="line"><span class="meta">@Documented</span>     <span class="comment">//该注解包含在文档中</span></span><br><span class="line"><span class="meta">@Inherited</span>      <span class="comment">//该注解可以被之类继承</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotations{</span><br><span class="line">    <span class="comment">//注解的参数 如果没有默认值必须在注解上加上该注解的参数，可以为String类型也可以为数组</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span>  ""</span>;</span><br><span class="line">    String [] schools();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>永鑫项目架构搭建</title>
      <link href="2021/04/20/yong-xin-xiang-mu-jia-gou-da-jian/"/>
      <url>2021/04/20/yong-xin-xiang-mu-jia-gou-da-jian/</url>
      
        <content type="html"><![CDATA[<h6 id="一、项目搭建目的"><a href="#一、项目搭建目的" class="headerlink" title="一、项目搭建目的"></a>一、项目搭建目的</h6><p>由于永城收付管理系统速率过慢，代码冗余，因此需一步一步的把永城收付管理系统的永鑫模块单独独立出来。</p><h6 id="二、框架设计"><a href="#二、框架设计" class="headerlink" title="二、框架设计"></a>二、框架设计</h6><ul><li>框架：Springboot微服务为基础，shiro做为权限框架，layui前端框架，模板引擎是thymleaf、orm采用mybatisPlus</li><li>数据库：oracle数据库，druid连接池</li><li>中间件：jwt用作token认证，redis缓存框架，swagger接口展示,quartz定时任务。</li></ul><h6 id="三、项目设计"><a href="#三、项目设计" class="headerlink" title="三、项目设计"></a>三、项目设计</h6><ol><li>权限方面重新设计</li><li>批处理项目取消，统一改成quartz定时任务。</li><li>web项目进行重构</li></ol><h6 id="四、项目注意要点"><a href="#四、项目注意要点" class="headerlink" title="四、项目注意要点"></a>四、项目注意要点</h6><ol><li>采用前后端分离模式，前后端数据传输json格式。</li><li>规定好正确返回、错误返回的信息标志，例（成功0000，失败4000）等标志以方便对接。</li><li>设置全局异常捕获框架以方便异常造成的事故定位。</li><li>全局打印一个方法的运行时间，如果超过规定的时间则记录下来并存入日志中以便后续排查。</li><li>文档设计安装统一格式，且统一上传到永鑫收付文件服务器上以便统一管理。</li></ol><h6 id="五、项目采用版本"><a href="#五、项目采用版本" class="headerlink" title="五、项目采用版本"></a>五、项目采用版本</h6><table><thead><tr><th>springboot</th><th>2.1.8</th></tr></thead><tbody><tr><td>shiro</td><td>1.4.1</td></tr><tr><td>swagger</td><td>2.9.2</td></tr><tr><td>fastjson</td><td>1.2.49</td></tr><tr><td>jwt</td><td>0.9.1</td></tr><tr><td>oracle</td><td>11</td></tr><tr><td>java</td><td>8</td></tr><tr><td>druid</td><td>1.1.10</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux基础命令</title>
      <link href="2021/04/18/linux-ji-chu-ming-ling/"/>
      <url>2021/04/18/linux-ji-chu-ming-ling/</url>
      
        <content type="html"><![CDATA[<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看版本信息</span></span><br><span class="line">uname -r</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看系统版本</span></span><br><span class="line">cat /etc/os-release</span><br><span class="line"><span class="meta">#</span><span class="bash">centos7的查看关闭开启防火墙命令</span></span><br><span class="line">firewall-cmd --state#查看防火墙状态</span><br><span class="line">systemctl stop firewalld.service#停止防火墙</span><br><span class="line">systemctl disable firewalld.service #开机自启</span><br></pre></td></tr></tbody></table></figure><h6 id="文件处理命令"><a href="#文件处理命令" class="headerlink" title="文件处理命令"></a>文件处理命令</h6><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 显示目录文件</span></span><br><span class="line">ls </span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示带隐藏的目录文件</span></span><br><span class="line">ls -a</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建目录</span></span><br><span class="line">mkdir 目录名</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建文件</span></span><br><span class="line">touch 文件名</span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换目录</span></span><br><span class="line">cd  /目录</span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回上一级目录</span></span><br><span class="line">cd ..</span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示当前目录</span></span><br><span class="line">pwd</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除空目录</span></span><br><span class="line">rmdir /目录</span><br><span class="line"><span class="meta">#</span><span class="bash"> 复制目录或者文件</span></span><br><span class="line">cp -rp /源文件或者目录 /目标目录</span><br><span class="line"><span class="meta">#</span><span class="bash"> 剪切文件或目录</span></span><br><span class="line">mv /源文件或者目录 /目标目录</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除文件或目录</span></span><br><span class="line">rm -rf /目录或文件</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查询文件信息</span></span><br><span class="line">cat 文件名  </span><br><span class="line">tail -f 文件名  #实时查询信息</span><br><span class="line">tail -n 1000 文件名 #倒叙查询1000行信息</span><br></pre></td></tr></tbody></table></figure><h6 id="权限管理命令"><a href="#权限管理命令" class="headerlink" title="权限管理命令"></a>权限管理命令</h6><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 参数 文件名#更改文件的读写执行权限  参数有-r -w -x 读 写 执行 u所有人 g所属组 例如：chown U+x 123.log</span><br><span class="line">chown 用户 文件名#更改某个文件用户权限用户必须是真实存在的</span><br></pre></td></tr></tbody></table></figure><h6 id="文件查询命令"><a href="#文件查询命令" class="headerlink" title="文件查询命令"></a>文件查询命令</h6><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find /目录或文件 -name *init*#查询含有init的文件 *可以匹配任意个字符</span><br><span class="line">find /目录或文件 -name *init？？？#一个？只能匹配一个字符</span><br></pre></td></tr></tbody></table></figure><h6 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h6><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">whoami #查看当前用户</span><br><span class="line">useradd -m 账号#新建一个账号</span><br><span class="line">passwd 账号#给此账号输入密码</span><br><span class="line">userdel -r 账号 #删除账号信息</span><br></pre></td></tr></tbody></table></figure><h6 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h6><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cal -1 5 2020  #查看2020年5月份的日历</span><br><span class="line">wc -lc 文件名 &gt;要创建的文件# 统计某个文件的行数和列数要书写到某个文件</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker基础</title>
      <link href="2021/04/18/docker-ji-chu/"/>
      <url>2021/04/18/docker-ji-chu/</url>
      
        <content type="html"><![CDATA[<h6 id="docker的默认工作路径是-var-lib-docker"><a href="#docker的默认工作路径是-var-lib-docker" class="headerlink" title="docker的默认工作路径是      /var/lib/docker"></a>docker的默认工作路径是      /var/lib/docker</h6><h6 id="docker的基础是镜像与容器"><a href="#docker的基础是镜像与容器" class="headerlink" title="docker的基础是镜像与容器"></a>docker的基础是镜像与容器</h6><h6 id="docker的官网地址：https-docs-docker-com"><a href="#docker的官网地址：https-docs-docker-com" class="headerlink" title="docker的官网地址：https://docs.docker.com/"></a>docker的官网地址：<a href="https://docs.docker.com/">https://docs.docker.com/</a></h6><h4 id="Docker的基本命令："><a href="#Docker的基本命令：" class="headerlink" title="Docker的基本命令："></a>Docker的基本命令：</h4><pre class="line-numbers language-none"><code class="language-none">docker version    #查看docker的基本信息docker info #显示docker的系统信息，包括镜像和容器镜像docker 命令 --help #docker命令帮助查询12321312<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Docker的镜像常用命令："><a href="#Docker的镜像常用命令：" class="headerlink" title="Docker的镜像常用命令："></a>Docker的镜像常用命令：</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker images -a#查看所有镜像信息docker images -q #查看所有镜像iddocker images -filter ......   #过滤信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="docker搜索镜像："><a href="#docker搜索镜像：" class="headerlink" title="docker搜索镜像："></a>docker搜索镜像：</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker search 服务名称  例如：docker search java  docker search mysqldocker search mysql --filter=stars=200   #查询星数在200以上<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="拉取镜像："><a href="#拉取镜像：" class="headerlink" title="拉取镜像："></a>拉取镜像：</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker pull (镜像名称)：（镜像版本）   #例如  docker pull mysql:5.7   docker pull (镜像名称)#拉取最新版本的镜像信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="删除镜像："><a href="#删除镜像：" class="headerlink" title="删除镜像："></a>删除镜像：</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker rmi -f (镜像id)#删除镜像信息，镜像d可通过docker images进行查询docker rmi -f $（dokcer images） #删除所有镜像信息dokker rmi -f 镜像id 镜像id #删除多个镜像信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="Docker的容器命令："><a href="#Docker的容器命令：" class="headerlink" title="Docker的容器命令："></a>Docker的容器命令：</h4><h6 id="首先我们先下载个centos镜像命令进行学习"><a href="#首先我们先下载个centos镜像命令进行学习" class="headerlink" title="首先我们先下载个centos镜像命令进行学习"></a>首先我们先下载个centos镜像命令进行学习</h6><pre class="line-numbers language-none"><code class="language-none">docker pull centos<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h6 id="容器命令："><a href="#容器命令：" class="headerlink" title="容器命令："></a>容器命令：</h6><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker run [可选参数] image#常用参数--name   #容器名字，用来区分容器-d #后台方式运行-it  #使用交互方式运行，进入容器查看内容-p #指定容器的端口  -p 主机端口：容器端口-P #随机指定端口运行查看容器：docker run -it centos /bin/bash  #进入centosdocker ps #查看正在运行的容器docker ps -a #查看历史运行的容器docker ps -n=？   #查看最近运行的容器,如果加上=？则表示最近几条退出容器：exit #容器停止并退出CTRL+P+Q#容器不停止退出删除容器：docker rm 容器id    #删除非运行的容器，如果运行会报错docker rm -f 容器id#强制删除容器docker rm -f $(docker ps -aq)#删除所有容器id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="启动容器命令："><a href="#启动容器命令：" class="headerlink" title="启动容器命令："></a>启动容器命令：</h6><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker start 容器id#启动容器docker restart 容器id#重启容器docker stop 容器id#停止正在运行的容器docker kill 容器id#强制停止当前容器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h6 id="日志命令："><a href="#日志命令：" class="headerlink" title="日志命令："></a>日志命令：</h6><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker logs -tf tail 10 容器id   #查询后十条日志信息   tail 10 可省略<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h6 id="常用其他命令："><a href="#常用其他命令：" class="headerlink" title="常用其他命令："></a>常用其他命令：</h6><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker top 容器id#查看容器进程docker inspect  容器id#查看容器的基本信息docker exec  -it  容器id /bin/bash#进入正在启动的容器，并开启一个新容器docker attach 容器id#进入正在启动的容器，不会启动新的容器docker cp 容器id:容器内路径 容器外路径  #复制文件从内部容器到外部容器docker stats #查询docker的内存使用率<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="下载nginx镜像到linux服务器"><a href="#下载nginx镜像到linux服务器" class="headerlink" title="下载nginx镜像到linux服务器"></a>下载nginx镜像到linux服务器</h6><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker search nginx #查看镜像docker pull nginx #下载最新版本的镜像docker images#查看下载的容器docker run -d --name nginx01 -p 3344:80 nginx#-d   后台运行# --name 给容器起个名字以便分辨# -p 3344 宿主机端口,即外部端口# 80 内部容器端口即nginx端口 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="下载mysql5-7到linux服务器"><a href="#下载mysql5-7到linux服务器" class="headerlink" title="下载mysql5.7到linux服务器"></a>下载mysql5.7到linux服务器</h6><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#获取mysql镜像docker pull mysql:5.7# -v 卷挂载# -e 环境配置# -d 后台运行# -p 端口映射# --name 给容器命名# 配置mysql地址环境docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql  -e MYSQL_ROOT_PASSWORD=wlk161536 --name mysql01 mysql:5.7#-v的目的是映射到本地 前面的表示宿主机文件，后面表示docker内文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="提交镜像"><a href="#提交镜像" class="headerlink" title="提交镜像"></a>提交镜像</h6><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker commit -m="描述提交的信息" -a="作者" 容器id 目录镜像名:[tags版本]例如：1、先运行一个tomcat镜像docker run -it 容器id /bin/bash2、启动tomcat镜像docker exec -it 容器id /bin/bash3、由于docker中的webApps下没有目录，需要webApps.dist文件复制到webApps下cp -r webApps.dist/* webApps4、把修改后的镜像提交docker commit -m ="添加webbApps信息" -a="moerWolld" 容器id tomcat2:1.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-SHELL" data-language="SHELL"><code class="language-SHELL">#查看镜像的历史构建记录   可查看构造方式仿造一个同样的镜像docker history 镜像id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
