<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Alibaba</title>
      <link href="2021/05/30/alibaba/"/>
      <url>2021/05/30/alibaba/</url>
      
        <content type="html"><![CDATA[<h4 id="springCloud-alibaba的nacos组件"><a href="#springCloud-alibaba的nacos组件" class="headerlink" title="springCloud alibaba的nacos组件"></a>springCloud alibaba的nacos组件</h4>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idea的常用快捷键</title>
      <link href="2021/05/26/idea-de-chang-yong-kuai-jie-jian/"/>
      <url>2021/05/26/idea-de-chang-yong-kuai-jie-jian/</url>
      
        <content type="html"><![CDATA[<h4 id="CTRL"><a href="#CTRL" class="headerlink" title="CTRL+"></a>CTRL+</h4><table><thead><tr><th>快捷键</th><th>介绍</th></tr></thead><tbody><tr><td>Ctrl + F</td><td>在当前文件进行文本查找 （必备）</td></tr><tr><td>Ctrl + R</td><td>在当前文件进行文本替换 （必备）</td></tr><tr><td>Ctrl + Z</td><td>撤销 （必备）</td></tr><tr><td>Ctrl + Y</td><td>删除光标所在行 或 删除选中的行 （必备）</td></tr><tr><td>Ctrl + X</td><td>剪切光标所在行 或 剪切选择内容</td></tr><tr><td>Ctrl + C</td><td>复制光标所在行 或 复制选择内容</td></tr><tr><td>Ctrl + D</td><td><strong>复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 （必备）</strong></td></tr><tr><td>Ctrl + W</td><td><strong>递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围 （必备）</strong></td></tr><tr><td>Ctrl + E</td><td>显示最近打开的文件记录列表</td></tr><tr><td>Ctrl  N</td><td>根据输入的 类名 查找类文件</td></tr><tr><td>Ctrl + G</td><td>查找当前文件中某一行的信息</td></tr><tr><td>Ctrl + J</td><td><strong>插入自定义的模板</strong></td></tr><tr><td>Ctrl + P</td><td>用于提示当前的方法需要哪些参数</td></tr><tr><td>Ctrl + Q</td><td>光标所在的变量 / 类名 / 方法名的路径</td></tr><tr><td>Ctrl + B</td><td>进入光标所在的方法/变量的接口或是定义出，等效于 Ctrl + 左键单击</td></tr><tr><td>Ctrl + O</td><td>选择可重写的方法</td></tr><tr><td>Ctrl + I</td><td>选择可继承的方法</td></tr><tr><td>Ctrl + +</td><td>展开代码</td></tr><tr><td>Ctrl +  -</td><td>折叠代码</td></tr><tr><td>Ctrl + /</td><td>注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 （必备）</td></tr><tr><td>Ctrl + [</td><td>移动光标到当前所在代码的花括号开始位置</td></tr><tr><td>Ctrl + ]</td><td>移动光标到当前所在代码的花括号结束位置</td></tr><tr><td>Ctrl + F3</td><td>调转到所选中的词的下一个引用位置</td></tr><tr><td>Ctrl + F4</td><td>关闭当前编辑文件</td></tr><tr><td>Ctrl + F8</td><td>在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点</td></tr><tr><td>Ctrl + F9</td><td>执行 Make Project 操作</td></tr><tr><td>Ctrl + F12</td><td>弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选</td></tr><tr><td>Ctrl + Tab</td><td>编辑窗口切换，如果在切换的过程又加按上delete，则是关闭对应选中的窗口</td></tr></tbody></table><h4 id="ALT"><a href="#ALT" class="headerlink" title="ALT+"></a>ALT+</h4><table><thead><tr><th>快捷键</th><th>介绍</th></tr></thead><tbody><tr><td>Alt + Insert</td><td>代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等</td></tr><tr><td>Alt + F3</td><td>选中文本，逐个往下查找相同文本，并高亮显示</td></tr><tr><td>Alt + F7</td><td>查找光标所在的方法 / 变量 / 类被调用的地方</td></tr><tr><td>Alt + F8</td><td>在 Debug 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果</td></tr><tr><td>Alt + 左方向键</td><td>按左方向切换当前已打开的文件视图</td></tr><tr><td>Alt + 右方向键</td><td>按右方向切换当前已打开的文件视图</td></tr><tr><td>Alt + 前方向键</td><td>当前光标跳转到当前文件的前一个方法名位置</td></tr><tr><td>Alt + 后方向键</td><td>当前光标跳转到当前文件的后一个方法名位置</td></tr></tbody></table><h4 id="SHIFT"><a href="#SHIFT" class="headerlink" title="SHIFT+"></a>SHIFT+</h4><table><thead><tr><th>快捷键</th><th>介绍</th></tr></thead><tbody><tr><td>Shift + F4</td><td>对当前打开的文件，使用新Windows窗口打开，旧窗口保留</td></tr><tr><td>Shift + F7</td><td>在 Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法</td></tr><tr><td>Shift + F8</td><td>在 Debug 模式下，跳出，表现出来的效果跟 F9 一样</td></tr><tr><td>Shift + Tab</td><td>取消缩进</td></tr><tr><td>Shift + 左键单击</td><td>在打开的文件名上按此快捷键，可以关闭当前打开文件</td></tr><tr><td>Shift + 滚轮前后滚动</td><td>当前文件的横向滚动轴滚动</td></tr></tbody></table><h4 id="CTRL-ALT"><a href="#CTRL-ALT" class="headerlink" title="CTRL+ALT"></a>CTRL+ALT</h4><table><thead><tr><th>快捷键</th><th>介绍</th></tr></thead><tbody><tr><td>Ctrl + Alt + L</td><td>格式化代码，可以对当前文件和整个包目录使用 （必备）</td></tr><tr><td>Ctrl + Alt + B</td><td>在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口）</td></tr><tr><td>Ctrl + Alt + I</td><td>光标所在行 或 选中部分进行自动代码缩进，有点类似格式化</td></tr><tr><td>Ctrl + Alt + V</td><td>快速引进变量</td></tr><tr><td>Ctrl + Alt + S</td><td>打开 IntelliJ IDEA 系统设置</td></tr><tr><td>Ctrl + Alt + F11</td><td>切换全屏模式</td></tr><tr><td>Ctrl + Alt + Enter</td><td>光标所在行上空出一行，光标定位到新行</td></tr><tr><td>Ctrl + Alt + 左方向键</td><td>退回到上一个操作的地方 （必备）（注意与其他软件快捷键冲突）</td></tr><tr><td>Ctrl + Alt + 右方向键</td><td>前进到上一个操作的地方 （必备）（注意与其他软件快捷键冲突）</td></tr><tr><td>Ctrl + Alt + 前方向键</td><td>在查找模式下，跳到上个查找的文件</td></tr><tr><td>Ctrl + Alt + 后方向键</td><td>在查找模式下，跳到下个查找的文件</td></tr></tbody></table><h4 id="CTRL-SHIFT"><a href="#CTRL-SHIFT" class="headerlink" title="CTRL+SHIFT"></a>CTRL+SHIFT</h4><table><thead><tr><th>快捷键</th><th>介绍</th></tr></thead><tbody><tr><td>Ctrl + Shift + R</td><td>根据输入内容查找或替换对应内容，范围为整个项目 或 指定目录内文件 （必备）</td></tr><tr><td>Ctrl + Shift + J</td><td>自动将下一行合并到当前行末尾 （必备）</td></tr><tr><td>Ctrl + Shift + Z</td><td>取消撤销 （必备）</td></tr><tr><td>Ctrl + Shift + W</td><td>递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 （必备）</td></tr><tr><td>Ctrl + Shift + U</td><td>对选中的代码进行大 / 小写轮流转换 （必备）</td></tr><tr><td>Ctrl + Shift + C</td><td>复制当前文件磁盘路径到剪贴板</td></tr><tr><td>Ctrl + Shift + +</td><td>展开所有代码</td></tr><tr><td>Ctrl + Shift + -</td><td>折叠所有代码</td></tr><tr><td>Ctrl + Shift + F7</td><td>高亮显示所有该选中文本，按Esc高亮消失</td></tr><tr><td>Ctrl + Shift + F12</td><td>编辑器最大化</td></tr><tr><td>Ctrl + Shift + Enter</td><td>自动结束代码，行末自动添加分号 （必备）</td></tr><tr><td>Ctrl + Shift + Backspace</td><td>退回到上次修改的地方</td></tr><tr><td>Ctrl + Shift + 左/右方向键</td><td>在代码上选中区域调试，在文件上结构宽度调试</td></tr><tr><td>Ctrl + Shift + 后方向键</td><td>在代码上上下文件换位，在文件上选中文件</td></tr></tbody></table><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><table><thead><tr><th>快捷键</th><th>介绍</th></tr></thead><tbody><tr><td>F2</td><td>跳转到下一个高亮错误 或 警告位置 （必备）</td></tr><tr><td>F3</td><td>在查找模式下，定位到下一个匹配处</td></tr><tr><td>F4</td><td>编辑源</td></tr><tr><td>F7</td><td>在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中</td></tr><tr><td>F8</td><td>在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内</td></tr><tr><td>Tab</td><td>缩进</td></tr><tr><td>连按两次Shift</td><td>弹出 Search Everywhere 弹出层</td></tr></tbody></table><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shiro</title>
      <link href="2021/05/26/shiro/"/>
      <url>2021/05/26/shiro/</url>
      
        <content type="html"><![CDATA[<h4 id="shiro的核心组件"><a href="#shiro的核心组件" class="headerlink" title="shiro的核心组件"></a>shiro的核心组件</h4><ol><li><code>Subject</code>即主体，外部应用与subject进行交互，subject记录了当前的操作用户，将用户的概念理解为当前操作的主体。外部程序通过subject进行认证授权，而subject是通过SecurityManager安全管理器进行认证授权。</li><li>SecurityManager即安全管理器，对全部的subject进行安全管理，它是shiro的核心，负责对所有的subject进行安全管理。通过SecurityManager可以完成subject的认证、授权等，实质上SecurityManager是通过Authenticator进行认证，通过Authorizer进行授权，通过SessionManager进行会话管理等</li><li><code>Authenticator</code>即认证器，对用户身份进行认证，Authenticator是一个接口，shiro提供ModularRealmAuthenticator实现类，通过ModularRealmAuthenticator基本上可以满足大多数需求，也可以自定义认证器</li><li><code>Authorizer</code>即授权器，用户通过认证器认证通过，在访问功能时需要通过授权器判断用户是否有此功能的操作权限</li><li><code>Realm</code>即领域，相当于datasource数据源，securityManager进行安全认证需要通过Realm获取用户权限数据，比如：如果用户身份数据在数据库那么realm就需要从数据库获取用户身份信息</li><li><code>sessionManager</code>即会话管理，shiro框架定义了一套会话管理，它不依赖web容器的session，所以shiro可以使用在非web应用上，也可以将分布式应用的会话集中在一点管理，此特性可使它实现单点登录</li><li><code>CacheManager</code>即缓存管理，将用户权限数据存储在缓存，这样可以提高性能</li><li>CredentialsMatcher即密码管理，shiro提供了一套加密/解密的组件，方便开发。比如提供常用的散列、加/解密等功能。</li></ol><h4 id="shiro配置的核心代码"><a href="#shiro配置的核心代码" class="headerlink" title="shiro配置的核心代码"></a>shiro配置的核心代码</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">//自定义的Realm public class CustomRealm extends AuthorizingRealm {   //授权方法    @Override    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {        SimpleAuthorizationInfo info=new SimpleAuthorizationInfo();        return info;    }//认证方法    @Override    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {        SimpleAuthenticationInfo info=new SimpleAuthenticationInfo("","密码","");        return info;    }}//实现自定义的Realm@Beanpublic CustomRealm customRealm(){    CustomRealm customRealm=new CustomRealm();    return customRealm;}//securityManager安全管理器@Beanpublic SecurityManager securityManager(){    DefaultWebSecurityManager defaultWebSecurityManager=new DefaultWebSecurityManager();    defaultWebSecurityManager.setRealm(customRealm());    return defaultWebSecurityManager;}//配置过滤器，过滤或拦截请求@Beanpublic ShiroFilterFactoryBean shiroFilterFactoryBean(SecurityManager securityManager){    ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();    shiroFilterFactoryBean.setSecurityManager(securityManager);    return shiroFilterFactoryBean;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>shiro的Realm负责认证和授权功能，认证成功之后统一交给SecurityManager进行管理，ShiroFilterFactoryBean则负责总工程，对一些必要的数据进行过滤。</p><p>subject是认证成功之后的主体，可以通过下面代码获取用户信息</p><pre class="line-numbers language-none"><code class="language-none">Subject subject = SecurityUtils.getSubject();UsernamePasswordToken token = (UsernamePasswordToken) subject.getPrincipal();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>sessionManager是shiro的session，用来存储密码认证成功之后的数据</p><p>cacheManager是缓存管理，如果我们自定义缓存可实现此接口，用途是提高性能、扩展性。</p><p>CredentialsMatcher是密码加密策略。</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springBootSummary</title>
      <link href="2021/05/25/springbootsummary/"/>
      <url>2021/05/25/springbootsummary/</url>
      
        <content type="html"><![CDATA[<h4 id="dependencyManagement和dependencies的区别"><a href="#dependencyManagement和dependencies的区别" class="headerlink" title="dependencyManagement和dependencies的区别"></a>dependencyManagement和dependencies的区别</h4><ul><li>dependencyManagement只声明依赖，不实现引入。因此如果子项目需要引入依赖的话需要自己再次声明。目的是为了统一多module之间的version。</li><li>如果子项目的dependencies实现了具体依赖，可不加版本号直接实现父类即dependencyManagement内声明的版本号</li><li>如果子项目的dependencies实现了具体依赖且有版本号则以子项目声明的为准。</li><li>总结类似于java的继承关系。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springSummary</title>
      <link href="2021/05/18/springsummary/"/>
      <url>2021/05/18/springsummary/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是CAP理论"><a href="#什么是CAP理论" class="headerlink" title="什么是CAP理论"></a>什么是CAP理论</h4><p>CAP原则又称CAP定理，指的是在一个分布式系统中，<a href="https://baike.baidu.com/item/%E4%B8%80%E8%87%B4%E6%80%A7/9840083">一致性</a>（Consistency）、<a href="https://baike.baidu.com/item/%E5%8F%AF%E7%94%A8%E6%80%A7/109628">可用性</a>（Availability）、<a href="https://baike.baidu.com/item/%E5%88%86%E5%8C%BA%E5%AE%B9%E9%94%99%E6%80%A7/23734073">分区容错性</a>（Partition tolerance）。</p><p>CAP 原则指的是，这三个<a href="https://baike.baidu.com/item/%E8%A6%81%E7%B4%A0/5261200">要素</a>最多只能同时实现两点，不可能三者兼顾。一般保证容错性，一致性和可用性二选一。</p><p>一致性（C）：在<a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/4905336">分布式系统</a>中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）</p><p>可用性（A）：保证每个请求不管成功或者失败都有响应。</p><p>分区容忍性（P）：系统中任意信息的丢失或失败不会影响系统的继续运作。</p><h4 id="HTTP和RPC的概述"><a href="#HTTP和RPC的概述" class="headerlink" title="HTTP和RPC的概述"></a>HTTP和RPC的概述</h4><p>Http是根据网络定义的，具有标准语义的通用接口，里面的资源都可被解释。对系统的可用性、伸缩性有更好的支持，而RPC是根据语言的API来定义的。</p><p>RPC主要用于公司内部的服务调用，性能消耗低，传输效率高，服务治理方便。HTTP主要用于对外的异构环境，浏览器接口调用，APP接口调用，第三方接口调用等。</p><h4 id="HTTP和RPC的异同"><a href="#HTTP和RPC的异同" class="headerlink" title="HTTP和RPC的异同"></a>HTTP和RPC的异同</h4><ul><li><p>RPC，可以基于TCP协议，也可以基于HTTP协议<br>HTTP，基于HTTP协议</p></li><li><p>RPC，使用自定义的TCP协议，可以让请求报文体积更小，或者使用HTTP2协议，也可以很好的减少报文的体积，提高传输效率<br>HTTP，如果是基于HTTP1.1的协议，请求中会包含很多无用的内容，如果是基于HTTP2.0，那么简单的封装一下是可以作为一个RPC来使用的，这时标准RPC框架更多的是服务治理性能消耗，主要在于序列化和反序列化的耗时</p></li><li><p>RPC，可以基于thrift实现高效的二进制传输<br>HTTP，大部分是通过json来实现的，字节大小和序列化耗时都比thrift要更消耗性能负载均衡</p></li><li><p>RPC，基本都自带了负载均衡策略<br>HTTP，需要配置Nginx，HAProxy来实现<br>服务治理（下游服务新增，重启，下线时如何不影响上游调用者）</p></li><li><p>RPC，能做到自动通知，不影响上游<br>HTTP，需要事先通知，修改Nginx/HAProxy配置        </p></li></ul><h4 id="SpringCloud和Dubbo的区别"><a href="#SpringCloud和Dubbo的区别" class="headerlink" title="SpringCloud和Dubbo的区别"></a>SpringCloud和Dubbo的区别</h4><p>微服务的核心要素在于服务的发现、注册、路由、熔断、降级、分布式配置。</p><p><img src="https://i.loli.net/2021/05/18/izUmO8QhI1M63PF.jpg" alt="微服务区别.jpg"></p><p>综合上述：dubbo属于早期的微服务框架，少了很多组件。而SpringCloud是一种生态，即把微服务架构所需要的组件都整合在一起使用起来更加方面。</p><p>dubbo用的是RPC进行通讯，而SpringCLoud用的是HTTP进行通讯。</p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springCloud</title>
      <link href="2021/05/17/springcloud/"/>
      <url>2021/05/17/springcloud/</url>
      
        <content type="html"><![CDATA[<h4 id="微服务是什么"><a href="#微服务是什么" class="headerlink" title="微服务是什么"></a>微服务是什么</h4><p>对于微服务，其实没有太多统一定义，通常而言对于微服务架构来说它只是一个架构风格，就是把所有的应用分成一个个独立的模块，每个独立的模块能运行在自己的进程中并各模块之间相互协助，相互通信去完成一个具体的业务。</p><h4 id="微服务的优缺点"><a href="#微服务的优缺点" class="headerlink" title="微服务的优缺点"></a>微服务的优缺点</h4><blockquote><p>优点</p></blockquote><ul><li>每个微服务都很小，这样能聚焦一个指定的业务功能或业务需求</li><li>微服务能够被小团队单独开发，这个小团队是2到5人的开发人员组成</li><li>微服务是松耦合的，是有功能意义的服务，无论是在开发阶段或部署阶段都是独立的</li><li>微服务能使用不同的语言开发</li><li>微服务易于被一个开发人员理解，修改和维护，这样小团队能够更关注自己的工作成果。无需通过合作才能体现价值</li><li>微服务允许你利用融合最新技术</li><li>微服务只是业务逻辑的代码，不会和HTML,CSS 或其他界面组件混合</li></ul><blockquote><p>缺点</p></blockquote><ul><li>开发人员要处理系统的复杂性</li><li>随着服务器的增加，运维的工作压力增大</li><li>系统部署之间存在依赖关系</li><li>服务之间通信需要成本</li><li>数据的一致性问题</li><li>性能的监控等</li></ul><h4 id="什么是SpringCloud"><a href="#什么是SpringCloud" class="headerlink" title="什么是SpringCloud"></a>什么是SpringCloud</h4><p>SpringCloud是一种微服务框架，也可以说是一种生态，它把微服务之间所需要解决的问题的组件融合在一起来实现微服务架构通信，数据传输等。</p><h4 id="SpringBoot和SpringCloud的区别"><a href="#SpringBoot和SpringCloud的区别" class="headerlink" title="SpringBoot和SpringCloud的区别"></a>SpringBoot和SpringCloud的区别</h4><ul><li>Sprinboot专注于开发单体微服务项目</li><li>SpringCloud是关注全局的微服务协调框架，它把Springboot开发的单体微服务项目整合在一起，并为各个服务之间提供通信、注册和发现、断路器、路由等</li><li>Springboot可以离开SpringCloud称为一个单体的服务，但是SpringCloud必须依赖于Springboot开发</li><li>Springboot专注为于个体，SpringCloud专注于服务治理</li></ul><h4 id="SpringCloud-Netflix的组件"><a href="#SpringCloud-Netflix的组件" class="headerlink" title="SpringCloud Netflix的组件"></a>SpringCloud Netflix的组件</h4><h5 id="Eureka服务注册及发现"><a href="#Eureka服务注册及发现" class="headerlink" title="Eureka服务注册及发现"></a>Eureka服务注册及发现</h5><blockquote><p>Eureka的两大组件Eureka Server、Eureka Client</p></blockquote><p>Eureka Server是提供节点服务的，每个服务启动之后会在Eureka Server中进行注册，服务节点的信息也可通过界面直观的感受</p><p>Eureka Client是一个java客户端，用来检测服务是否有效，即每30秒Eureka Client会想Eureka Server发送一个心跳，如果Eureka Server在多个周期内没有接收到心跳，Eureka Server则会把该服务从注册中心移除。默认周期为90s。</p><blockquote><p>获取Eureka Serve中的以已注册的信息</p></blockquote><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">@RestController@RequestMapping("/discover")public class DiscoverController {    @Autowired    private DiscoveryClient client;    @GetMapping("/get")    public Object getDiscover(){        //获取所有的服务        List&lt;String&gt; list = client.getServices();        list.forEach(s -&gt; System.out.println(s));//获取某个服务的信息        List&lt;ServiceInstance&gt; provide8081 = client.getInstances("PROVIDE8081");        provide8081.forEach(serviceInstance -&gt; System.out.println(                "host:"+serviceInstance.getHost()+"----------"                +"instance:"+serviceInstance.getInstanceId()+"----------"                +"port:"+serviceInstance.getPort()+"----------"                +"uri:"+serviceInstance.getUri()+"----------"                +"metadata:"+serviceInstance.getMetadata()        ));        return this.client;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>Eureka和zookeeper的区别</p></blockquote><p>Eureka利用的是CAP理论中AP原则，即可用性和容错性。会造成注册中心返回的是几分钟之前的信息。</p><p>zookeeper是利用CAP理论中的CP原则，即一致性和容错性。如果主服务器master宕机之后，会存在一个选举的过程，次选举过程会造成服务不可用。</p><p>两则相比之下，对于大部分业务逻辑来说，高可用性更强于一致性。</p><h5 id="Ribbon负载均衡工具"><a href="#Ribbon负载均衡工具" class="headerlink" title="Ribbon负载均衡工具"></a>Ribbon负载均衡工具</h5><p>ribbon是NetFlix的开源项目，提供负载均衡算法，将各个中间件信息链接在一起，简单的来说就是列出所有的机器，通过某种算法实现负载均衡。</p><blockquote><p>ribbon和nginx的区别</p></blockquote><p>Nginx 是客户端所有请求统一交给 nginx 进行实现负载均衡请求转发，属于服务器端负载均衡。是一种<strong>集中式</strong>的负载均衡器。即请求由 nginx 服务器端进行转发。</p><p>Ribbon 是从 eureka 注册中心服务器端上获取服务注册信息列表，缓存到本地，然后在本地实现轮询负载均衡策略。即在<strong>客户端</strong>实现负载均衡。</p><p>Nginx 适合于<strong>服务器端</strong>实现负载均衡 比如 Tomcat</p><p>Ribbon 适合与在微服务中 RPC 远程调用实现本地服务负载均衡，比如 Dubbo、SpringCloud 中都是采用本地负载均衡。</p><blockquote><p>常用的负载均衡算法    </p></blockquote><ul><li>轮询算法                  默认</li><li>随机算法</li><li>权重算法</li></ul><p>负载均衡算法的实现接口为IRule类，我们可以自定义算法来做负载均衡。</p><blockquote><p>ribbon和feign的区别</p></blockquote><ul><li><p>启动类使用的注解不同，Ribbon用的是@RibbonClient，Feign用的是@EnableFeignClients。</p></li><li><p>服务的指定位置不同，Ribbon是在@RibbonClient注解上声明，Feign则是在定义抽象方法的接口中使用@FeignClient声明。</p></li><li><p>调用方式不同，Ribbon需要自己构建http请求，模拟http请求然后使用RestTemplate发送给其他服务，步骤相当繁琐。</p></li></ul><p>总的来说feign是面向接口编程更符合开发人员的思想，而ribbon+restTemplate对http进行了封装，形成了一套模板化带调用方式。</p><h5 id="hystrix服务熔断"><a href="#hystrix服务熔断" class="headerlink" title="hystrix服务熔断"></a>hystrix服务熔断</h5><blockquote><p>hystrix的简介</p></blockquote><p>Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，已提高分布式系统的弹性。</p><p>“ 断路器 ” 本身是一种开关装置，当某个服务单元发送故障之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个符合预期的、可处理的备选响应（FallBack），而不是长时间的等待或抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。</p><blockquote><p>hystrix的特性</p></blockquote><ul><li><strong>服务熔断：</strong>熔断是应对雪崩效应的一种微服务链路保护机制。当扇出链路的某个微服务不可用或者响应实践太长时，会进行服务的降级，<strong>进而熔断该节点微服务的调用，快速返回错误的响应信息</strong>。当检测到该节点微服务调用响应正常后恢复调用链路。在SpringCloud框架里熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定的阈值，缺省是5秒内20次调用失败就会启动熔断机制。熔断机制的注解是<code>HystrixCommand</code>。</li><li><strong>服务降级：</strong>降级的目的是为了解决整体项目的压力，而牺牲掉某一服务模块而采取的措施。</li><li><strong>服务监控：</strong>可视化页面观察服务的信息</li></ul><p><img src="https://i.loli.net/2021/05/20/Cc4rno9ZPTxitQL.png" alt="服务监控.png"></p><blockquote><p>服务熔断和服务降级的区别</p></blockquote><ul><li><p><strong>触发原因不太一样</strong>，服务熔断一般是某个服务（下游服务）故障引起，而服务降级一般是从整体负荷考虑；</p></li><li><p><strong>管理目标的层次不太一样</strong>，熔断其实是一个框架级的处理，每个微服务都需要（无层级之分），而降级一般需要对业务有层级之分（比如降级一般是从最外围服务开始）</p></li></ul><h5 id="zuul服务网关（已停用）"><a href="#zuul服务网关（已停用）" class="headerlink" title="zuul服务网关（已停用）"></a>zuul服务网关（已停用）</h5><ul><li>提供统一服务入口，微服务对前台透明</li><li>聚合后台服务，节省流量，提升性能</li><li>安全，过滤，流控等API管理功能</li><li>提供统一服务出口，解耦</li></ul><h5 id="SpringCloud-gateway服务网关"><a href="#SpringCloud-gateway服务网关" class="headerlink" title="SpringCloud gateway服务网关"></a>SpringCloud gateway服务网关</h5><h6 id="什么是网关"><a href="#什么是网关" class="headerlink" title="什么是网关"></a>什么是网关</h6><p> 网关是整个微服务API请求的入口，负责拦截所有请求，分发到服务上去。可以实现日志拦截、权限控制、解决跨域问题、限流、熔断、负载均衡，隐藏服务端的ip，黑名单与白名单拦截、授权等，常用的网关有zuul(netflix的，但是已经停更了)和spring cloud gateway (springcloudalibaba)。这里主要讲springcloud gateway，springcloud gateway是一个全新的项目,其基于spring5.0 以及springboot2.0和项目Reactor等技术开发的网关,其主要的目的是为微服务架构提供一种简单有效的API路由管理方式.</p><h6 id="过滤器和网关的对比"><a href="#过滤器和网关的对比" class="headerlink" title="过滤器和网关的对比"></a>过滤器和网关的对比</h6><p>过滤器：对单个服务器的请求进行拦截控制</p><p>网关：对所有的服务器的请求进行拦截控制</p><h6 id="zuul和spring-cloud-gateway的对比"><a href="#zuul和spring-cloud-gateway的对比" class="headerlink" title="zuul和spring cloud gateway的对比"></a>zuul和spring cloud gateway的对比</h6><p>zuul：是Netflix的，是基于servlet实现的，阻塞式的api即基于servlet实现，不支持长连接。</p><p>gateway：是springcloud自己研制的微服务网关，是基于Spring5构建，能够实现响应式非阻塞式的Api，支持长连接</p><h6 id="网关与nginx区别"><a href="#网关与nginx区别" class="headerlink" title="网关与nginx区别"></a>网关与nginx区别</h6><p>相同点：都是可以实现对api接口的拦截，负载均衡、反向代理、请求过滤等，可以实现和网关一样的效果。</p><p>不同点：Nginx采用C语言编写，Gateway属于Java语言编写的， 能够更好让我们使用java语言来实现对请求的处理。</p><p>Nginx 属于服务器端负载均衡器。</p><p>Gateway 属于本地负载均衡器。 </p><h6 id="gateway的组成"><a href="#gateway的组成" class="headerlink" title="gateway的组成"></a>gateway的组成</h6><p>路由 : 网关的基本模块，有ID，目标URI，一组断言和一组过滤器组成</p><p>断言：就是访问该旅游的访问规则，可以用来匹配来自http请求的任何内容，例如headers或者参数</p><p>过滤器：这个就是我们平时说的过滤器，用来过滤一些请求的，gateway有自己默认的过滤器，具体请参考官网，我们也可以自定义过滤器，但是要实现两个接口，ordered和globalfilter</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis</title>
      <link href="2021/05/13/mybatis/"/>
      <url>2021/05/13/mybatis/</url>
      
        <content type="html"><![CDATA[<h4 id="mybatis的中文官网地址"><a href="#mybatis的中文官网地址" class="headerlink" title="mybatis的中文官网地址"></a>mybatis的中文官网地址</h4><p><a href="https://mybatis.org/mybatis-3/zh/">https://mybatis.org/mybatis-3/zh/</a></p><h4 id="mybatis的主要核心部件"><a href="#mybatis的主要核心部件" class="headerlink" title="mybatis的主要核心部件"></a>mybatis的主要核心部件</h4><ul><li>SqlSession    表示和数据库交互的会话，完成必要的数据库增删改查功能</li><li>Executor       执行器，是mybatis的核心，负责sql语句的执行，缓存的查询</li><li>StatementHandler    封装了JDBC Statement操作，负责对JDBC statement的操作，如设置参数，或将结果集转换成List</li><li>ParameterHandler    负责对用户传递的参数转换成JDBC Statement所需要的参数</li><li>ResultSetHandler      负责将jdbc返回的结果集转换成List集合</li><li>TypeHandler              负责将java的数据类型和jdbc数据类型之间的转换</li><li>Configuration             配置mybatis的信息</li><li>SqlSource                    负责用户传递的paramterObject,动态的生成SQL语句，将信息封装到BoundSql中</li><li>BoundSql                    表示动态生成SQL语句以及相应的参数信息</li></ul><h4 id="mybatis-工作流程"><a href="#mybatis-工作流程" class="headerlink" title="mybatis 工作流程"></a>mybatis 工作流程</h4><ol><li>读取mybatis的配置信息，可以是xml的格式，也可以是基于Configuration的对象。</li><li>实例化SqlSessionFactoryBuilder,并通过build配置文件生成SqlSessionFactory实例</li><li>创建一个SqlSession会话，用于实现CRUD。</li><li>创建会话时也会创建一个新的Executor执行器，用于执行SQL或者查询缓存</li><li>执行完成，返回结果并关闭SqlSession会话。</li></ol><h4 id="mybatis的缓存"><a href="#mybatis的缓存" class="headerlink" title="mybatis的缓存"></a>mybatis的缓存</h4><h5 id="一级缓存SqlSession"><a href="#一级缓存SqlSession" class="headerlink" title="一级缓存SqlSession"></a>一级缓存SqlSession</h5><p>mybatis的一级缓存是默认开启的，是SqlSession级别的，即拿到这个链接到结束连接的过程中缓存是有效的。其特点有以下：</p><ul><li>映射语句文件中的所有 select 语句的结果将会被缓存。</li><li>映射语句文件中的所有 insert、update 和 delete 语句会刷新缓存。</li><li>缓存会使用最近最少使用算法（LRU, Least Recently Used）算法来清除不需要的缓存。</li><li>缓存不会定时进行刷新（也就是说，没有刷新间隔）。</li><li>缓存会保存列表或对象（无论查询方法返回哪种）的 1024 个引用。</li><li>缓存会被视为读/写缓存，这意味着获取到的对象并不是共享的，可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。</li></ul><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--可以设置缓存算法，刷新间隔、引用大小、只读表示等 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cache</span>  <span class="token attr-name">eviction</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>FIFO<span class="token punctuation">"</span></span>  <span class="token attr-name">flushInterval</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>60000<span class="token punctuation">"</span></span>  <span class="token attr-name">size</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>512<span class="token punctuation">"</span></span>  <span class="token attr-name">readOnly</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="二级缓存nameSpace"><a href="#二级缓存nameSpace" class="headerlink" title="二级缓存nameSpace"></a>二级缓存nameSpace</h5><p>mybatis的二级缓存也叫全局缓存，由于一级缓存的作用域只在sqlSession中（太窄了），所以诞生了二级缓存，它是基于nameSpace级别的缓存，相当于一个nameSpace对应一个二级缓存。mybatis的二级缓存需要手动开启。</p><p>二级缓存的工作机制：</p><ul><li>当一个会话查询到一条数据时首先会存储到一级缓存中</li><li>如果当前会话关闭，则一级缓存不存在了，则会把一级缓存的信息过渡到二级缓存</li><li>当我们再次在此nameSPace空间内查询时则会从二级缓存中获得内容</li><li>不同的nameSpace有不同的缓存集合</li></ul><h5 id="自定义缓存"><a href="#自定义缓存" class="headerlink" title="自定义缓存"></a>自定义缓存</h5><p>自定义缓存只需实现Cache就可以了！具体可查看官方文档！</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql</title>
      <link href="2021/05/12/mysql/"/>
      <url>2021/05/12/mysql/</url>
      
        <content type="html"><![CDATA[<h4 id="mysql中innodb和myisam"><a href="#mysql中innodb和myisam" class="headerlink" title="mysql中innodb和myisam"></a>mysql中innodb和myisam</h4><table><thead><tr><th></th><th>innodb</th><th>myisam</th></tr></thead><tbody><tr><td>事务</td><td>支持</td><td>不支持</td></tr><tr><td>外键</td><td>支持</td><td>不支持</td></tr><tr><td>全文索引</td><td>不支持</td><td>支持</td></tr><tr><td>锁级别</td><td>行级锁</td><td>表锁</td></tr><tr><td>表空间大小</td><td>较大，约为myisam的2倍</td><td>较小</td></tr><tr><td>索引</td><td>聚簇索引、索引就是数据，顺序存储，因此能缓存索引，也能缓存数据</td><td>非聚簇索引、索引和文件分开，随机存储，只能缓存索引</td></tr><tr><td>备份和恢复</td><td>拷贝数据文件、备份 binlog，或者用 mysqldump，数据量大时很慢</td><td>数据是以文件的形式存储，所以在跨平台的数据转移中会很方便</td></tr></tbody></table><blockquote><p>myisam：节约空间，速度快，如果不注重事务或读取操作较多时选择myisam，其他情况选择innodb。</p></blockquote><blockquote><p>innodb：安全性高、事务处理、多表多用户操作。</p></blockquote><p>mysql的数据库信息都存在data目录下：</p><ul><li>InnoDB基于磁盘的资源是InnoDB表空间数据文件和它的日志文件，InnoDB 表的大小只受限于操作系统文件的大小</li><li>MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型， .frm文件存储表定义，数据文件的扩展名为.MYD， 索引文件的扩展名是.MYI</li></ul><h4 id="mysql的事务ACID"><a href="#mysql的事务ACID" class="headerlink" title="mysql的事务ACID"></a>mysql的事务ACID</h4><ul><li>原子性(A)：事务是最小单位，不可再分</li><li>一致性©：事务要求所有的DML语句操作的时候，必须保证同时成功或者同时失败</li><li>隔离性(I)：事务A和事务B之间具有隔离性</li><li>持久性(D)：是事务的保证，事务终结的标志(内存的数据持久到硬盘文件中)</li></ul><blockquote><p>隔离存在的并发问题</p></blockquote><ul><li>脏读：事务A读取了事务B更新的数据，然后B回滚操作（即未提交），那么A读取到的数据是脏数据</li><li>不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。</li><li>幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</li></ul><blockquote><p>隔离级别的分类</p></blockquote><table><thead><tr><th>事务隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交（read-uncommitted）</td><td>是</td><td>是</td><td>是</td></tr><tr><td>不可重复读（read-committed）</td><td>否</td><td>是</td><td>是</td></tr><tr><td>可重复读（repeatable-read）</td><td>否</td><td>否</td><td>是</td></tr><tr><td>串行化（serializable）</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><p><strong>mysql默认的事务隔离级别为repeatable-read</strong></p><blockquote><p>mysql事务的常用方法</p></blockquote><pre class="line-numbers language-SHELl" data-language="SHELl"><code class="language-SHELl">set autocommit =0   #关闭自动提交set autocommit =1#开启自动提交Start Transaction#开启事务Commit #提交事务Rollback #回滚事务End Transaction#事务结束<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="索引-index"><a href="#索引-index" class="headerlink" title="索引 index"></a>索引 index</h4><h5 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h5><ul><li><strong>InnoDB使用的是B+Tree，每一个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的范围遍历。</strong></li><li><strong>B-Tree通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同，很适合查找范围数据。</strong></li><li><strong>B-Tree可以对&lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN，以及不以通配符开始的LIKE使用索引。</strong></li></ul><h5 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h5><blockquote><p>优点：</p></blockquote><ul><li>建立索引的列可以保证行的唯一性，生成唯一的rowId</li><li> 建立索引可以有效缩短数据的检索时间</li><li> 建立索引可以加快表与表之间的连接</li><li> 为用来排序或者是分组的字段添加索引可以加快分组和排序顺序</li></ul><blockquote><p>缺点：</p></blockquote><ul><li><p>创建索引和维护索引需要时间成本，这个成本随着数据量的增加而加大</p></li><li><p>创建索引和维护索引需要空间成本，每一条索引都要占据数据库的物理存储空间，数据量越大，占用空间也越大（数据表占据的是数据库的数据空间）</p></li><li><p>会降低表的增删改的效率，因为每次增删改索引需要进行动态维护，导致时间变长</p></li></ul><h5 id="常见的索引类型"><a href="#常见的索引类型" class="headerlink" title="常见的索引类型"></a>常见的索引类型</h5><ul><li><p>普通索引      index</p><p><strong>普通索引是最基本的索引，它没有任何限制。</strong></p></li><li><p>唯一索引     uniqe index</p><p><strong>唯一索引和普通索引类似，主要的区别在于，唯一索引限制列的值必须唯一，但允许存在空值（只允许存在一条空值）。</strong></p></li><li><p>主键索引     primary key</p><p><strong>主键索引是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引</strong></p></li><li><p>组合索引     index</p><p><strong>复合索引是在多个字段上创建的索引。复合索引遵守“最左前缀”原则，即在查询条件中使用了复合索引的第一个字段，索引才会被使用。因此，在复合索引中索引列的顺序至关重要。</strong></p></li><li><p>全文索引    fullText</p><p><strong>FULLTEXT 索引在 MySQL 5.6 版本之后支持 InnoDB，而之前的版本只支持 MyISAM 表。一般用于模糊查询</strong></p></li></ul><h5 id="索引失效场景"><a href="#索引失效场景" class="headerlink" title="索引失效场景"></a>索引失效场景</h5><ul><li>在where后使用or，导致索引失效（尽量少用or）</li><li>使用like ，like查询是以%开头</li><li>复合索引遵守“最左前缀”原则，即在查询条件中使用了复合索引的第一个字段，索引才会被使用</li><li>如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引</li><li>在索引字段上使用not，&lt;&gt;，!=。不等于操作符是永远不会用到索引的，因此对它的处理只会产生全表扫描</li><li>DATE_FORMAT()格式化时间，格式化后的时间再去比较，可能会导致索引失效。</li><li>is null， is not null也无法使用索引</li></ul><h5 id="什么情况下不适合建立索引"><a href="#什么情况下不适合建立索引" class="headerlink" title="什么情况下不适合建立索引"></a>什么情况下不适合建立索引</h5><ul><li>小数据量的表不超过10万</li><li>数据变动强的字段不建立索引</li><li>大字段不建立索引</li><li>有枚举类型的字段不建议索引，或者建立组合索引</li></ul>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot</title>
      <link href="2021/05/10/springboot/"/>
      <url>2021/05/10/springboot/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm</title>
      <link href="2021/05/10/jvm/"/>
      <url>2021/05/10/jvm/</url>
      
        <content type="html"><![CDATA[<h4 id="jvm（hotSpot）的体系结构"><a href="#jvm（hotSpot）的体系结构" class="headerlink" title="jvm（hotSpot）的体系结构"></a>jvm（hotSpot）的体系结构</h4><p><img src="https://i.loli.net/2021/05/10/pZ1nxflVTFqdOaC.png" alt="jvm体系结构.png"></p><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><h5 id="类加载器的种类"><a href="#类加载器的种类" class="headerlink" title="类加载器的种类"></a>类加载器的种类</h5><ul><li>启动类根加载器                      lib/rb.jar</li><li>扩展类加载器                          lib/exc/*.jar</li><li>应用程序加载器                     classpath</li></ul><h5 id="类加载器概念"><a href="#类加载器概念" class="headerlink" title="类加载器概念"></a>类加载器概念</h5><p>我们编写号类文件之后，通过类加载器class loader加载成class文件，class文件也可通过getClassload转换到class loader里，如果我们需要实例化，则一般常用new的方式实例化成具体的对象，对象也可通过getClass得到想要的class文件。其中class是抽象的，对象是具体的实现。每个对象都是一个实例化。</p><h4 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><p>双亲委派模型是为了保证Java核心库的类型安全。所有Java应用都至少需要引用java.lang.Object类，在运行时这个类需要被加载到Java虚拟机中。如果该加载过程由自定义类加载器来完成，可能就会存在多个版本的java.lang.Object类，而且这些类之间是不兼容的。</p><p>通过双亲委派模型，对于Java核心库的类的加载工作由启动类加载器来统一完成，保证了Java应用所使用的都是同一个版本的Java核心库的类，是互相兼容的。</p><h5 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h5><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的加载器都是如此，因此所有的类加载请求都会传给顶层的启动类加载器，只有当父加载器反馈自己无法完成该加载请求（该加载器的搜索范围中没有找到对应的类）时，子加载器才会尝试自己去加载。三种加载器的子父关系：启动类根加载器/扩展类加载器 /应用程序加载器      </p><h4 id="native关键字"><a href="#native关键字" class="headerlink" title="native关键字"></a>native关键字</h4><ul><li>凡是用native修饰的方法，说明java程序的作用范围达不到，需要调用底层的C语言</li><li>会进入本地方法栈调用本地方法接口JNI</li><li>JNI的作用是扩展java的应用，融合不同的语言为java使用</li><li>存储native方法的区域叫做native Method Stack即本地方法栈</li><li>在最终执行的时候会加载到本地方法库通过JNI进行调用</li></ul><h4 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h4><ul><li>它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域</li><li>在jvm规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致</li><li>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的java方法的JVM指令地址；或者，如果在执行native方法，则是未指定值（undefined）,因为程序计数器不负责本地方法栈。</li><li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成</li><li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令</li><li>它是唯一一个在java虚拟机规范中没有规定任何OOM（Out Of Memery）情况的区域,而且没有垃圾回收</li></ul><h4 id="方法区、元空间"><a href="#方法区、元空间" class="headerlink" title="方法区、元空间"></a>方法区、元空间</h4><ul><li>方法区（Method Area）与 Java 堆一样，是所有线程共享的内存区域。</li><li>JDK7 之前（永久代）用于存储已被虚拟机加载的类信息、常量、字符串常量、类静态变量、即时编译器编译后的代码等。即static、final、Class、常量池。</li><li>JDK8 彻底将永久代移除出 HotSpot JVM，将其原有的数据迁移至 Java Heap 或 Native Heap，取代它的是另一个内存区域被称为元空间(Metaspace）</li></ul><p>元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。</p><h4 id="栈stack"><a href="#栈stack" class="headerlink" title="栈stack"></a>栈stack</h4><ul><li>栈内存主管程序的运行和线程同步</li><li>线程结束，栈内存也就释放不存在垃圾回收机制</li><li>栈存储的有8大基本数据类型+对象引用+实例方法</li><li>栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活。</li><li>如果栈满则会抛出stackOverFlowError错误</li></ul><h4 id="堆heap"><a href="#堆heap" class="headerlink" title="堆heap"></a>堆heap</h4><ul><li><p>一个jvm只有一个堆内存，堆内存的大小是可以调节的。</p></li><li><p>类加载器读取类文件之后，会把类、方法、常亮放入堆中，保存我们引用类型的真实对象</p></li><li><p>堆分为：新生区（伊甸园区eden、from、to）、老年区</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">-Xms1024m -Xmx1024m -XX:+PrintGCDetails//自定义堆的内存空间为1024m，其中xms时初始化内存大小，xmx时最大分配内存· //新生代总内存   305664K,PSYoungGen      total 305664K, used 47186K [0x00000000eab00000, 0x0000000100000000, 0x0000000100000000)     //伊甸园区 使用率                                 eden space 262144K, 18% used [0x00000000eab00000,0x00000000ed914aa0,0x00000000fab00000)  //幸村一区、幸存0区的内次使用率                               from space 43520K, 0% used [0x00000000fd580000,0x00000000fd580000,0x0000000100000000)  to   space 43520K, 0% used [0x00000000fab00000,0x00000000fab00000,0x00000000fd580000)  //养老区的内存总数                             ParOldGen       total 699392K, used 0K [0x00000000c0000000, 0x00000000eab00000, 0x00000000eab00000)  //养老区内存使用率                                         object space 699392K, 0% used [0x00000000c0000000,0x00000000c0000000,0x00000000eab00000)  //元空间的 的逻辑内存，实际上存储在本地内存中                              Metaspace       used 3396K, capacity 4500K, committed 4864K, reserved 1056768K  class space    used 369K, capacity 388K, committed 512K, reserved 1048576K                                   -Xms16m -Xmx16m -XX:+PrintGCDetails      //自定义空间为16m，可以看出明显的差别                         PSYoungGen      total 4608K, used 851K [0x00000000ffb00000, 0x0000000100000000, 0x0000000100000000)  eden space 4096K, 8% used [0x00000000ffb00000,0x00000000ffb586f0,0x00000000fff00000)  from space 512K, 97% used [0x00000000fff00000,0x00000000fff7c7a0,0x00000000fff80000)  to   space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000) ParOldGen       total 11264K, used 786K [0x00000000ff000000, 0x00000000ffb00000, 0x00000000ffb00000)  object space 11264K, 6% used [0x00000000ff000000,0x00000000ff0c4a28,0x00000000ffb00000) Metaspace       used 3447K, capacity 4500K, committed 4864K, reserved 1056768K  class space    used 370K, capacity 388K, committed 512K, reserved 1048576K                                                                 //当运行的对象过多时会进行轻量级的GC清理和重量级的GC清理，如果重量级的GC清理也不成功，则会提示 java.lang.OutOfMemoryError: Java heap space内存溢出[GC (Allocation Failure) --[PSYoungGen: 3072K-&gt;3072K(3584K)] 14077K-&gt;14333K(14848K), 0.0025489 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]                                 [Full GC (Ergonomics) [PSYoungGen: 3072K-&gt;3071K(3584K)] [ParOldGen: 11208K-&gt;11208K(11264K)] 14280K-&gt;14279K(14848K), [Metaspace: 36735K-&gt;36735K(1083392K)], 0.0202492 secs] [Times: user=0.01 sys=0.00, real=0.02 secs] 2021-05-11 21:38:46.349 ERROR 8084 --- [  restartedMain] com.alibaba.druid.pool.DruidDataSource   : {dataSource-1} init errorjava.lang.OutOfMemoryError: Java heap space<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="垃圾回收GC"><a href="#垃圾回收GC" class="headerlink" title="垃圾回收GC"></a>垃圾回收GC</h4><p><strong>1、分代收集算法：</strong> 堆中的每个对象都会添加一个引用计数器。每当一个地方引用这个对象时，计数器值 <code>+1</code>；当引用失效时，计数器值 <code>-1</code>。任何时刻计数值为 <code>0</code> 的对象就是不可能再被使用的。这种算法无法解决<strong>对象之间相互引用的情况</strong>。</p><p><strong>2、复制算法：</strong>将可用内存分为两块，每次只用其中一块，当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已经使用过的内存空间一次性清理掉。这种算法适用于对象存活率低的场景，比如新生代。</p><p><strong>3、标记、清除、压缩算法：</strong>首先垃圾回收器此时会找出哪些内存在使用中，那些未使用，接着删除未使用对象并内存分配器会保留指向可用内存的引用，以供分配新对象，最后为了提升性能，删除了未引用对象后，还可以将剩下的已引用对象放在一起（压缩），这样就能更简单快捷地分配新对象了。一般可以设置N次标记清除之后，压缩一次。其中N最多15次。</p><p><strong>4、分代收集算法：</strong></p><ul><li>新生代的目标就是尽可能快速的收集掉那些生命周期短的对象，一般情况下，所有新生成的对象首先都是放在新生代的。新生代内存按照 8:1:1 的比例分为一个eden区和两个survivor(survivor0，survivor1)区，大部分对象在Eden区中生成。在进行垃圾回收时，先将eden区存活对象复制到survivor0区，然后清空eden区，当这个survivor0区也满了时，则将eden区和survivor0区存活对象复制到survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后交换survivor0区和survivor1区的角色（即下次垃圾回收时会扫描Eden区和survivor1区），即保持survivor0区为空，如此往复。特别地，当survivor1区也不足以存放eden区和survivor0区的存活对象时，就将存活对象直接存放到老年代。如果老年代也满了，就会触发一次FullGC，也就是新生代、老年代都进行回收。注意，新生代发生的GC也叫做MinorGC，MinorGC发生频率比较高，不一定等 Eden区满了才触发。</li><li>老年代存放的都是一些生命周期较长的对象，就像上面所叙述的那样，在新生代中经历了N次垃圾回收后仍然存活的对象就会被放到老年代中。此外，老年代的内存也比新生代大很多(大概比例是1:2)，当老年代满时会触发Major GC(Full GC)，老年代对象存活时间比较长，因此FullGC发生的频率比较低。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程</title>
      <link href="2021/05/05/duo-xian-cheng/"/>
      <url>2021/05/05/duo-xian-cheng/</url>
      
        <content type="html"><![CDATA[<h4 id="实现线程的方式有哪些"><a href="#实现线程的方式有哪些" class="headerlink" title="实现线程的方式有哪些"></a>实现线程的方式有哪些</h4><ul><li>实现Runnable接口</li><li>继承Thread类</li><li>实现Callable接口</li></ul><h5 id="继承Thread类的调用过程"><a href="#继承Thread类的调用过程" class="headerlink" title="继承Thread类的调用过程"></a>继承Thread类的调用过程</h5><ul><li>书写一个类继承Thread类让其具有多线程的功能，并实现run（）方法</li><li>启动线程，该类调用start（）方法进行调用</li></ul><h5 id="实现runnable接口的调用过程"><a href="#实现runnable接口的调用过程" class="headerlink" title="实现runnable接口的调用过程"></a>实现runnable接口的调用过程</h5><ul><li>书写一个类实现Runnable接口让其具有多线程的功能，并实现run()方法</li><li>启动线程，new Thread(类的对象)调用start()方法。</li></ul><h5 id="实现Callable接口的调用过程"><a href="#实现Callable接口的调用过程" class="headerlink" title="实现Callable接口的调用过程"></a>实现Callable接口的调用过程</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">//书写一个类实现Callable接口让其具有多线程的功能，并实现call（）方法，且需要自定义一个返回值类型//实例化对象CallableTest callableTest = new CallableTest();//创建一个线程池 1代表之启动一个线程ExecutorService executorService = Executors.newFixedThreadPool(1);//执行Future&lt;Boolean&gt; future = executorService.submit(callableTest);//获取结果boolean f1 = future.get();//关闭服务executorService.shutdown();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>线程启动之后，不一定立即执行，而是等待CPU调度，即多个线程执行时结果顺序是不一致的。推荐使用runnable接口，由于java的单继承概念，如果继承Thread类灵活性会很差。</p><p>实现callable接口相对于其他两个优点是有返回值且可以抛出异常，缺点是实现比较麻烦。</p><h4 id="线程中常用的方法"><a href="#线程中常用的方法" class="headerlink" title="线程中常用的方法"></a>线程中常用的方法</h4><h5 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h5><p>停止线程的方式不建议使用stop等方法，而是建立一个标志位，如果标志位不成立，则停止该线程，即用手动控制，避免死锁。</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">public class TestStop implements Runnable{    //设置一个标志位标识是否停止    private boolean flag =true;        @Override    public void run() {        int i=0;        while (flag){            System.out.println("new Thread"+i);        }    }    //如果运行此方法标识停止    private void stop(){       this.flag =false;    }    public static void main(String[] args) {        TestStop testStop = new TestStop();        new Thread(testStop).start();        for (int i = 0; i &lt; 500; i++) {            System.out.println("main"+i);            if(i==450){                testStop.stop();                System.out.println("线程停止了");            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="线程休眠sleep"><a href="#线程休眠sleep" class="headerlink" title="线程休眠sleep"></a>线程休眠sleep</h5><ul><li>sleep休眠的时间指的是毫秒数</li><li>sleep的时间达到后线程进入就绪状态</li><li>sleep一般应用于倒计时、网络延迟等</li><li>每个对象都会有一个锁，sleep不会释放锁</li></ul><h5 id="线程礼让yield"><a href="#线程礼让yield" class="headerlink" title="线程礼让yield"></a>线程礼让yield</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">//正常流程a线程开始执行、a线程结束执行、b线程开始执行、b线程结束执行//Thread.yield()可重新让cpu调度，即有可能礼让成功，有可能礼让失败public class YieldTest implements Runnable{    @Override    public void run() {        System.out.println(Thread.currentThread().getName()+"线程开始执行");        //礼让线程        Thread.yield();        System.out.println(Thread.currentThread().getName()+"线程结束执行");    }    public static void main(String[] args) {        YieldTest yieldTest = new YieldTest();        new Thread(yieldTest,"a").start();        new Thread(yieldTest,"b").start();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="线程插队join"><a href="#线程插队join" class="headerlink" title="线程插队join"></a>线程插队join</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">//即线程在执行过程中如果添加Thread.join，则需强制执行该对象所在的线程public class JoinTest implements Runnable {    @Override    public void run() {        for (int i = 0; i &lt; 1000; i++) {            System.out.println("vip"+i);        }    }    public static void main(String[] args) throws InterruptedException {        JoinTest joinTest = new JoinTest();        Thread thread  =   new Thread(joinTest);        thread.start();        for (int i = 0; i &lt; 500; i++) {            if(i==200){                thread.join();            }            System.out.println("main"+i);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="线程状态观测"><a href="#线程状态观测" class="headerlink" title="线程状态观测"></a>线程状态观测</h5><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">//锁定状态Thread.State blocked1 = Thread.State.BLOCKED;//新生状态  运行start方法Thread.State blocked2 =Thread.State.NEW;//运行状态运行run方法Thread.State blocked3 =Thread.State.RUNNABLE;//死亡状态  最后结束时的状态Thread.State blocked4 =Thread.State.TERMINATED;//睡眠状态 sleep方法Thread.State blocked5 =Thread.State.TIMED_WAITING;//等待状态 wait方法Thread.State blocked6 =Thread.State.WAITING;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">//设置线程的优先级t3.setPriority（数值），最小为1，最大为10，超过抛出异常，优先级高的不一定最先执行，但大概率会优先执行public class PriorityTest implements Runnable{    @Override    public void run() {        System.out.println(Thread.currentThread().getName()+"-&lt;&lt;"+Thread.currentThread().getPriority());    }    public static void main(String[] args) {        System.out.println(Thread.currentThread().getName()+"-&lt;&lt;"+Thread.currentThread().getPriority());        PriorityTest priorityTest = new PriorityTest();        Thread t1 = new Thread(priorityTest);        Thread t2 = new Thread(priorityTest);        Thread t3 = new Thread(priorityTest);        Thread t4 = new Thread(priorityTest);        Thread t5 = new Thread(priorityTest);        t1.start();        t2.setPriority(2);        t2.start();        t3.setPriority(Thread.MAX_PRIORITY);        t3.start();        t4.setPriority(9);        t4.start();        t5.setPriority(Thread.MIN_PRIORITY);        t5.start();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="线程守护"><a href="#线程守护" class="headerlink" title="线程守护"></a>线程守护</h5><ul><li>线程分为守护线程和用户线程，我们平常用的都是用户线程</li><li>虚拟机必须确保用户线程执行完毕</li><li>虚拟机不必等待守护线程执行完毕</li><li>守护线程一般用作操作日志、垃圾回收、监控内存等</li><li>设置线程为守护线程的方式是Thread.setDaemon(true);</li></ul><pre class="line-numbers language-none"><code class="language-none">//设置线程的优先级t3.setPriority（数值），最小为1，最大为10，超过抛出异常，优先级高的不一定最先执行，但大概率会优先执行public class PriorityTest implements Runnable{    @Override    public void run() {        System.out.println(Thread.currentThread().getName()+"-&lt;&lt;"+Thread.currentThread().getPriority());    }    public static void main(String[] args) {        System.out.println(Thread.currentThread().getName()+"-&lt;&lt;"+Thread.currentThread().getPriority());        PriorityTest priorityTest = new PriorityTest();        Thread t1 = new Thread(priorityTest);        Thread t2 = new Thread(priorityTest);        Thread t3 = new Thread(priorityTest);        Thread t4 = new Thread(priorityTest);        Thread t5 = new Thread(priorityTest);        t1.start();        t2.setPriority(2);        t2.start();        t3.setPriority(Thread.MAX_PRIORITY);        t3.start();        t4.setPriority(9);        t4.start();        t5.setPriority(Thread.MIN_PRIORITY);        t5.start();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="线程同步锁synchronized"><a href="#线程同步锁synchronized" class="headerlink" title="线程同步锁synchronized"></a>线程同步锁synchronized</h5><ul><li>锁的对象是变换的对象，即this信息。</li><li>用synchronized修饰的方法或者代码块表示同步信息，即一个线程进入某个方法之后，其他线程只能等待当前线程结束才能访问</li><li>上锁的功能都是修改的功能</li><li>由于每个线程都需要上锁，造成资源浪费</li><li>如果线程内部存在调用且也是同步方法时可能会造成死锁</li></ul><h5 id="显式锁lock"><a href="#显式锁lock" class="headerlink" title="显式锁lock"></a>显式锁lock</h5><ul><li>lock是显式锁即需要加锁和解锁的过程，synchronized是隐式锁即出了锁定域自动解锁</li><li>lock只能锁定代码块，synchronized能锁定方法和代码块</li><li>lock锁的性能更好</li></ul><h5 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h5><h6 id="死锁产生的4个必要条件"><a href="#死锁产生的4个必要条件" class="headerlink" title="死锁产生的4个必要条件"></a>死锁产生的4个必要条件</h6><ul><li>互斥条件：一个资源每次只能被一个进程使用</li><li>请求和保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放</li><li>不可剥夺条件：进程已获得的资源，在未使用完成，不能强行剥夺</li><li>循环等待条件：若干进程之间形成一种头尾相接的循环等待关系</li></ul>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注解</title>
      <link href="2021/05/03/zhu-jie/"/>
      <url>2021/05/03/zhu-jie/</url>
      
        <content type="html"><![CDATA[<h4 id="Qualifier-如果项目中自定义的注解跟底层一样，则可使用次注解来标识项目中运用。"><a href="#Qualifier-如果项目中自定义的注解跟底层一样，则可使用次注解来标识项目中运用。" class="headerlink" title="@Qualifier    如果项目中自定义的注解跟底层一样，则可使用次注解来标识项目中运用。"></a>@Qualifier    如果项目中自定义的注解跟底层一样，则可使用次注解来标识项目中运用。</h4>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>精句</title>
      <link href="2021/05/03/jing-ju/"/>
      <url>2021/05/03/jing-ju/</url>
      
        <content type="html"><![CDATA[<h4 id="知其然并知其所以然，授人以鱼不如授人以渔！学习需慢慢来，不能太过急躁。"><a href="#知其然并知其所以然，授人以鱼不如授人以渔！学习需慢慢来，不能太过急躁。" class="headerlink" title="知其然并知其所以然，授人以鱼不如授人以渔！学习需慢慢来，不能太过急躁。"></a>知其然并知其所以然，授人以鱼不如授人以渔！学习需慢慢来，不能太过急躁。</h4>]]></content>
      
      
      <categories>
          
          <category> 感悟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis进阶</title>
      <link href="2021/05/03/redis-shi-wu/"/>
      <url>2021/05/03/redis-shi-wu/</url>
      
        <content type="html"><![CDATA[<h3 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h3><p>Redis事务本质是一种命令的集合，一个事务中的所有命令都会被序列化，且按照顺序执行！</p><p>Redis事务没有隔离级别的概念，即没有mysql的脏读等事情发生</p><p>Redis的单条命令是具有原子性的，多条命令不具有原子性</p><ul><li>开启事务（multi）</li><li>命令入队（。。。。。）</li><li>执行事务（exec）</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#一个完整的事务执行过程127.0.0.1:6379&gt; MULTI#开启一个事务OK127.0.0.1:6379(TX)&gt; set k1 v1#在事务中执行操作QUEUED127.0.0.1:6379(TX)&gt; set k2 v2 QUEUED127.0.0.1:6379(TX)&gt; get k2QUEUED127.0.0.1:6379(TX)&gt; exec#执行事务1) OK2) OK3) "v2"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-BASH" data-language="BASH"><code class="language-BASH">#如果在事务中做了取消操作，则所有操作都不会执行，此时具有原子性127.0.0.1:6379&gt; MULTI#开启事务OK127.0.0.1:6379(TX)&gt; set k1 v1 #执行操作QUEUED127.0.0.1:6379(TX)&gt; set k2 v2QUEUED127.0.0.1:6379(TX)&gt; DISCARD#取消事务OK127.0.0.1:6379&gt; get k1(nil)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#编译时异常，即系统检测出的异常，此时具有原子性27.0.0.1:6379&gt; MULTI#开启事务OK127.0.0.1:6379(TX)&gt; set k1 v1#执行正确操作QUEUED127.0.0.1:6379(TX)&gt; set k2 v2QUEUED127.0.0.1:6379(TX)&gt; getset k1#执行错误操作(error) ERR wrong number of arguments for 'getset' command127.0.0.1:6379(TX)&gt; get k2QUEUED127.0.0.1:6379(TX)&gt; exec #执行事务时提示所有操作都未成功(error) EXECABORT Transaction discarded because of previous errors.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#运行时异常，即系统运行过程中才检测到异常，此时不具有原子性127.0.0.1:6379&gt; MULTI#开启事务OK127.0.0.1:6379(TX)&gt; set k1 v1#执行正确操作QUEUED127.0.0.1:6379(TX)&gt; set k2 v2QUEUED127.0.0.1:6379(TX)&gt; incr k1#执行错误操作，向String中自增QUEUED127.0.0.1:6379(TX)&gt; get k2QUEUED127.0.0.1:6379(TX)&gt; exec#执行事务，则提示第三步错误，其他都正常运行1) OK2) OK3) (error) ERR value is not an integer or out of range4) "v2"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="redis的监控"><a href="#redis的监控" class="headerlink" title="redis的监控"></a>redis的监控</h3><blockquote><p>乐观锁是什么</p></blockquote><p>无论什么时候都认为不会出现问题，所以不用上锁，更新数据的适合判断一下是否有人修改过数据即可。</p><blockquote><p>悲观锁是什么</p></blockquote><p>无论什么时候都认为会出现问题，所以执行过程中都会增加一个锁。效率过慢</p><blockquote><p>redis的乐观锁用watch进行表示</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#一个正常的操作127.0.0.1:6379&gt; set money 100OK127.0.0.1:6379&gt; set out 0OK127.0.0.1:6379&gt; watch money#开启监控OK127.0.0.1:6379&gt; MULTIOK127.0.0.1:6379(TX)&gt; decrby money 60#减少60QUEUED127.0.0.1:6379(TX)&gt; INCRBY out 60#增加60QUEUED127.0.0.1:6379(TX)&gt; exec1) (integer) 402) (integer) 60<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-BASH" data-language="BASH"><code class="language-BASH">#一个错误信息的执行过程#线程1127.0.0.1:6379&gt; WATCH money#监控moneyOK127.0.0.1:6379&gt; MULTIOK127.0.0.1:6379(TX)&gt; DECRby money 10#对money进行操作QUEUED127.0.0.1:6379(TX)&gt; INCRBY out 10QUEUED127.0.0.1:6379(TX)&gt; exec #执行事务不成功(nil)#线程2127.0.0.1:6379&gt; set money 1000#线程2修改了监控的moneyOK127.0.0.1:6379&gt; UNWATCH#取消所有监控信息OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="设置redis的密码"><a href="#设置redis的密码" class="headerlink" title="设置redis的密码"></a>设置redis的密码</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; config set requirepass 123456#设置redis的密码OK127.0.0.1:6379&gt; exitroot@5a78b143c447:/data# redis-cli127.0.0.1:6379&gt; ping(error) NOAUTH Authentication required.127.0.0.1:6379&gt; auth 123456#密码认证OK127.0.0.1:6379&gt; pingPONG<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="RDB（redis-database）持久化"><a href="#RDB（redis-database）持久化" class="headerlink" title="RDB（redis database）持久化"></a>RDB（redis database）持久化</h3><blockquote><p>触发机制产生dump.rdb文件</p></blockquote><ul><li>配置文件中设置的save规则如果满足条件即可触发，例如save 900 1 （如果900s内存在一次更改或添加操作）</li><li>执行flushAll命令，也会触发持久化配置产生rdb文件</li><li>退出redis也可产生rdb文件。</li></ul><blockquote><p>如何恢复rdb文件</p></blockquote><p>找到rdb文件需识别的目录，启动redis的适合会自动加载</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; config get dir#输出此命令可查看rdb文件所在目录1) "dir"2) "/etc"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>优点</strong></p><ol><li>适合大规模的数据恢复</li><li>对数据的完整性不高</li></ol><p><strong>缺点</strong></p><ol><li>需要一定的时间间隔进程操作，如果redis意外down了，则最后一次修改的数据就持久化不成功。</li><li>fork进行的时候，暂用一定的内存空间。</li></ol><h3 id="AOF（append-only-file）持久化"><a href="#AOF（append-only-file）持久化" class="headerlink" title="AOF（append only file）持久化"></a>AOF（append only file）持久化</h3><p>由于redis的默认持久化方式为RDB，需修改配置文件中的APPENDONLY 为YES则表示AOF持久化</p><p>AOF持久化产生的文件名为appendOnly.aof文件</p><p>AOF持久化的方式有三种：</p><ul><li>appendfSync    always        每次修改都会sync，比较消耗性能</li><li>appendfSync    everysec    每秒执行一次sync，可能会丢失这1s的数据，默认的方式</li><li>appendfSync    no               不执行sync，操作系统回自己同步数据，速度最快</li></ul><p><strong>优缺点</strong></p><ol><li>相对于rdb的方式，数据的完整性更好</li><li>相对于rdb的方式，aof的文件远大于rdb文件，修复速度也比rdb慢</li><li>运行效率也比rdb慢</li></ol><h3 id="Redis消息队列"><a href="#Redis消息队列" class="headerlink" title="Redis消息队列"></a>Redis消息队列</h3><pre class="line-numbers language-BASH" data-language="BASH"><code class="language-BASH"># 消息接收者127.0.0.1:6379&gt; SUBSCRIBE wei #设置接收数据的频道weiReading messages... (press Ctrl-C to quit)1) "subscribe"2) "wei"3) (integer) 11) "message"#下三步则为接收到数据信息2) "wei"3) "123232"#消息发送者127.0.0.1:6379&gt; PUBLISH wei 123232#发送到wei频道信息(integer) 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Redis的主从复制"><a href="#Redis的主从复制" class="headerlink" title="Redis的主从复制"></a>Redis的主从复制</h3><blockquote><p>主从复制的概念</p></blockquote><p>主从复制试讲一台Redis服务器复制到其他服务器，前者称为主节点（master/leader),后者称为从节点（slave/follower）;数据的复制是单向的，只能从主节点到从节点，其中master为主，slave为从。</p><blockquote><p>主从复制的作用是什么</p></blockquote><ol><li>数据冗余：实现了数据的热备份，是持久化之外的一种数据冗余模式</li><li>故障恢复：当主节点出现问题时，可以有从节点提供服务，实现快速的故障恢复，实际上是一种服务的冗余。</li><li>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，从节点提供读服务，分担服务器负载。</li><li>高可用：除了上述作用外，主从复制还采用了哨兵和集群模式，实现了redis的高可用。</li></ol><pre class="line-numbers language-BASH" data-language="BASH"><code class="language-BASH">127.0.0.1:6379&gt; INFO replication#查看当前redis的机器信息# Replicationrole:master#角色信息（主机）connected_slaves:0#从机数量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">127.0.0.1:6379&gt; info replication# Replicationrole:master#主机标识connected_slaves:1#链接的从机数目slave0:ip=47.101.169.95,port=6379,state=online,offset=14,lag=0#从机的基本信息127.0.0.1:6379&gt; info replication# Replicationrole:slave#从机master_host:47.100.3.247#连接到的主机信息master_port:6379<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><blockquote><p>哨兵模式的概念</p></blockquote><p>主从切换技术的方法是：当主服务器down后，需要手动选择一台服务器作为主服务器，需要人工干预，费时费力，并且还会造成一段时间的不可用，因此产生一个全新的自动化模式sentinel来解决这个问题。如果主机down，从机则会根据一定的算法选择从机做为主机。如果主机在连接则只能作为从机，主机还是原来推举出来的。</p><blockquote><p>哨兵的作用</p></blockquote><ul><li>通过发送命令，检测主服务器和从服务器的运行状态</li><li>当master宕机，会自动将slave转换为master，然后通知其他服务器，修改配置文件，让他们切换主机。</li><li>哨兵也可能存在down的可能，因此会布置多个哨兵互相监控。</li></ul><blockquote><p>哨兵配置</p></blockquote><p>1、配置sentinel.conf</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># sentinel monitor myredis host port  1   sentinel monitor myredis 47.100.3.247 6379  1#1表示主机挂了，slave投票谁最多谁成为主机#具体的配置后续再了解，目前只配置最基础的配置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>2、启动哨兵</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">redis-sentinel sentinel.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>优点：</strong></p><ol><li>哨兵集群，基于主从复制模式，所有的主从配置有点都拥有</li><li>主从可以切换，故障可以转移，系统的可用性会更好</li><li>哨兵模式是主从模式的升级，手动改为自动更加的健壮</li></ol><p><strong>缺点：</strong></p><ol><li>哨兵模式的扩容非常麻烦</li><li>配置相对来说比较麻烦</li></ol>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis特殊数据类型</title>
      <link href="2021/05/03/redis-te-shu-shu-ju-lei-xing/"/>
      <url>2021/05/03/redis-te-shu-shu-ju-lei-xing/</url>
      
        <content type="html"><![CDATA[<h3 id="geospatial地理位置"><a href="#geospatial地理位置" class="headerlink" title="geospatial地理位置"></a>geospatial地理位置</h3><p>应用场景: 朋友圈定位、附近的距离、地理位置的计算</p><p>常用命令：</p><p>geoadd 添加经纬度信息</p><p>geopos 查询经纬度信息</p><p>geodist 查询两个位置直接的直线距离</p><p>geoRadius    查询某个坐标下（经度、维度）的所有位置信息</p><p>georadiusBymember    查询某个坐标下（集合内的数据）的位置信息</p><p>geohash    返回某个城市的一维数据，11位</p><pre class="line-numbers language-BASH" data-language="BASH"><code class="language-BASH">#顺序为key、经度、维度、城市#有效的经度从-180度到180度。#有效的纬度从-85.05112878度到85.05112878度。#如果超过则会提示如下错误127.0.0.1:6379&gt; GEOADD china:city 116.405289 39.904987 beijing#添加地理位置信息(integer) 1127.0.0.1:6379&gt; GEOADD china:city 117.190186 39.125595 tianqing 114.502464  38.045475 shijiazhuang 126.642464 45.756966 haerbing 121.472641 31.231707 shanghai(integer) 4127.0.0.1:6379&gt; GEOADD china:city 113.374375 23.368923 guangzhou(integer) 1127.0.0.1:6379&gt; keys *1) "china:city"127.0.0.1:6379&gt; GEOADD china:city    23.368923  113.374375  guangzhou#位置信息添加错误提示(error) ERR invalid longitude,latitude pair 23.368923,113.374375127.0.0.1:6379&gt; GEOPOS china:city beijing tianqing#查看当前经纬度的值1) 1) "116.40528827905654907"   2) "39.90498588819134085"2) 1) "117.19018846750259399"   2) "39.12559461779084558"#获取两人之间的距离127.0.0.1:6379&gt; GEODIST china:city beijing tianqing km#获取两地之间的距离，单位为km"109.7753"#查询附近的人key、经度、维度、半径、单位、直接距离、总数127.0.0.1:6379&gt; GEORADIUS china:city 100 30 1000 km withdist count 3#查询某个经纬度内半径为1000km的地点3个位置(empty array)#查询以某个集合内的位置作为基础半径内的位置信息127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city beijing 500 km withdist1) 1) "shijiazhuang"   2) "264.2750"2) 1) "tianqing"   2) "109.7753"3) 1) "beijing"   2) "0.0000"#获取某个城市的一维字符串127.0.0.1:6379&gt; GEOHASH china:city beijing1) "wx4g0b7xru0"127.0.0.1:6379&gt; GEOHASH china:city shanghai guangzhou1) "wtw3sjt9vs0"2) "ws0sgyhty70"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>地理位置的底层实现是根据zset进行操作的。</p></blockquote><pre class="line-numbers language-BASH" data-language="BASH"><code class="language-BASH">127.0.0.1:6379&gt; ZRAnge china:city 0 -1#查询所有的经纬度信息1) "guangzhou"2) "shanghai"3) "shijiazhuang"4) "tianqing"5) "beijing"6) "haerbing"127.0.0.1:6379&gt; zrem china:city beijing#删除某个经纬度信息(integer) 1127.0.0.1:6379&gt; ZRAnge china:city 0 -11) "guangzhou"2) "shanghai"3) "shijiazhuang"4) "tianqing"5) "haerbing"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Hyperloglog数据类型"><a href="#Hyperloglog数据类型" class="headerlink" title="Hyperloglog数据类型"></a>Hyperloglog数据类型</h3><p>优点：占用的内存是固定的，可以存取2的64个不同的元素，只需要12kb的内存。</p><p>缺点：是有0.81%的错误率，一般可以忽略不计。</p><p>目的：处理集合中不同的元素总数，跟set的用途一致。</p><ul><li>pfadd         添加元素</li><li>pfcount      计算元素总数</li><li>pfmegre    合并两个元素为一个全新的元素</li></ul><pre class="line-numbers language-BASH" data-language="BASH"><code class="language-BASH">127.0.0.1:6379&gt; PFADD key a b c d e f g h i j k#向集合中添加元素(integer) 1127.0.0.1:6379&gt; PFCOUNT key#查看当前集合的元素总数(integer) 11127.0.0.1:6379&gt; PFADD key1 f f  n f e p o #重复元素的按1计算(integer) 1127.0.0.1:6379&gt; PFCOUNT key1(integer) 5127.0.0.1:6379&gt; PFMERGE key2 key key1#合并两个key的元素为最新的keyOK127.0.0.1:6379&gt; PFCOUNT key2(integer) 14<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="BItMaps数据类型"><a href="#BItMaps数据类型" class="headerlink" title="BItMaps数据类型"></a>BItMaps数据类型</h3><p>表示位运算，一般应用场景是统计某个事情的真总数，以判断是否成立，例如：统计某员工一个月内的打卡次数</p><ul><li>setbit     key   offset  0/1           给某个key设置一个事件，用0表示假、1表示真</li><li>getbit     key   offset                   获取这个key值的事件状态即0/1</li><li>bitcount     key                            查询某个key的真事件的总数</li></ul><pre class="line-numbers language-BASH" data-language="BASH"><code class="language-BASH">127.0.0.1:6379&gt; setbit key 1 0#设置某个元素的某种事件值是0或者1(integer) 0127.0.0.1:6379&gt; setbit key 2 1(integer) 0127.0.0.1:6379&gt; setbit key 2 0(integer) 1127.0.0.1:6379&gt; getbit key 2#获取该元素的事件状态(integer) 0127.0.0.1:6379&gt; setbit key 3 0(integer) 0127.0.0.1:6379&gt; BITCOUNT key#获取某个元素的为1的时间总数(integer) 0127.0.0.1:6379&gt; setbit key 3 1(integer) 0127.0.0.1:6379&gt; BITCOUNT key(integer) 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis常用命令</title>
      <link href="2021/04/29/redis-chang-yong-ming-ling/"/>
      <url>2021/04/29/redis-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<h3 id="redis的命令查找网址"><a href="#redis的命令查找网址" class="headerlink" title="redis的命令查找网址"></a>redis的命令查找网址</h3><p><a href="http://www.redis.cn/commands.html">http://www.redis.cn/commands.html</a></p><h3 id="redis的基本命令"><a href="#redis的基本命令" class="headerlink" title="redis的基本命令"></a>redis的基本命令</h3><pre class="line-numbers language-SHELL" data-language="SHELL"><code class="language-SHELL">127.0.0.1:6379&gt; FLUSHALL#清空所有数据库OK127.0.0.1:6379&gt; set name '123'#设置key为name的值OK127.0.0.1:6379&gt; set age 1#设置key为age的值OK127.0.0.1:6379&gt; get name#获取key为name的值，如果不存在key值则返回nil。"123"127.0.0.1:6379&gt; gea age(error) ERR unknown command `gea`, with args beginning with: `age`, 127.0.0.1:6379&gt; get age#获取key为age的值"1"127.0.0.1:6379&gt; EXISTS naem#查询是否存在此key值，存在返回1，否则返回0(integer) 0127.0.0.1:6379&gt; EXISTS name(integer) 1127.0.0.1:6379&gt; move name 1#移除key值，成功返回1，失败返回0(integer) 1127.0.0.1:6379&gt; keys *#查询当前存在的key值1) "age"127.0.0.1:6379&gt; EXPIRE age 15#设置key值得过期时间(integer) 1127.0.0.1:6379&gt; ttl name(integer) -2127.0.0.1:6379&gt; ttl age#查看当前key的剩余时间，如果key值不存在则返回-2(integer) 7127.0.0.1:6379&gt; ttl age(integer) 4127.0.0.1:6379&gt; ttl age(integer) -2127.0.0.1:6379&gt; type age#查看key值得返回类型String<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="String基本数据类型"><a href="#String基本数据类型" class="headerlink" title="String基本数据类型"></a>String基本数据类型</h3><pre class="line-numbers language-SHELl" data-language="SHELl"><code class="language-SHELl">127.0.0.1:6379&gt; FLUSHALLOK127.0.0.1:6379&gt; keys *(empty array)127.0.0.1:6379&gt; set key1 1OK127.0.0.1:6379&gt; get key1"1"127.0.0.1:6379&gt; EXISTS key1(integer) 1127.0.0.1:6379&gt; EXISTS key1(integer) 1127.0.0.1:6379&gt; EXISTS key2(integer) 0127.0.0.1:6379&gt; APPEND key1 2#给某个key追加一个值，如果当前值不存在则创建当前key，返回的当前value的长度(integer) 2127.0.0.1:6379&gt; keys *1) "key1"127.0.0.1:6379&gt; get key1"12"127.0.0.1:6379&gt; STRLEN key1#查看当前key的长度(integer) 2127.0.0.1:6379&gt; append key1 '321321'(integer) 8127.0.0.1:6379&gt; STRLEN key1(integer) 8127.0.0.1:6379&gt; get key1"12321321"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">127.0.0.1:6379&gt; set view 0OK127.0.0.1:6379&gt; get view"0"127.0.0.1:6379&gt; incr view#给某个字段字段增加1(integer) 1127.0.0.1:6379&gt; incr view(integer) 2127.0.0.1:6379&gt; incr view(integer) 3127.0.0.1:6379&gt; decr view#给某个字段自动减少1(integer) 2127.0.0.1:6379&gt; INCRBY view 10#给某个字段增加10(integer) 12127.0.0.1:6379&gt; INCRBY view 10(integer) 22127.0.0.1:6379&gt; decrby view 5#给某个字段减少5(integer) 17127.0.0.1:6379&gt; incr key1#如果自增的数据不是Integer类型则提示错误(error) ERR value is not an integer or out of range<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-SHELL" data-language="SHELL"><code class="language-SHELL">127.0.0.1:6379&gt; set key1 abcdeOK127.0.0.1:6379&gt; get key1"abcde"127.0.0.1:6379&gt; GETRANGE key1 0 3#获取下表0-3的数据"abcd"127.0.0.1:6379&gt; GETRANGE key1 0 -1 #获取全部的数据"abcde"127.0.0.1:6379&gt; SETRANGE key1 0 111#从下表为0开始替换数据，长度为值得长度(integer) 5127.0.0.1:6379&gt; get key1 "111de"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">127.0.0.1:6379&gt; clear127.0.0.1:6379&gt; keys *1) "key1"127.0.0.1:6379&gt; get key1"111de"127.0.0.1:6379&gt; SETNX key1 'abcde'#设置某个值如果存在则不替换，不存在则添加(integer) 0127.0.0.1:6379&gt; get key1"111de"127.0.0.1:6379&gt; SETEX key1 30 abcde#设置某个值存在即替换，不存在则添加，且设置其过去时间为30s.OK127.0.0.1:6379&gt; get key1"abcde"127.0.0.1:6379&gt; ttl key1#查看剩余时间，如果过期或者不存在则返回0(integer) 22127.0.0.1:6379&gt; ttl key1(integer) 0127.0.0.1:6379&gt; keys *(empty array)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">127.0.0.1:6379&gt; FLUSHdbOK127.0.0.1:6379&gt; keys *(empty array)127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3#设置多个key/value值OK127.0.0.1:6379&gt; keys *1) "k3"2) "k2"3) "k1"127.0.0.1:6379&gt; mset k1 v1 k4 v4#设置多个，如果存在则替换，不存在则添加OK127.0.0.1:6379&gt; keys *1) "k3"2) "k2"3) "k1"4) "k4"127.0.0.1:6379&gt; MSETNX k1 v1 k5 v5#设置多个，如果存在则全部失败，因为redis具有原子性。(integer) 0127.0.0.1:6379&gt; keys *1) "k3"2) "k2"3) "k1"4) "k4"127.0.0.1:6379&gt; get k5(nil)127.0.0.1:6379&gt; GETSET db redis#获取key值并设置key值，返回值为实现get的key值(nil)127.0.0.1:6379&gt; get db"redis"127.0.0.1:6379&gt; getset db mysql"redis"127.0.0.1:6379&gt; get db"mysql"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="List基本数据类型"><a href="#List基本数据类型" class="headerlink" title="List基本数据类型"></a>List基本数据类型</h3><pre class="line-numbers language-SHELL" data-language="SHELL"><code class="language-SHELL">127.0.0.1:6379&gt; FLUSHdbOK127.0.0.1:6379&gt; keys *(empty array)127.0.0.1:6379&gt; LPUSH list a b c#从左侧插入一直list，返回的是当前集合的长度(integer) 3127.0.0.1:6379&gt; lpush list d e(integer) 5127.0.0.1:6379&gt; RPUSH list f g#从右侧插入一个list(integer) 7127.0.0.1:6379&gt; LRANGE list 0 -1 #获取list的所有值1) "e"2) "d"3) "c"4) "b"5) "a"6) "f"7) "g"127.0.0.1:6379&gt; LRANGE list 1  5#获取list下标为1-5的值1) "d"2) "c"3) "b"4) "a"5) "f"127.0.0.1:6379&gt; RPOP list #移除右边的第一个元素"g"127.0.0.1:6379&gt; RPOP list 2#移除右边的2个元素1) "f"2) "a"127.0.0.1:6379&gt; LPOP list 2#移除左边边的2个元素1) "b"2) "c"127.0.0.1:6379&gt; LRANGE list 0 -11) "e"2) "d"127.0.0.1:6379&gt; LINDEX list 1#获取当前集合下标为1的元素"d"127.0.0.1:6379&gt; LLEN list#获取list集合的长度(integer) 2127.0.0.1:6379&gt; LRANGE list 0 -11) "e"2) "d"127.0.0.1:6379&gt; LPUSH list e#王list中添加一个重复元素(integer) 3127.0.0.1:6379&gt; LREM list 2 e#删除list中为e的元素，且值的个数为2(integer) 2127.0.0.1:6379&gt; LRANGE list 0 -11) "d"127.0.0.1:6379&gt; FLUSHdb OK127.0.0.1:6379&gt; keys *(empty array)127.0.0.1:6379&gt; clear127.0.0.1:6379&gt; lpush list hello1(integer) 1127.0.0.1:6379&gt; lpush list hello2(integer) 2127.0.0.1:6379&gt; lpush list hello2(integer) 3127.0.0.1:6379&gt; lpush list hello3(integer) 4127.0.0.1:6379&gt; lpush list hello4(integer) 5127.0.0.1:6379&gt; LREM list 1 hello 2(error) ERR wrong number of arguments for 'lrem' command127.0.0.1:6379&gt; LREM list 1 hello2(integer) 1127.0.0.1:6379&gt; LRANGE list 0 -11) "hello4"2) "hello3"3) "hello2"4) "hello1"127.0.0.1:6379&gt; LPUSH list hello5(integer) 5127.0.0.1:6379&gt; LRANGE list 0 -11) "hello5"2) "hello4"3) "hello3"4) "hello2"5) "hello1"127.0.0.1:6379&gt; LTRIM list 1 2#截取当前key的下标为1到2的值OK127.0.0.1:6379&gt; LRANGE list 0 -11) "hello4"2) "hello3"127.0.0.1:6379&gt; RPOPLPUSH list mylist#截取list右侧第一个元素把他存入到mylist的最左侧"hello3"127.0.0.1:6379&gt; LRANGE list 0 -1#查看list的所有值1) "hello4"127.0.0.1:6379&gt; LRANGE mylist 0 -1#查看mylist的所有值1) "hello3"127.0.0.1:6379&gt; FLUSHdbOK127.0.0.1:6379&gt; EXISTS list#查看是否存在当前key值(integer) 0127.0.0.1:6379&gt; lset list 0 redis#往当前key值中set一个下标为0的数据，如果不存在则提示错误，存在则替换(error) ERR no such key127.0.0.1:6379&gt; LPUSH list mysql(integer) 1127.0.0.1:6379&gt; lset list 0 redisOK127.0.0.1:6379&gt; LRANGE list 0 -11) "redis"127.0.0.1:6379&gt; lset list 1 redis(error) ERR index out of range##############################################127.0.0.1:6379&gt; LRANGE list 0 -11) "redis"127.0.0.1:6379&gt; lpush list myql(integer) 2127.0.0.1:6379&gt; LRANGE list 0 -11) "myql"2) "redis"127.0.0.1:6379&gt; LINSERT list before 'mysql' mysql1(integer) -1127.0.0.1:6379&gt; LRANGE list 0 -11) "myql"2) "redis"127.0.0.1:6379&gt; LINSERT list after 'mysql' mysql1(integer) -1127.0.0.1:6379&gt; LRANGE list 0 -11) "myql"2) "redis"127.0.0.1:6379&gt; keys *1) "list"127.0.0.1:6379&gt; LRANGE list 0 -11) "myql"2) "redis"127.0.0.1:6379&gt; LINSERT list after "redis" "mysql1"#往某个key得之前或之后插入一个值，值不能是下标为0的数据。(integer) 3127.0.0.1:6379&gt; LRANGE list 0 -11) "myql"2) "redis"3) "mysql1"127.0.0.1:6379&gt; LINSERT list before "redis" "mysql1"(integer) 4127.0.0.1:6379&gt; LRANGE list 0 -11) "myql"2) "mysql1"3) "redis"4) "mysql1"127.0.0.1:6379&gt; LINSERT list before "mysql" "mysql1"(integer) -1127.0.0.1:6379&gt; LINSERT list after "mysql" "mysql1"(integer) -1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Set基本数据类型"><a href="#Set基本数据类型" class="headerlink" title="Set基本数据类型"></a>Set基本数据类型</h3><pre class="line-numbers language-SHELL" data-language="SHELL"><code class="language-SHELL">127.0.0.1:6379&gt; sadd key hello#向key值添加一个元素，如果存在，则返回0，如果不存在则返回1(integer) 1127.0.0.1:6379&gt; sadd key world(integer) 1127.0.0.1:6379&gt; sadd key world(integer) 0127.0.0.1:6379&gt; SMEMBERS key#查看key的所有元素1) "world"2) "hello"127.0.0.1:6379&gt; SISMEMBER key hellp#查看当前key是否存在某个值，如果存在则返回1，不存在则返回0(integer) 0127.0.0.1:6379&gt; SISMEMBER key hello(integer) 1127.0.0.1:6379&gt; scard key#查看当前key的所有值(integer) 2127.0.0.1:6379&gt; SREM key hello#移除某个元素，如果原有元素存在则返回1，原有元素不存在则返回0(integer) 127.0.0.1:6379&gt; SMEMBERS key1) "world"127.0.0.1:6379&gt; Sadd key 1(integer) 1127.0.0.1:6379&gt; Sadd key 2(integer) 1127.0.0.1:6379&gt; Sadd key 3(integer) 1127.0.0.1:6379&gt; SMEMBERS key1) "3"2) "1"3) "world"4) "2"127.0.0.1:6379&gt; SRANDMEMBER key#随机抽取一个key值"world"127.0.0.1:6379&gt; SRANDMEMBER key"world"127.0.0.1:6379&gt; SRANDMEMBER key"1"127.0.0.1:6379&gt; SRANDMEMBER key"2"127.0.0.1:6379&gt; SRANDMEMBER key"world"127.0.0.1:6379&gt; SRANDMEMBER key"3"127.0.0.1:6379&gt; SRANDMEMBER key 2#随机抽取指定个数key值1) "3"2) "2"127.0.0.1:6379&gt; SPOP key#随机删除一个元素，也可跟个数"2"127.0.0.1:6379&gt; SPOP key"1"127.0.0.1:6379&gt; SMEMBERS key1) "3"2) "world"127.0.0.1:6379&gt; FLUSHdbOK127.0.0.1:6379&gt; sadd key 1(integer) 1127.0.0.1:6379&gt; sadd key 2 3 4 5(integer) 4127.0.0.1:6379&gt; SMOVE key key1 2#把某个key的值移动另外一个key中(integer) 1127.0.0.1:6379&gt; keys *1) "key"2) "key1"127.0.0.1:6379&gt; SMEMBERS key1) "1"2) "3"3) "4"4) "5"127.0.0.1:6379&gt; SMEMBERS key11) "2"127.0.0.1:6379&gt; sadd key1 1 3 4(integer) 3127.0.0.1:6379&gt; SMEMBERS key#查询key的value值1) "1"2) "3"3) "4"4) "5"127.0.0.1:6379&gt; SMEMBERS key11) "1"2) "2"3) "3"4) "4"127.0.0.1:6379&gt; sdiff key key1#以key为基准，求两个key的差集1) "5"127.0.0.1:6379&gt; SINTER key key1#求两个集合的交集1) "1"2) "3"3) "4"127.0.0.1:6379&gt; SUNION key key1#求两个集合的并集1) "1"2) "2"3) "3"4) "4"5) "5"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Hash的基本命令（key-key-value"><a href="#Hash的基本命令（key-key-value" class="headerlink" title="Hash的基本命令（key-(key-value)"></a>Hash的基本命令（key-(key-value)</h3><pre class="line-numbers language-SHELL" data-language="SHELL"><code class="language-SHELL">127.0.0.1:6379&gt; hset hash key 1#向某个key值中添加一个key/value键值对 其中外层key为hash,内层key为key，value为1(integer) 1127.0.0.1:6379&gt; hset hash key 1 key1 2 key2 3#向key值hash中添加多个元素(integer) 2127.0.0.1:6379&gt; HGET hash key#获取hash中的key的值"1"127.0.0.1:6379&gt; HMGET hash key key1 key2#获取多个值1) "1"2) "2"3) "3"127.0.0.1:6379&gt; HGETALL hash#获取hash的所有key、value信息1) "key"2) "1"3) "key1"4) "2"5) "key2"6) "3"127.0.0.1:6379&gt; HDEL hash key key1#删除hash的key和key1的值(integer) 2127.0.0.1:6379&gt; HGETALL hash1) "key2"2) "3"127.0.0.1:6379&gt; HLEN hash#获取hash的键值对总数(integer) 1127.0.0.1:6379&gt; HEXISTS hash key1#查看hash中是否存在某个key值，如果存在返回1，如果不存在返回0(integer) 0127.0.0.1:6379&gt; HGETALL hash1) "key2"2) "3"127.0.0.1:6379&gt; HEXISTS hash key2(integer) 1127.0.0.1:6379&gt; HKEYS hash#获取hash里面所有的key值1) "key2"127.0.0.1:6379&gt; HVALS hash#获取hash中所有value值1) "3"127.0.0.1:6379&gt; hset hash key3 5(integer) 1127.0.0.1:6379&gt; HKEYS hash1) "key2"2) "key3"127.0.0.1:6379&gt; HVALS hash1) "3"2) "5"127.0.0.1:6379&gt; HINCRBY hash key3 5#给hash的key3值增加5(integer) 10127.0.0.1:6379&gt; HINCRBY hash key3 -1#给hash的key3值增加-1(integer) 9127.0.0.1:6379&gt; HSETNX hash key3 8#如果存在则给某个key添加至，不存在则返回0.(integer) 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Hset的基础类型"><a href="#Hset的基础类型" class="headerlink" title="Hset的基础类型"></a>Hset的基础类型</h3><pre class="line-numbers language-SHELL" data-language="SHELL"><code class="language-SHELL">127.0.0.1:6379&gt; zadd salary 800 lk#向某个元素添加至，其中key为salary,800为位置，即排序的标准(integer) 1127.0.0.1:6379&gt; zadd salary 900 wl 1000 ml(integer) 2127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf +inf#查看所有的value值，1) "lk"2) "wl"3) "ml"127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf 900 withscores #查看小于900的value值，显示score1) "lk"2) "800"3) "wl"4) "900"127.0.0.1:6379&gt; ZRAnge salary 0 -1#查询所有key值，无排序，按插入顺序1) "lk"2) "wl"3) "ml"127.0.0.1:6379&gt; ZRem salary lw#移除某个元素，如果存在返回1，不存在返回0(integer) 0127.0.0.1:6379&gt; ZRem salary lk(integer) 1127.0.0.1:6379&gt; ZRAnge salary 0 -11) "wl"2) "ml"127.0.0.1:6379&gt; ZCARD salary#获取集合中的个数(integer) 2127.0.0.1:6379&gt; ZREVRANGE salary 0 -1 withscores#按socre从大到小排序1) "ml"2) "1000"3) "wl"4) "900"127.0.0.1:6379&gt; ZCOUNT salary 0 900#获取集合内的总数(integer) 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis简介</title>
      <link href="2021/04/29/redis-jian-jie/"/>
      <url>2021/04/29/redis-jian-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="NoSQL简介"><a href="#NoSQL简介" class="headerlink" title="NoSQL简介"></a>NoSQL简介</h3><ul><li>NoSQL的全称     not only SQL</li><li>方便扩展，数据之间没有关系</li><li>大数据高性能（读取11万次每秒，写8万次每秒）</li><li>数据类型多种多样且不需要事先设计数据库的表，有更好的扩展性    </li></ul><h3 id="传统的数据库和NoSQL的区别"><a href="#传统的数据库和NoSQL的区别" class="headerlink" title="传统的数据库和NoSQL的区别"></a>传统的数据库和NoSQL的区别</h3><h4 id="传统数据库："><a href="#传统数据库：" class="headerlink" title="传统数据库："></a>传统数据库：</h4><ul><li>结构化组织</li><li>数据都存储在表中</li><li>需要用sql进行查询</li><li>严格的一致性</li><li>数据定义语言</li></ul><h4 id="NoSQL："><a href="#NoSQL：" class="headerlink" title="NoSQL："></a>NoSQL：</h4><ul><li>不仅仅是数据库</li><li>没有固定的查询语言</li><li>键值对存储、列存储、文档存储、图形数据库等</li><li>最终一致性</li><li>CAP定理和BASE理论</li><li>高性能、高可用、高扩展</li></ul><h3 id="NoSQL的4种存储方式"><a href="#NoSQL的4种存储方式" class="headerlink" title="NoSQL的4种存储方式"></a>NoSQL的4种存储方式</h3><ul><li>k-v键值对    常见的有redis、Tair、Memcache</li><li>文档数据库：MongoDB</li><li>列存储数据库：HBase、分布式文件系统</li><li>图形数据库：Neo4j</li></ul><p><img src="https://i.loli.net/2021/04/29/RtrZoQSJaFqiGUs.png" alt="nosql分类.png"></p><h3 id="Redis的概述"><a href="#Redis的概述" class="headerlink" title="Redis的概述"></a>Redis的概述</h3><p>英文官网：    <a href="https://redis.io/">https://redis.io/</a></p><p>中文官网：    <a href="http://www.redis.cn/">http://www.redis.cn/</a></p><h4 id="redis是什么"><a href="#redis是什么" class="headerlink" title="redis是什么"></a>redis是什么</h4><p>Redis（Remote Dictionary Server )，即远程字典服务。</p><p>是一个开源的使用ANSI <a href="https://baike.baidu.com/item/C%E8%AF%AD%E8%A8%80">C语言</a>编写、支持网络、可基于内存亦可持久化的日志型、Key-Value<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93/103728">数据库</a>，并提供多种语言的API。</p><h4 id="redis能做什么"><a href="#redis能做什么" class="headerlink" title="redis能做什么"></a>redis能做什么</h4><ul><li>内存存储，持久化，常用的持久化是RDB、AOF</li><li>效率高用于缓存</li><li>发布订阅系统</li><li>地图信息分析</li><li>计时器、计数器</li><li>………………</li></ul><h4 id="redis的特性"><a href="#redis的特性" class="headerlink" title="redis的特性"></a>redis的特性</h4><ul><li>多样的数据类型</li><li>持久化</li><li>集群</li><li>事务</li></ul><h4 id="redis数据库"><a href="#redis数据库" class="headerlink" title="redis数据库"></a>redis数据库</h4><p>redis有16个数据库，默认数据库是0号数据库</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">127.0.0.1:6379&gt; select 3#切换数据库到3OK127.0.0.1:6379[3]&gt; dbsize#显示当前数据库的key值数量(integer) 0127.0.0.1:6379[3]&gt; set key 1#设置一个值OK127.0.0.1:6379[3]&gt; get key#获取值"1"127.0.0.1:6379[3]&gt; select 1    #切换到1号数据库OK127.0.0.1:6379[1]&gt; get key#得到的数据为nil，也即是在3号数据库设置的值在1号数据库查不到(nil)127.0.0.1:6379[1]&gt; keys *#查询当前数据库的所有key值127.0.0.1:6379[1]&gt; FLUSHALL#清空所有数据库的值OK127.0.0.1:6379[1]&gt; FLUSHdb #清空当前数据库的值OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="redis的原理"><a href="#redis的原理" class="headerlink" title="redis的原理"></a>redis的原理</h4><p>redis是单线程的，redis是基于内存操作的，CPU不是redis的性能瓶颈，redis的性能瓶颈是由内存和网络带宽决定的。</p><p>redis是用c语言编写的，每秒大概100000QPS，性能不比Memcache差。</p><p>由于redis的数据都存储在内存中，所以单线程操作更加快速。多线程操作会存在CPU之间的切换消耗资源。对于内存系统，没有CPU切换效率最高。</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker常用命令汇总</title>
      <link href="2021/04/28/docker-chang-yong-ming-ling-hui-zong/"/>
      <url>2021/04/28/docker-chang-yong-ming-ling-hui-zong/</url>
      
        <content type="html"><![CDATA[<h4 id="普通指令"><a href="#普通指令" class="headerlink" title="普通指令"></a>普通指令</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 启动dockersystemctl start docker #停止dockersystemctl stop docker#重启dockersystemctl restart docker#查看版本docker version#查看docker信息docker info#帮助docker --help<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h4><pre class="line-numbers language-SHELL" data-language="SHELL"><code class="language-SHELL"># 查看已安装的镜像docker images# 查询镜像docker search 镜像名   #例如：docker search tomcat# 拉取镜像docker pull 镜像名#例如：docker pull tomcat:8.5 如果后面不跟版本后则默认下载最新版本# 删除镜像docker rmi 镜像名#例如 docker rmi tomcatdocker rmi -f  镜像id#镜像id是创建镜像的唯一表示# 删除所有镜像docker rmi -f ${docker images -qa}  #即查询出所有镜像并删除# 打包一个镜像docker commit -a 作者信息 -m="要提交的信息" 镜像id  要生产的镜像名称# 运行一个镜像,运行成功之后则生成一个容器docker run -it -p 外部端口号:内部端口号 镜像名称  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h4><pre class="line-numbers language-SHELL" data-language="SHELL"><code class="language-SHELL"># 通过镜像生成容器的常用命令--name  #给容器起一个名字-d#表示后台运行-it#表示进入控制台运行与-d功能相同-P#随机分配一个端口号不常用-p#端口映射外部端口：内部端口-v#卷挂载宿主机路径：内部路径   用途是挂载文件是同步的，即可通过修改外部文件已到达修改内部文件的目的# 查询docker正在运行的容器docker ps   #后续的常用参数-a #查看所有容器-l#最近创建的容器-n#最近创建的n个容器# 退出容器exit #退出并停止ctrl+p+Q#退出但不停止# 启动、停止、重启、杀死容器docker start/stop/restart/kill 容器id或容器名# 删除容器   docker rm 容器id或容器名#只能删除已停止的容器docker rm -f  容器id或容器名#强制删除容器docker rm -f ${docker ps -qa}  #删除所有容器#重新进入容器docker attach 容器id或容器名#这种方式太慢docker exex -it 容器id或容器名 /bin/bash #进入正在执行的容器并进行交互# 拷贝文件从内部到外部docker cp 容器id或容器名:文件路径 宿主机路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="日志命令"><a href="#日志命令" class="headerlink" title="日志命令"></a>日志命令</h4><pre class="line-numbers language-SHELL" data-language="SHELL"><code class="language-SHELL">docker logs -f -t --tail 10   容器id或容器名-t    #表示显示时间-f#最新的日志打印--tail #行数-n#全部打印docker top 容器id或容器名    #查看容器内的进程<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker进阶</title>
      <link href="2021/04/21/docker-jin-jie/"/>
      <url>2021/04/21/docker-jin-jie/</url>
      
        <content type="html"><![CDATA[<h4 id="容器卷技术"><a href="#容器卷技术" class="headerlink" title="容器卷技术"></a>容器卷技术</h4><p>容器卷技术的目的是为了持久化和同步操作！容器件也可以进行同步。</p><pre class="line-numbers language-SHELL" data-language="SHELL"><code class="language-SHELL">#容器与本地数据挂载# 一、命令挂载docker run -it -v  linux文件目录:容器目录 容器id /bin/bash#把linux目录和容器目录进行同步# 二、dockerFile 挂载# 1、建立dockerFile文件  其中书写指令是必须都大写FROM centos#要挂载的镜像VOLUME ["volume01","volume2"]#要挂载的卷CMD echo "----end----"CMD /bin/bash# 2、运行文件docker build -f 创建的dockerFile目录 -t 生成的名字#容器之间挂载 把两容器关联起来docker run -it --name 新建容器 --volume-from 要挂载的容器  moer/centos:1.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Dockerfile构建过程"><a href="#Dockerfile构建过程" class="headerlink" title="Dockerfile构建过程"></a>Dockerfile构建过程</h4><h6 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h6><p>1、每个指令必须的大写</p><p>2、指令的执行顺序从上到下</p><p>3、#表示注释</p><p>4、每个指令都会提交一个镜像，层层提交。</p><h4 id="DokcerFile的基础命令"><a href="#DokcerFile的基础命令" class="headerlink" title="DokcerFile的基础命令"></a>DokcerFile的基础命令</h4><p><img src="https://i.loli.net/2021/04/22/9BiAIRS7wEUqkPD.jpg" alt="docker命令.jpg"></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">FROM #基础镜像MAINRAINER#姓名+邮箱RUN#运行命令ADD#添加分层镜像WORKDIR#工作目录VOLUME#挂载卷EXPOSE#暴露端口号CMD#指定容器运行的适合要启动的命令，只有最后一个命令生效，不可追加ENTRYPOINT#指定容器运行的适合要启动的命令，可以追加命令ENV#构建的时候设置环境变量COPY#把一个镜像拷贝进去类似ADD<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="docker-网络"><a href="#docker-网络" class="headerlink" title="docker 网络"></a>docker 网络</h6><pre class="line-numbers language-SHELL" data-language="SHELL"><code class="language-SHELL">docker network ls   #查看所有的docker网络b6fbe2727cc1        bridge              bridge              locale8ea254fb069        host                host                local4956a8e7920a        none                null                local#其中bridge 是桥接模式（默认）host是主机模式  none不配置网络<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="springboot项目打包成Docker镜像"><a href="#springboot项目打包成Docker镜像" class="headerlink" title="springboot项目打包成Docker镜像"></a>springboot项目打包成Docker镜像</h6><pre class="line-numbers language-none"><code class="language-none">1、编写成功Springboot项目2、达成jar包3、编写dockerFile进行发布4、构建镜像5、发布运行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>序列化</title>
      <link href="2021/04/20/xu-lie-hua/"/>
      <url>2021/04/20/xu-lie-hua/</url>
      
        <content type="html"><![CDATA[<h4 id="java序列化和反序列化是什么？"><a href="#java序列化和反序列化是什么？" class="headerlink" title="java序列化和反序列化是什么？"></a>java序列化和反序列化是什么？</h4><p>序列化：把对象转换为字节序列的过程称为对象的序列化。</p><p>反序列化：把字节序列恢复为对象的过程称为对象的反序列化。</p><h4 id="为什么要用java序列化，它的作用是什么？"><a href="#为什么要用java序列化，它的作用是什么？" class="headerlink" title="为什么要用java序列化，它的作用是什么？"></a>为什么要用java序列化，它的作用是什么？</h4><p>1、 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中。</p><p>2、在网络上传送对象的字节序列。</p><h4 id="实现java序列化的方式？"><a href="#实现java序列化的方式？" class="headerlink" title="实现java序列化的方式？"></a>实现java序列化的方式？</h4><p>javaBean实现Serializable接口。</p><h4 id="为什么实现序列化的时要设置-serialVersionUID"><a href="#为什么实现序列化的时要设置-serialVersionUID" class="headerlink" title="为什么实现序列化的时要设置 serialVersionUID"></a>为什么实现序列化的时要设置 serialVersionUID</h4><p>如果一个M实体在序列化的时候存在A、B、C三个字段，则反序列化的时候也会返回这三个字段。由于需求的变化导致M实体增加了字段D，由于序列化的内容只有三个字段，在进行反序列化的时则会提示异常。故需设置标识来保证反序列化时serialVersionUID是否改变。</p><h4 id="javaBean中的字段不被序列化可以吗？"><a href="#javaBean中的字段不被序列化可以吗？" class="headerlink" title="javaBean中的字段不被序列化可以吗？"></a>javaBean中的字段不被序列化可以吗？</h4><p>使用Transient修饰关键字可以保证字段不被序列化，被反序列化时如果类型为int则默认值为0，对象型的默认值为null。</p><h4 id="static修饰的字段为什么不被序列化"><a href="#static修饰的字段为什么不被序列化" class="headerlink" title="static修饰的字段为什么不被序列化"></a>static修饰的字段为什么不被序列化</h4><p>由于static修饰的字段存在于静态方法区，而不是堆内存中，故不被序列化</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><h6 id="使用序列化的目的是把javaBean信息存入到磁盘中，方便进行网络中传输，特别是现在微服务盛行的时代。"><a href="#使用序列化的目的是把javaBean信息存入到磁盘中，方便进行网络中传输，特别是现在微服务盛行的时代。" class="headerlink" title="使用序列化的目的是把javaBean信息存入到磁盘中，方便进行网络中传输，特别是现在微服务盛行的时代。"></a>使用序列化的目的是把javaBean信息存入到磁盘中，方便进行网络中传输，特别是现在微服务盛行的时代。</h6><h6 id="目前最常见的实现序列化的方式时实现Serializable接口，并且要设置serialVersionUID的版本号以便对象更改时反序列化出错。"><a href="#目前最常见的实现序列化的方式时实现Serializable接口，并且要设置serialVersionUID的版本号以便对象更改时反序列化出错。" class="headerlink" title="目前最常见的实现序列化的方式时实现Serializable接口，并且要设置serialVersionUID的版本号以便对象更改时反序列化出错。"></a>目前最常见的实现序列化的方式时实现Serializable接口，并且要设置serialVersionUID的版本号以便对象更改时反序列化出错。</h6><h6 id="对于敏感信息不想被序列化可以用Transient关键字进行隐藏，或者用static关键字设置为静态字段。"><a href="#对于敏感信息不想被序列化可以用Transient关键字进行隐藏，或者用static关键字设置为静态字段。" class="headerlink" title="对于敏感信息不想被序列化可以用Transient关键字进行隐藏，或者用static关键字设置为静态字段。"></a>对于敏感信息不想被序列化可以用Transient关键字进行隐藏，或者用static关键字设置为静态字段。</h6>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合</title>
      <link href="2021/04/20/ji-he/"/>
      <url>2021/04/20/ji-he/</url>
      
        <content type="html"><![CDATA[<h4 id="数组和集合的区别？"><a href="#数组和集合的区别？" class="headerlink" title="数组和集合的区别？"></a>数组和集合的区别？</h4><blockquote><p>数组是同一类型的数据汇总，长度是固定的，可以通过下标的形式获取值，存入值。</p></blockquote><blockquote><p>集合是具有某种特质的抽象对象汇成的集体。</p></blockquote><blockquote><p>相对来说数组适用于简单固定的数据操作，而集合不仅适用于简单的数据操作，也可操作复杂的数据信息。</p></blockquote><blockquote><p>对简单数据操作来说数组更方便快捷。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">//数组的三种创建方式int[] createOne = new int[]{1,2,3,4,5};int[] createTwo = {1,2,3,4,5};int[] createThree = new int[5];//数组存储值方式，获取值方式createThree[0] = 1;System.out.println(createThree[0]);createThree[0] = 2;System.out.println(createThree[0]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="谈谈你对集合的理解"><a href="#谈谈你对集合的理解" class="headerlink" title="谈谈你对集合的理解"></a>谈谈你对集合的理解</h4><blockquote><p>集合分为Collection和Map两个大的方向，Collection有包含了Set不重复集合、List可重复集合两种。</p></blockquote><h4 id="Set集合描述"><a href="#Set集合描述" class="headerlink" title="Set集合描述"></a>Set集合描述</h4><blockquote><p>Set是存储无序元素集合，且集合内的元素不会重复。</p></blockquote><blockquote><p>Set接口的实现方式有很多，例如HashSet、TreeSet、LinkedHashSet等</p></blockquote><p>HashSet的特点是无重复、无序，存储位置是通过特定的hash算法进行获得，存储方式时数组结构，如果两个元素hashCode()相等但equals()不相等时，存储的方式时在数组的基础上增加链表。如果两则均相等则表示重复，具体存储方式可了解hashMap的存储方式。</p><p>TreeSet的特点是自然排序，无重复，存储机构是红黑树的形式，判断两个元素是否重复（重写了Comparable的CompareTo方法来判断返回值是否为0，如果0则表示重复）</p><p>LinkedHashSet的特点是按插入顺序排序，无重复，判断是否重复的方式跟HashSet一致。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//常见的集合操作Set&lt;String&gt; setOne = new LinkedHashSet&lt;String&gt;();Set&lt;String&gt; setTwo = new HashSet&lt;String&gt;();Set&lt;String&gt; setThree = new TreeSet&lt;String&gt;();//添加元素setOne.add("ea");setOne.add("a");setOne.add("dc");setOne.add("nb");setOne.add("md");setTwo.add("ea");setTwo.add("a");setTwo.add("dc");setTwo.add("nb");setTwo.add("md");setThree.add("ea");setThree.add("a");setThree.add("dc");setThree.add("nb");setThree.add("md");//遍历元素setOne.forEach(set-&gt;System.out.print(set+"   "));System.out.println("LinkedHashSet的遍历结果");setTwo.forEach(set-&gt;System.out.print(set+"   "));System.out.println("HashSet的遍历结果");setThree.forEach(set-&gt;System.out.print(set+"   "));System.out.println("TreeSet的遍历结果");//删除元素setOne.remove("d");//查看集合是否有值setOne.isEmpty();//查看集合的个数 setOne.size();//查看是否包含元素setOne.contains("d");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#这是上述三种集合遍历的结果，可看出三种集合的排序方式ea   a   dc   nb   md   LinkedHashSet的遍历结果a   nb   md   ea   dc   HashSet的遍历结果a   dc   ea   md   nb   TreeSet的遍历结果<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="List集合描述"><a href="#List集合描述" class="headerlink" title="List集合描述"></a>List集合描述</h4><blockquote><p>List集合是存储有序的集合，且集合内的元素是可重复的。</p></blockquote><blockquote><p>List接口的实现方式有ArrayList,Vector,LinkedList三种方式</p></blockquote><p>ArrayList底层实现方式是数组的结构，方便查找。</p><p>Vector底层实现方式也是数组结构，与ArrayList不同之处在于它是线程安全的，所以性能消耗更大，不建议使用</p><p>LinkedList底层实现方式时双向链表结构，方便插入、删除。</p><p>由于ArrayList插入方式大部分都是尾插法，与LinkedList相比两则在数据插入时ArrayList的效率更高。</p><p>再删除时，ArrayList删除的数据更靠后或数据量很小时移动的次数也会很少，两则的效率差不太多，故使用场景中ArrayList运用比较广泛。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//常见的集合操作List&lt;String&gt; listOne = new ArrayList&lt;String&gt;();List&lt;String&gt; listTwo = new LinkedList&lt;&gt;();listOne.add("aaa");listOne.add("bbb");listOne.add("ccc");listTwo.add("aaa");listTwo.add("bbb");listTwo.add("ccc");//遍历操作listOne.forEach(System.out::print);//集合大小System.out.println(listOne.size());//是否为空System.out.println(listOne.isEmpty());//是否包含某个数据System.out.println(listOne.contains("aaa"));//通过下标获取元素System.out.println(listOne.get(0));//移除某个元素System.out.println(listOne.remove("aaa"));//替换某个元素System.out.println(listOne.set(1,"aaaaaaa"));//截取集合System.out.println(listOne.subList(0,1));//获取某个元素的下标System.out.println(listOne.indexOf("bbb"));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Map集合描述"><a href="#Map集合描述" class="headerlink" title="Map集合描述"></a>Map集合描述</h4><blockquote><p>Map是一个key/value的键值对集合，key不可重复，value可重复的。</p></blockquote><blockquote><p>Map接口的实现方式有HashMap、HashTable、TreeMap、LinkedHashMap</p></blockquote><p>HashMap是我们最常用且最快速的，key底层数据结构是数组+链表+红黑树形式的，key/value都可为null。</p><p>HashTable和HashMap是线程安全的，效率较慢，故不经常用，且key/value都不允许为null。</p><p>TreeMap的存储是根据比较器进行排序，跟TreeSet的数据结构层上一致，key不可以为null。</p><p>LinkedHashMap是按存储的先后位置进行确定的，key/value都可为null。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Map&lt;String,String&gt;  mapOne = new HashMap&lt;String,String&gt;();//添加数据mapOne.put("aaa","aaaaaaaaaaa");//遍历数据mapOne.forEach((str,str1)-&gt;{    System.out.println(str1);});//根据key值获取valueSystem.out.println(mapOne.get("aaa"));//判断集合是否为nullSystem.out.println( mapOne.isEmpty());//查看集合的大小System.out.println( mapOne.size());//查看集合是否包含某个key值System.out.println( mapOne.containsKey("aaa"));//查看集合是否包含某个value值System.out.println( mapOne.containsValue("aaaaaaa"));//移除某个key值System.out.println( mapOne.remove("aaaaaaa"));//替换某个key的value值System.out.println( mapOne.replace("aaa","bbbbbbb"));//清除value的值mapOne.clear();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用排序算法</title>
      <link href="2021/04/20/chang-yong-pai-xu-suan-fa/"/>
      <url>2021/04/20/chang-yong-pai-xu-suan-fa/</url>
      
        <content type="html"><![CDATA[<h6 id="1、选择排序"><a href="#1、选择排序" class="headerlink" title="1、选择排序"></a>1、选择排序</h6><p><img src="https://i.loli.net/2021/04/20/eu9IyhmdiEcTHBx.gif" alt="选择排序.gif"></p><p>选择排序就是每趟排序从中找出最小的一个放在最前面，直至最后排序完成。</p><p>通俗的讲：假设有N条数据，首先第一趟排序从1-N中找出最小的一个，然后把1的数据的和最小的数据进行交换，第二趟则从2-N中找出最小的一个，再让2与最小的数据进行交换。以此类推，直到N-1趟结束。由此可推断比较次数为N+（N-1）+…..+2+1;</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void main(String[] args) {        int[]  chooseArray  = {10,11,12,16,2,18,9,5,4,29,11};        for (int ele:chooseArray) {            System.out.print(ele+",");        }        System.out.println("排序前的遍历数据");        for (int i =0;i&lt;chooseArray.length-1;i++){            int start = chooseArray[i];  //每次循环的开始数据            int index = i;   //获取每次循环的最小下标            int temp = 0;    //交换是临时存放值            for (int ele:chooseArray) {                System.out.print(ele+",");            }            System.out.println("每一次调用过程数据遍历");            for (int j=i+1;j&lt;chooseArray.length;j++){                if (start&gt;chooseArray[j]){ //如果开始值大于当前值                    start=chooseArray[j];  //把当前值赋予开始值，并与后续的值进行循环大小比较                    index=j;   //并记录当前下标                }            }            if(index!=i){   //如果本次循环下标不等于index则表示当前循环的最小值非开始值                temp = chooseArray[i]; //把开始值赋给临时值                chooseArray[i]=start; //把最小值赋给开始位置                chooseArray[index] =temp; //把临时值赋给最小值的下标位置            }        }        for (int ele:chooseArray) {            System.out.print(ele+",");        }        System.out.println("排序后的遍历数据");    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#每一趟排序后遍历的结果10,11,12,16,2,18,9,5,4,29,11,每一次调用过程数据遍历2,11,12,16,10,18,9,5,4,29,11,每一次调用过程数据遍历2,4,12,16,10,18,9,5,11,29,11,每一次调用过程数据遍历2,4,5,16,10,18,9,12,11,29,11,每一次调用过程数据遍历2,4,5,9,10,18,16,12,11,29,11,每一次调用过程数据遍历2,4,5,9,10,18,16,12,11,29,11,每一次调用过程数据遍历2,4,5,9,10,11,16,12,18,29,11,每一次调用过程数据遍历2,4,5,9,10,11,11,12,18,29,16,每一次调用过程数据遍历2,4,5,9,10,11,11,12,18,29,16,每一次调用过程数据遍历2,4,5,9,10,11,11,12,16,29,18,每一次调用过程数据遍历2,4,5,9,10,11,11,12,16,18,29,排序后的遍历数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="2、冒泡排序"><a href="#2、冒泡排序" class="headerlink" title="2、冒泡排序"></a>2、冒泡排序</h6><p><img src="https://i.loli.net/2021/04/20/YTl5X36ZAFVebE9.png" alt="冒泡排序.png"></p><p>冒泡排序是相邻的两个数据进行比较，如果前者大于后者，两则进行交换。每趟比较之后最后一个则为最大数值。</p><p>通俗的讲：假设有N条数据，第一趟则先让第一条与第二条比较，如果第一条大于第二条则两条数据进行交换，否则不进行交互，即值大的放后面，然后第二条在于第三条进行比较得出比较大的值放第三条的位置，以此类推得出最大的一条放在最后面。第二趟还是第一条与第二条相比，得出最大与第三条相比，知道N-1次（最后一条已经为最大了）。由此可推断比较次数为N+（N-1）+…..+2+1。</p><p>冒泡排序可中途进行打断，即当发现排序过程中已经排序成功则可进行break打断当前循环，以减少资源浪费。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void main(String[] args) {  int[]  bubbleArray  = {10,11,12,16,2,18,9,5,4,29,11};    for (int i =0;i&lt;bubbleArray.length-1;i++){        boolean changeFlag = false;  //控制后续如果值无改变可调出循环代表已排序完成        int temp = 0;        for (int ele:bubbleArray) {            System.out.print(ele+",");        }        System.out.println("第"+i+"趟排序前数据");        for (int j=0;j&lt;bubbleArray.length-1-i;j++){            if (bubbleArray[j]&gt;bubbleArray[j+1]){ //如果第j条数据大于后一条数据                temp=bubbleArray[j];    //则把第j条数据赋给临时数据                bubbleArray[j]=bubbleArray[j+1];  //把后条数据赋给第j条数据                bubbleArray[j+1] =temp; //再把临时数据赋给第j+1条                changeFlag=true; //说明有排序的动作            }        }        if(!changeFlag){ //如果无排序的动作则进行打断当前循环            break;        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#当前做了8次循环，如果不打断则会循环数组的11-1=10次10,11,12,16,2,18,9,5,4,29,11,第0趟排序前数据10,11,12,2,16,9,5,4,18,11,29,第1趟排序前数据10,11,2,12,9,5,4,16,11,18,29,第2趟排序前数据10,2,11,9,5,4,12,11,16,18,29,第3趟排序前数据2,10,9,5,4,11,11,12,16,18,29,第4趟排序前数据2,9,5,4,10,11,11,12,16,18,29,第5趟排序前数据2,5,4,9,10,11,11,12,16,18,29,第6趟排序前数据2,4,5,9,10,11,11,12,16,18,29,第7趟排序前数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="3、插入排序"><a href="#3、插入排序" class="headerlink" title="3、插入排序"></a>3、插入排序</h6><p><img src="https://i.loli.net/2021/04/20/IlVLMqed8s1Y9rU.png" alt="插入排序.png"></p><p>插入排序是每次拿出一个值与已排序好的进行比较，直至排序完成。</p><p>通俗的讲：假设有N条数据，第一趟让第二条数据与第一条比较如果大于则不交换，小于则进行交换，第二趟则让第三条数据与第二条相比较，如果大于则表明，第三条比第一条也大，无需比较，如果小于则让第三条与第一条进行比较，如果小于则第一条、第二条后移一位，第三条存放第一位数据，如果大于则第一条不变，第二条与第三条交换位置。这样可以保证每次循环过后前面的数据都是排序完成的。由此可推断比较的次数为1+2+……+N-1。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void main(String[] args) {    int[]  insertArray  = {10,11,12,16,2,18,9,5,4,29,11};    for (int i =1;i&lt;insertArray.length;i++){        int temp = insertArray[i];   //把要比较的值存入临时        int j ;        for (int ele:insertArray) {            System.out.print(ele+",");        }        System.out.println("每趟比较前的遍历数据");        for (j=i;j&gt;0&amp;&amp;insertArray[j-1]&gt;temp;j--){ //如果临时值小于要循环的数值，            insertArray[j] =insertArray[j-1]; //需要把当前值往后移位以保证空出一个位置存放临时值        }        insertArray[j] =temp; //把临时值存放到循环比较的j的位置    }    for (int ele:insertArray) {        System.out.print(ele+",");    }    System.out.println("排序完成遍历数据");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">10,11,12,16,2,18,9,5,4,29,11,每趟比较前的遍历数据10,11,12,16,2,18,9,5,4,29,11,每趟比较前的遍历数据10,11,12,16,2,18,9,5,4,29,11,每趟比较前的遍历数据10,11,12,16,2,18,9,5,4,29,11,每趟比较前的遍历数据2,10,11,12,16,18,9,5,4,29,11,每趟比较前的遍历数据2,10,11,12,16,18,9,5,4,29,11,每趟比较前的遍历数据2,9,10,11,12,16,18,5,4,29,11,每趟比较前的遍历数据2,5,9,10,11,12,16,18,4,29,11,每趟比较前的遍历数据2,4,5,9,10,11,12,16,18,29,11,每趟比较前的遍历数据2,4,5,9,10,11,12,16,18,29,11,每趟比较前的遍历数据2,4,5,9,10,11,11,12,16,18,29,排序完成遍历数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="4、快速排序"><a href="#4、快速排序" class="headerlink" title="4、快速排序"></a>4、快速排序</h6><p><img src="https://i.loli.net/2021/04/20/ylPKqaMvrUeJ3Gc.gif" alt="快速排序.gif"></p><p>暂不书写，过程有点复杂，理解排序流程即可。</p><p>选取一个参数为基准，依次进行比较，如果比这个基准大放在不动，如果比这个基准小则移动到前面。</p><h6 id="5、归并排序"><a href="#5、归并排序" class="headerlink" title="5、归并排序"></a>5、归并排序</h6><p><img src="https://i.loli.net/2021/04/20/9dbEuieFLRTmfg8.png" alt="归并排序.png"></p><p>归并排序采用的是归并的思想，即把长的的数组等分分割成小的数组进行排序，最后在一步一步的合成排序。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void main(String []args){      int []arr = {9,5,3,7,1,8,4,2,6};      sort(arr);      System.out.println(Arrays.toString(arr));   }   public static void sort(int []arr){      int []temp = new int[arr.length];//在排序前，先建好一个长度等于原数组长度的临时数组   }   private static void sort(int[] arr,int left,int right,int []temp){      if(left&lt;right){         int mid = (left+right)/2;         sort(arr,left,mid,temp);//左边归并排序，使得左子序列有序         sort(arr,mid+1,right,temp);//右边归并排序，使得右子序列有序         merge(arr,left,mid,right,temp);//将两个有序子数组合并操作         System.out.println(Arrays.toString(arr));      }   }   private static void merge(int[] arr,int left,int mid,int right,int[] temp){      int i = left;//左序列指针      int j = mid+1;//右序列指针      int t = 0;//临时数组指针      while (i&lt;=mid &amp;&amp; j&lt;=right){         if(arr[i]&lt;=arr[j]){            temp[t++] = arr[i++];         }else {            temp[t++] = arr[j++];         }      }      while(i&lt;=mid){//将左边剩余元素填充进temp中         temp[t++] = arr[i++];      }      while(j&lt;=right){//将右序列剩余元素填充进temp中         temp[t++] = arr[j++];      }      t = 0;      //将temp中的元素全部拷贝到原数组中      while(left &lt;= right){         arr[left++] = temp[t++];      }   }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="6、希尔排序"><a href="#6、希尔排序" class="headerlink" title="6、希尔排序"></a>6、希尔排序</h6><p><img src="https://i.loli.net/2021/04/20/LDpPkswzXVyTYjf.png" alt="希尔排序.png"></p><p>希尔排序(Shell’s Sort)是插入排序的一种又称“缩小增量排序”（Diminishing Increment Sort），是直接插入排序算法的一种更高效的改进版本。即把数组按组进行比较，分组步数为数组的长度除以2的n次方，直至余数为1的时候，进行全局排序，可查看下图。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"> public static void main(String []args){         int []arr = {9,5,3,7,1,8,4,2,6};         shellSort(arr);         System.out.println(Arrays.toString(arr));  }  public static void shellSort(int[] arrays) {    //增量每次都/2    for (int step = arrays.length / 2; step &gt; 0; step /= 2) {        //从增量那组开始进行插入排序，直至完毕        for (int i = step; i &lt; arrays.length; i++) {            int j = i;            int temp = arrays[j];            // j - step 就是代表与它同组隔壁的元素            while (j - step &gt;= 0 &amp;&amp; arrays[j - step] &gt; temp) {                arrays[j] = arrays[j - step];                j = j - step;            }            arrays[j] = temp;        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>swagger总结</title>
      <link href="2021/04/20/swagger-zong-jie/"/>
      <url>2021/04/20/swagger-zong-jie/</url>
      
        <content type="html"><![CDATA[<h4 id="Swagger简介"><a href="#Swagger简介" class="headerlink" title="Swagger简介"></a>Swagger简介</h4><h6 id="swagger即是一个接口文档生成工具，也是一个接口调用工具，主要目的是解决前后端的即时交互问题。"><a href="#swagger即是一个接口文档生成工具，也是一个接口调用工具，主要目的是解决前后端的即时交互问题。" class="headerlink" title="swagger即是一个接口文档生成工具，也是一个接口调用工具，主要目的是解决前后端的即时交互问题。"></a>swagger即是一个接口文档生成工具，也是一个接口调用工具，主要目的是解决前后端的即时交互问题。</h6><h6 id="swagger的配置："><a href="#swagger的配置：" class="headerlink" title="swagger的配置："></a>swagger的配置：</h6><ul><li>ApiInfo   文档的简介</li><li>enable    是否启动swagger   以便保证生产环境不启动</li><li>select ().apis ()  可扫描的路径</li><li>select().paths()  可匹配的路径     </li><li>build是固定结束格式</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration@EnableSwagger2  //开启swagger2public class SwaggerConfig {    @Bean    public Docket docket(Environment environment){        //读取application.yml读取的环境        Profiles profiles = Profiles.of("dev","test");        //判断运行的环境是否是可读取的环境        boolean flag = environment.acceptsProfiles(profiles);                return  new Docket(DocumentationType.SWAGGER_2)                .apiInfo(new ApiInfo("小婉Swagger",   //title                                "当一个闲鱼",//description                                "v.1.0",//版本                                "47.100.69.105",    //服务器地址                                new Contact(                                        "小婉",                                        "47.100.69.105",                                        "wlkjava@163.com"                                ),     //个人介绍                                "Apache 2.0",                                "http://www.apache.org/licenses/LICENSE-2.0",                                new ArrayList()                                )                        )                //右上角的命名path                .groupName("learn")                //设置swagger是否启动                .enable(flag)                .select()                //RequestHandlerSelectors.basePackage扫描包下的所有接口                //RequestHandlerSelectors.any扫描所有接口    具体的可查看源码                .apis(RequestHandlerSelectors.basePackage("com.example.swagger.controller"))                //匹配所有符合的路径                .paths(PathSelectors.any())                .build();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="swagger的常用注解"><a href="#swagger的常用注解" class="headerlink" title="swagger的常用注解"></a>swagger的常用注解</h6><ul><li>@ApiModel    用在实体类上的注解</li><li>@ApiModelProperty        用在字段上的注解</li><li>@ApiOperation                 用在方法上的注解</li><li>@ApiParam                       用在入参上的注解</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Data@ApiModel(value = "用户信息表")public class User {    @ApiModelProperty(value = "用户名")    private String userName;    @ApiModelProperty(value = "密码")    private String password;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210123111636040.png" alt="image-20210123111636040"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@ApiOperation("测试")@PostMapping(value = "/test")public String test(@ApiParam(value ="用户名") String  userName){    return userName;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>1、swagger在一些比较难理解的属性或者接口上增加注释信息 （替换了平常书写接口文档的office、wps等）</p><p>2、接口文档实时更新（更易于前后端对接、其各部分之间的对接）</p><p>3、在线测试工具（替换了接口测试工具，如POSTMan等）</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> swagger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射基础</title>
      <link href="2021/04/20/fan-she-ji-chu/"/>
      <url>2021/04/20/fan-she-ji-chu/</url>
      
        <content type="html"><![CDATA[<blockquote><h6 id="正常方式-引入包名、类名-————————-gt-new对象————————-gt-取得实例化对象"><a href="#正常方式-引入包名、类名-————————-gt-new对象————————-gt-取得实例化对象" class="headerlink" title="正常方式: 引入包名、类名_————————>new对象————————>取得实例化对象"></a>正常方式: 引入包名、类名_————————&gt;new对象————————&gt;取得实例化对象</h6></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.annotation.example.demo.controller;import com.annotation.example.demo.entity.Student; //引入类名public class Reflection {    public void test(){        Student student = new Student();  //new对象        student.getAddress(); //获取对象信息    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h6 id="反射方式：-实例化对象—————————-gt-getClass-方法—————————-gt-获取完整的包类信息"><a href="#反射方式：-实例化对象—————————-gt-getClass-方法—————————-gt-获取完整的包类信息" class="headerlink" title="反射方式：  实例化对象—————————>getClass()方法—————————>获取完整的包类信息"></a>反射方式：  实例化对象—————————&gt;getClass()方法—————————&gt;获取完整的包类信息</h6></blockquote><blockquote><h6 id="全路径信息—————————-gt-forName-方法—————————-gt-获取完整的包类信息"><a href="#全路径信息—————————-gt-forName-方法—————————-gt-获取完整的包类信息" class="headerlink" title="全路径信息—————————>forName()方法—————————>获取完整的包类信息"></a>全路径信息—————————&gt;forName()方法—————————&gt;获取完整的包类信息</h6></blockquote><blockquote><h6 id="类名————————————-gt-class——————————————-gt-获取完整的包类信息"><a href="#类名————————————-gt-class——————————————-gt-获取完整的包类信息" class="headerlink" title="类名————————————>.class——————————————>获取完整的包类信息"></a>类名————————————&gt;.class——————————————&gt;获取完整的包类信息</h6></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void main(String[] args) throws ClassNotFoundException {    // 方式1----通过全路径获取student信息    Class c= Class.forName("com.annotation.example.demo.entity.Student");    System.out.println(c.hashCode());    //方式2----通过new对象的getClass()方法获取student信息    Student student = new Student();    Class c2 = student.getClass();    System.out.println(c2.hashCode());    //方式3----通过类名获取student信息    Class c1 = Student.class;    System.out.println(c1.hashCode());}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h6 id="反射获取基本信息：更多方法可自行测试查看"><a href="#反射获取基本信息：更多方法可自行测试查看" class="headerlink" title="反射获取基本信息：更多方法可自行测试查看"></a>反射获取基本信息：更多方法可自行测试查看</h6></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException {    // 方式1----通过全路径获取student信息    Class c= Class.forName("com.annotation.example.demo.entity.Student");    System.out.println(c.hashCode());    //获得包名+类名    System.out.println(c.getName());    //获得类名    System.out.println(c.getSimpleName());    //获取public的信息    Field[] fields = c.getFields();    for (Field field : fields) {        System.out.println(field);    }    //获取全部的信息    Field[] declaredFields = c.getDeclaredFields();    for (Field field : declaredFields) {        System.out.println(field);    }    //获取具体某一个的字段    Field name = c.getDeclaredField("name");    System.out.println(name);    //获取本类的方法及其父类的额所有方法    Method[] methods = c.getMethods();    for (Method method : methods) {        System.out.println(method);    }    //只获取本类的基本信息    Method[] declaredMethods = c.getDeclaredMethods();    for (Method declaredMethod : declaredMethods) {        System.out.println(declaredMethod);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h6 id="常用的获取对象信息的方式"><a href="#常用的获取对象信息的方式" class="headerlink" title="常用的获取对象信息的方式"></a>常用的获取对象信息的方式</h6></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void main(String[] args) throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException {    Class c = Student.class;    //通过newInstance的方式获取对象信息    Student student = (Student) c.newInstance();    student.setName("小婉");    System.out.println(student.getName());    //通过构造器创建对象    Constructor declaredConstructor = c.getDeclaredConstructor(String.class, String.class, int.class);    Student student1 = (Student) declaredConstructor.newInstance("小婉", "驻马店", 30);    System.out.println(student1);    //通过获取方法获得对象信息    Student student2 = (Student) c.newInstance();    Method setName = c.getDeclaredMethod("setName", String.class);   setName.invoke(student2, "小婉");    System.out.println(student2.getName());    //通过反射操作属性    Student student3 = (Student) c.newInstance();    Field name1 = c.getDeclaredField("name");    //不能直接操作私有属性,关闭安全检测，如果反射运用比较多，可以关闭检测提高性能    name1.setAccessible(true);    name1.set(student3,"小婉");    System.out.println(student3.getName());}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h6 id="获取参数类型及返回值类型步骤"><a href="#获取参数类型及返回值类型步骤" class="headerlink" title="获取参数类型及返回值类型步骤"></a>获取参数类型及返回值类型步骤</h6></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void main(String[] args) throws NoSuchMethodException {    Method method = Reflection2.class.getMethod("test1", Map.class, List.class); //获取test1的方法    Type[] types = method.getGenericParameterTypes(); //获取方法内所有的参数    for (Type type : types) {  //便利参数        System.out.println(type); //输出参数        if (type instanceof ParameterizedType){   //查看参数是否属于参数化类型            Type[] typeArguments = ((ParameterizedType) type).getActualTypeArguments();  //把参数强转为参数化类型在获取具体的参数            for (Type typeArgument : typeArguments) {                System.out.println(typeArgument);   //便利参数并打印            }        }    }    Method method1 = Reflection2.class.getMethod("test2");    Type genericReturnType = method1.getGenericReturnType();   //获取返回参数类型    System.out.println(genericReturnType);    if (genericReturnType instanceof ParameterizedType){   //查看参数是否属于参数化类型        Type[] typeArguments = ((ParameterizedType) genericReturnType).getActualTypeArguments();  //把参数强转为参数化类型在获取具体的参数        for (Type typeArgument : typeArguments) {            System.out.println(typeArgument);   //便利参数并打印        }    }}public void test1(Map&lt;String, Student&gt; map, List&lt;Student&gt; list){    System.out.println("test1");}public Map&lt;String,Student&gt; test2(){    System.out.println("test2");    return null;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><h6 id="获取注解的值及参数信息"><a href="#获取注解的值及参数信息" class="headerlink" title="获取注解的值及参数信息"></a>获取注解的值及参数信息</h6></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Reflection3 {    public static void main(String[] args) throws NoSuchFieldException {        classAnnotation annotation = Student2.class.getAnnotation(classAnnotation.class);        System.out.println(annotation.value());        Field name = Student2.class.getDeclaredField("name");        filedAnnotation annotation1 = name.getAnnotation(filedAnnotation.class);        System.out.println(annotation1.id());        System.out.println(annotation1.length());        //db_student//db_id//10      }}@Data@classAnnotation("db_student")class Student2{    @filedAnnotation(id="db_id",length = 10)    private String name;    @filedAnnotation(id="db_address",length = 19)    private String address;    @filedAnnotation(id="db_age",length = 3)    private int age;}/** * 类注解 */@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@interface classAnnotation{    String value();}/** * 字段注解 */@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@interface filedAnnotation{    String id();    int length();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全局捕获日志</title>
      <link href="2021/04/20/quan-ju-bu-huo-ri-zhi/"/>
      <url>2021/04/20/quan-ju-bu-huo-ri-zhi/</url>
      
        <content type="html"><![CDATA[<h6 id="问题：记录所有方法运行时间用来判断哪些方法的书写不规范导致运行时间过长，如果超过规定的秒数-2000ms-则存储到日志表，以便后续优化。"><a href="#问题：记录所有方法运行时间用来判断哪些方法的书写不规范导致运行时间过长，如果超过规定的秒数-2000ms-则存储到日志表，以便后续优化。" class="headerlink" title="问题：记录所有方法运行时间用来判断哪些方法的书写不规范导致运行时间过长，如果超过规定的秒数(2000ms)则存储到日志表，以便后续优化。"></a>问题：记录所有方法运行时间用来判断哪些方法的书写不规范导致运行时间过长，如果超过规定的秒数(2000ms)则存储到日志表，以便后续优化。</h6><p>一、引入常用jar包</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--web依赖 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--lombok --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.projectlombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>lombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>optional</span><span class="token punctuation">&gt;</span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>optional</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--测试依赖--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--aop依赖--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-aop<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--日志依赖 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>log4j<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>log4j<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.2.17<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--swagger依赖 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>io.springfox<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>springfox-swagger2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.9.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--swagger图形页面 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>io.springfox<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>springfox-swagger-ui<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.9.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--mybatisPlus依赖 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.baomidou<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>mybatis-plus-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>3.4.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--mybatisPlus生成代码依赖 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.baomidou<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>mybatis-plus-generator<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>3.4.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--mybatisPlus生成模板前端模板依赖 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.freemarker<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>freemarker<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.3.30<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--mysql依赖 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>5.1.47<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--热部署依赖 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-devtools<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.3.8.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--druid连接池 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>druid<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.0.29<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--hutool工具类 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>cn.hutool<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>hutool-all<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>5.5.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>二、书写aop切入方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Component@Aspect@Slf4jpublic class LogAspectConfig {    @Resource    private LogOverTimeMapper logOverTimeMapper;//设置切入点的值为LogAnnotation注解    //如果嫌注解麻烦，可以配置具体的类上例如：@Pointcut("execution(* com.example.aop.controller.TestController.*(..)) ||     @annotation(com.example.aop.annotation.LogAnnotation)")    @Pointcut(value = "@annotation(com.example.aop.annotation.LogAnnotation)")    public void pointCut(){    }    //使用环绕通知，在方法的执行前后分别记录一个时间相减    @Around("pointCut()")    public Object doLog(ProceedingJoinPoint proceedingJoinPoint){        long startTime = System.currentTimeMillis();        Object object=null;        try {            object=proceedingJoinPoint.proceed();        } catch (Throwable throwable) {            throwable.printStackTrace();            log.info(throwable.getMessage());        }finally {            long endTime = System.currentTimeMillis();            //如果最后时间减去开始时间大于2000ms则插入日志表            if ((endTime-startTime)&gt;new Long(2000)){                LogOverTime logOverTime = new LogOverTime();                logOverTime.setLastDate( LocalDateTime.now());                logOverTime.setLastName("admin");                logOverTime.setMethod(proceedingJoinPoint.getSignature().toShortString());                logOverTime.setRunMillisecond(new Integer((int) (endTime-startTime)));                logOverTimeMapper.insert(logOverTime);            }            log.info(proceedingJoinPoint.getSignature().toShortString() + "方法执行了：" + (endTime - startTime) + "ms");        }        return object;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>三、书写注解LogAnnotation</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Target(value = ElementType.METHOD)@Retention(value = RetentionPolicy.RUNTIME)@Documentedpublic @interface LogAnnotation {}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>四、书写实体类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Data@EqualsAndHashCode(callSuper = false)@ApiModel(value="LogOverTime对象", description="方法超时日志表")public class LogOverTime implements Serializable {    private static final long serialVersionUID = 1L;    @ApiModelProperty(value = "主键自增")    @TableId(value = "id", type = IdType.AUTO)    private Integer id;    @ApiModelProperty(value = "方法")    private String method;    @ApiModelProperty(value = "运行时间")    private Integer runMillisecond;    @ApiModelProperty(value = "最后修改时间")    private LocalDateTime lastDate;    @ApiModelProperty(value = "最后修改人")    private String lastName;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>五、书写Mapper</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//此Mapper用的增强mybatis（mybatis_plus）public interface LogOverTimeMapper extends BaseMapper&lt;LogOverTime&gt; {}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>六、书写测试类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestController@RequestMapping("/testApi")public class TestController {    @LogAnnotation    @PostMapping("/test1")    public String testAop(){        try {            Thread.sleep(1000);        } catch (InterruptedException e) {            e.printStackTrace();        }        return "123132";    }    @LogAnnotation    @PostMapping("/test2")    public void testAop2(){        try {            Thread.sleep(2000);        } catch (InterruptedException e) {            e.printStackTrace();        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义注解</title>
      <link href="2021/04/20/zi-ding-yi-zhu-jie/"/>
      <url>2021/04/20/zi-ding-yi-zhu-jie/</url>
      
        <content type="html"><![CDATA[<h6 id="Target-：用于描述注解的使用范围"><a href="#Target-：用于描述注解的使用范围" class="headerlink" title="@Target ：用于描述注解的使用范围"></a>@Target ：用于描述注解的使用范围</h6><h6 id="Retention：-表示需在该级别保存注释信息，用于描述生命周期，常用的有（SOURCE-lt-CLASS-lt-RUNTIME）"><a href="#Retention：-表示需在该级别保存注释信息，用于描述生命周期，常用的有（SOURCE-lt-CLASS-lt-RUNTIME）" class="headerlink" title="@Retention： 表示需在该级别保存注释信息，用于描述生命周期，常用的有（SOURCE<CLASS<RUNTIME）"></a>@Retention： 表示需在该级别保存注释信息，用于描述生命周期，常用的有（SOURCE&lt;CLASS&lt;RUNTIME）</h6><h6 id="Document-说明该注解被包含在javadoc中"><a href="#Document-说明该注解被包含在javadoc中" class="headerlink" title="@Document : 说明该注解被包含在javadoc中"></a>@Document : 说明该注解被包含在javadoc中</h6><h6 id="inherited：说明之类可以继承父类中的注解"><a href="#inherited：说明之类可以继承父类中的注解" class="headerlink" title="@inherited：说明之类可以继承父类中的注解"></a>@inherited：说明之类可以继承父类中的注解</h6><h6 id="注解参数的注意事项，如果注解的参数只有一个且为value时，可以省略value参数。"><a href="#注解参数的注意事项，如果注解的参数只有一个且为value时，可以省略value参数。" class="headerlink" title="注解参数的注意事项，如果注解的参数只有一个且为value时，可以省略value参数。"></a>注解参数的注意事项，如果注解的参数只有一个且为value时，可以省略value参数。</h6><pre class="line-numbers language-java" data-language="java"><code class="language-java">@MyAnnotations(name="微录客",schools = {"北京大学","清华大学"})public class MyAnnotation {    @MyAnnotations(name="微录客",schools = {"北京大学","清华大学"})    public void test(){    }}@Target(value = {ElementType.METHOD,ElementType.TYPE})       //  描述在方法、包、类上等等@Retention(value = RetentionPolicy.RUNTIME )   //表示该注释的生命周期为@Documented     //该注解包含在文档中@Inherited      //该注解可以被之类继承@interface MyAnnotations{    //注解的参数 如果没有默认值必须在注解上加上该注解的参数，可以为String类型也可以为数组    String name();    String value() default  "";    String [] schools();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>永鑫项目架构搭建</title>
      <link href="2021/04/20/yong-xin-xiang-mu-jia-gou-da-jian/"/>
      <url>2021/04/20/yong-xin-xiang-mu-jia-gou-da-jian/</url>
      
        <content type="html"><![CDATA[<h6 id="一、项目搭建目的"><a href="#一、项目搭建目的" class="headerlink" title="一、项目搭建目的"></a>一、项目搭建目的</h6><p>由于永城收付管理系统速率过慢，代码冗余，因此需一步一步的把永城收付管理系统的永鑫模块单独独立出来。</p><h6 id="二、框架设计"><a href="#二、框架设计" class="headerlink" title="二、框架设计"></a>二、框架设计</h6><ul><li>框架：Springboot微服务为基础，shiro做为权限框架，layui前端框架，模板引擎是thymleaf、orm采用mybatisPlus</li><li>数据库：oracle数据库，druid连接池</li><li>中间件：jwt用作token认证，redis缓存框架，swagger接口展示,quartz定时任务。</li></ul><h6 id="三、项目设计"><a href="#三、项目设计" class="headerlink" title="三、项目设计"></a>三、项目设计</h6><ol><li>权限方面重新设计</li><li>批处理项目取消，统一改成quartz定时任务。</li><li>web项目进行重构</li></ol><h6 id="四、项目注意要点"><a href="#四、项目注意要点" class="headerlink" title="四、项目注意要点"></a>四、项目注意要点</h6><ol><li>采用前后端分离模式，前后端数据传输json格式。</li><li>规定好正确返回、错误返回的信息标志，例（成功0000，失败4000）等标志以方便对接。</li><li>设置全局异常捕获框架以方便异常造成的事故定位。</li><li>全局打印一个方法的运行时间，如果超过规定的时间则记录下来并存入日志中以便后续排查。</li><li>文档设计安装统一格式，且统一上传到永鑫收付文件服务器上以便统一管理。</li></ol><h6 id="五、项目采用版本"><a href="#五、项目采用版本" class="headerlink" title="五、项目采用版本"></a>五、项目采用版本</h6><table><thead><tr><th>springboot</th><th>2.1.8</th></tr></thead><tbody><tr><td>shiro</td><td>1.4.1</td></tr><tr><td>swagger</td><td>2.9.2</td></tr><tr><td>fastjson</td><td>1.2.49</td></tr><tr><td>jwt</td><td>0.9.1</td></tr><tr><td>oracle</td><td>11</td></tr><tr><td>java</td><td>8</td></tr><tr><td>druid</td><td>1.1.10</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux基础命令</title>
      <link href="2021/04/18/linux-ji-chu-ming-ling/"/>
      <url>2021/04/18/linux-ji-chu-ming-ling/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 查看版本信息uname -r# 查看系统版本cat /etc/os-release#centos7的查看关闭开启防火墙命令firewall-cmd --state#查看防火墙状态systemctl stop firewalld.service#停止防火墙systemctl disable firewalld.service #开机自启<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="文件处理命令"><a href="#文件处理命令" class="headerlink" title="文件处理命令"></a>文件处理命令</h6><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 显示目录文件ls # 显示带隐藏的目录文件ls -a# 创建目录mkdir 目录名# 创建文件touch 文件名# 切换目录cd  /目录# 返回上一级目录cd ..# 显示当前目录pwd# 删除空目录rmdir /目录# 复制目录或者文件cp -rp /源文件或者目录 /目标目录# 剪切文件或目录mv /源文件或者目录 /目标目录# 删除文件或目录rm -rf /目录或文件# 查询文件信息cat 文件名  tail -f 文件名  #实时查询信息tail -n 1000 文件名 #倒叙查询1000行信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="权限管理命令"><a href="#权限管理命令" class="headerlink" title="权限管理命令"></a>权限管理命令</h6><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">chmod 参数 文件名#更改文件的读写执行权限  参数有-r -w -x 读 写 执行 u所有人 g所属组 例如：chown U+x 123.logchown 用户 文件名#更改某个文件用户权限用户必须是真实存在的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h6 id="文件查询命令"><a href="#文件查询命令" class="headerlink" title="文件查询命令"></a>文件查询命令</h6><pre class="line-numbers language-SHELL" data-language="SHELL"><code class="language-SHELL">find /目录或文件 -name *init*#查询含有init的文件 *可以匹配任意个字符find /目录或文件 -name *init？？？#一个？只能匹配一个字符<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h6 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h6><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">whoami #查看当前用户useradd -m 账号#新建一个账号passwd 账号#给此账号输入密码userdel -r 账号 #删除账号信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h6 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h6><pre class="line-numbers language-SHELL" data-language="SHELL"><code class="language-SHELL">cal -1 5 2020  #查看2020年5月份的日历wc -lc 文件名 &gt;要创建的文件# 统计某个文件的行数和列数要书写到某个文件wget 远程地址#下载某个文件从远程地址中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker基础</title>
      <link href="2021/04/18/docker-ji-chu/"/>
      <url>2021/04/18/docker-ji-chu/</url>
      
        <content type="html"><![CDATA[<h6 id="docker的默认工作路径是-var-lib-docker"><a href="#docker的默认工作路径是-var-lib-docker" class="headerlink" title="docker的默认工作路径是      /var/lib/docker"></a>docker的默认工作路径是      /var/lib/docker</h6><h6 id="docker的基础是镜像与容器"><a href="#docker的基础是镜像与容器" class="headerlink" title="docker的基础是镜像与容器"></a>docker的基础是镜像与容器</h6><h6 id="docker的官网地址：https-docs-docker-com"><a href="#docker的官网地址：https-docs-docker-com" class="headerlink" title="docker的官网地址：https://docs.docker.com/"></a>docker的官网地址：<a href="https://docs.docker.com/">https://docs.docker.com/</a></h6><h4 id="Docker的基本命令："><a href="#Docker的基本命令：" class="headerlink" title="Docker的基本命令："></a>Docker的基本命令：</h4><pre class="line-numbers language-none"><code class="language-none">docker version    #查看docker的基本信息docker info #显示docker的系统信息，包括镜像和容器镜像docker 命令 --help #docker命令帮助查询12321312<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Docker的镜像常用命令："><a href="#Docker的镜像常用命令：" class="headerlink" title="Docker的镜像常用命令："></a>Docker的镜像常用命令：</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker images -a#查看所有镜像信息docker images -q #查看所有镜像iddocker images -filter ......   #过滤信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="docker搜索镜像："><a href="#docker搜索镜像：" class="headerlink" title="docker搜索镜像："></a>docker搜索镜像：</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker search 服务名称  例如：docker search java  docker search mysqldocker search mysql --filter=stars=200   #查询星数在200以上<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="拉取镜像："><a href="#拉取镜像：" class="headerlink" title="拉取镜像："></a>拉取镜像：</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker pull (镜像名称)：（镜像版本）   #例如  docker pull mysql:5.7   docker pull (镜像名称)#拉取最新版本的镜像信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="删除镜像："><a href="#删除镜像：" class="headerlink" title="删除镜像："></a>删除镜像：</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker rmi -f (镜像id)#删除镜像信息，镜像d可通过docker images进行查询docker rmi -f $（dokcer images） #删除所有镜像信息dokker rmi -f 镜像id 镜像id #删除多个镜像信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="Docker的容器命令："><a href="#Docker的容器命令：" class="headerlink" title="Docker的容器命令："></a>Docker的容器命令：</h4><h6 id="首先我们先下载个centos镜像命令进行学习"><a href="#首先我们先下载个centos镜像命令进行学习" class="headerlink" title="首先我们先下载个centos镜像命令进行学习"></a>首先我们先下载个centos镜像命令进行学习</h6><pre class="line-numbers language-none"><code class="language-none">docker pull centos<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h6 id="容器命令："><a href="#容器命令：" class="headerlink" title="容器命令："></a>容器命令：</h6><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker run [可选参数] image#常用参数--name   #容器名字，用来区分容器-d #后台方式运行-it  #使用交互方式运行，进入容器查看内容-p #指定容器的端口  -p 主机端口：容器端口-P #随机指定端口运行查看容器：docker run -it centos /bin/bash  #进入centosdocker ps #查看正在运行的容器docker ps -a #查看历史运行的容器docker ps -n=？   #查看最近运行的容器,如果加上=？则表示最近几条退出容器：exit #容器停止并退出CTRL+P+Q#容器不停止退出删除容器：docker rm 容器id    #删除非运行的容器，如果运行会报错docker rm -f 容器id#强制删除容器docker rm -f $(docker ps -aq)#删除所有容器id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="启动容器命令："><a href="#启动容器命令：" class="headerlink" title="启动容器命令："></a>启动容器命令：</h6><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker start 容器id#启动容器docker restart 容器id#重启容器docker stop 容器id#停止正在运行的容器docker kill 容器id#强制停止当前容器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h6 id="日志命令："><a href="#日志命令：" class="headerlink" title="日志命令："></a>日志命令：</h6><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker logs -tf tail 10 容器id   #查询后十条日志信息   tail 10 可省略<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h6 id="常用其他命令："><a href="#常用其他命令：" class="headerlink" title="常用其他命令："></a>常用其他命令：</h6><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker top 容器id#查看容器进程docker inspect  容器id#查看容器的基本信息docker exec  -it  容器id /bin/bash#进入正在启动的容器，并开启一个新容器docker attach 容器id#进入正在启动的容器，不会启动新的容器docker cp 容器id:容器内路径 容器外路径  #复制文件从内部容器到外部容器docker stats #查询docker的内存使用率<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="下载nginx镜像到linux服务器"><a href="#下载nginx镜像到linux服务器" class="headerlink" title="下载nginx镜像到linux服务器"></a>下载nginx镜像到linux服务器</h6><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker search nginx #查看镜像docker pull nginx #下载最新版本的镜像docker images#查看下载的容器docker run -d --name nginx01 -p 3344:80 nginx#-d   后台运行# --name 给容器起个名字以便分辨# -p 3344 宿主机端口,即外部端口# 80 内部容器端口即nginx端口 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="下载mysql5-7到linux服务器"><a href="#下载mysql5-7到linux服务器" class="headerlink" title="下载mysql5.7到linux服务器"></a>下载mysql5.7到linux服务器</h6><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#获取mysql镜像docker pull mysql:5.7# -v 卷挂载# -e 环境配置# -d 后台运行# -p 端口映射# --name 给容器命名# 配置mysql地址环境docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql  -e MYSQL_ROOT_PASSWORD=wlk161536 --name mysql01 mysql:5.7#-v的目的是映射到本地 前面的表示宿主机文件，后面表示docker内文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="提交镜像"><a href="#提交镜像" class="headerlink" title="提交镜像"></a>提交镜像</h6><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker commit -m="描述提交的信息" -a="作者" 容器id 目录镜像名:[tags版本]例如：1、先运行一个tomcat镜像docker run -it 容器id /bin/bash2、启动tomcat镜像docker exec -it 容器id /bin/bash3、由于docker中的webApps下没有目录，需要webApps.dist文件复制到webApps下cp -r webApps.dist/* webApps4、把修改后的镜像提交docker commit -m ="添加webbApps信息" -a="moerWolld" 容器id tomcat2:1.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-SHELL" data-language="SHELL"><code class="language-SHELL">#查看镜像的历史构建记录   可查看构造方式仿造一个同样的镜像docker history 镜像id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
