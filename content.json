{"meta":{"title":"摩尔的世界","subtitle":"moleBlog@Wei","description":"本科 | 计算机科学与技术 | 网络安全","author":"摩尔","url":"http://www.luckyzmj.cn","root":"/"},"pages":[{"title":"","date":"2022-04-07T04:13:22.475Z","updated":"2022-04-07T04:13:22.475Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"http://www.luckyzmj.cn/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2022-04-07T04:13:22.348Z","comments":true,"path":"404.html","permalink":"http://www.luckyzmj.cn/404.html","excerpt":"","text":""},{"title":"","date":"2022-04-07T04:13:22.478Z","updated":"2022-04-07T04:13:22.478Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"http://www.luckyzmj.cn/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2022-04-07T04:13:22.474Z","comments":true,"path":"archives/index.html","permalink":"http://www.luckyzmj.cn/archives/index.html","excerpt":"","text":""},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2022-04-07T04:13:22.474Z","comments":true,"path":"about/index.html","permalink":"http://www.luckyzmj.cn/about/index.html","excerpt":"","text":""},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2022-04-07T04:13:22.361Z","comments":true,"path":"List/index.html","permalink":"http://www.luckyzmj.cn/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2022-04-07T04:13:22.476Z","comments":true,"path":"census/index.html","permalink":"http://www.luckyzmj.cn/census/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2022-04-07T04:13:22.476Z","comments":true,"path":"categories/index.html","permalink":"http://www.luckyzmj.cn/categories/index.html","excerpt":"","text":""},{"title":"留言板","date":"2019-10-24T16:00:00.000Z","updated":"2022-04-07T04:13:22.476Z","comments":true,"path":"contact/index.html","permalink":"http://www.luckyzmj.cn/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 Luckeyの友链信息 博客名称: Luckeyの博客 博客网址: http://www.luckyzmj.cn 博客头像: https://s1.ax1x.com/2020/05/17/YRWsYT.png 博客介绍: The harder you work, the luckier you will be"},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2022-04-07T04:13:22.476Z","comments":true,"path":"friends/index.html","permalink":"http://www.luckyzmj.cn/friends/index.html","excerpt":"","text":""},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2022-04-07T04:13:22.478Z","comments":true,"path":"resource/index.html","permalink":"http://www.luckyzmj.cn/resource/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2022-04-07T04:13:22.480Z","comments":true,"path":"tags/index.html","permalink":"http://www.luckyzmj.cn/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2022-04-07T04:13:22.355Z","updated":"2022-04-07T04:13:22.355Z","comments":true,"path":"List/galleries/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2022-04-07T04:13:22.362Z","comments":true,"path":"List/music/index.html","permalink":"http://www.luckyzmj.cn/List/music/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2022-04-07T04:13:22.355Z","updated":"2022-04-07T04:13:22.355Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2022-04-07T04:13:22.355Z","updated":"2022-04-07T04:13:22.355Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2022-04-07T04:13:22.363Z","comments":true,"path":"List/tools/index.html","permalink":"http://www.luckyzmj.cn/List/tools/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2022-04-07T04:13:22.362Z","comments":true,"path":"List/movies/index.html","permalink":"http://www.luckyzmj.cn/List/movies/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2022-04-07T04:13:22.357Z","updated":"2022-04-07T04:13:22.357Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2022-04-07T04:13:22.357Z","updated":"2022-04-07T04:13:22.357Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2022-04-07T04:13:22.358Z","updated":"2022-04-07T04:13:22.358Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2022-04-07T04:13:22.358Z","updated":"2022-04-07T04:13:22.358Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2022-04-07T04:13:22.358Z","updated":"2022-04-07T04:13:22.358Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2022-04-07T04:13:22.359Z","updated":"2022-04-07T04:13:22.359Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2022-04-07T04:13:22.360Z","updated":"2022-04-07T04:13:22.360Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2022-04-07T04:13:22.361Z","updated":"2022-04-07T04:13:22.361Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2022-04-07T04:13:22.360Z","updated":"2022-04-07T04:13:22.360Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2022-04-07T04:13:22.361Z","updated":"2022-04-07T04:13:22.361Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""}],"posts":[{"title":"精句","slug":"精句","date":"2022-04-15T03:02:55.000Z","updated":"2022-04-07T07:08:36.491Z","comments":true,"path":"posts/98a729ec.html","link":"","permalink":"http://www.luckyzmj.cn/posts/98a729ec.html","excerpt":"","text":"知其然并知其所以然，授人以鱼不如授人以渔！学习需慢慢来，不能太过急躁。实践才能出真理，只停留表面就是纸上谈兵。","categories":[{"name":"感悟","slug":"感悟","permalink":"http://www.luckyzmj.cn/categories/%E6%84%9F%E6%82%9F/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://www.luckyzmj.cn/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"springSecurity","slug":"springSecurity","date":"2022-04-12T00:18:52.000Z","updated":"2022-04-21T01:41:22.820Z","comments":true,"path":"posts/b04a945b.html","link":"","permalink":"http://www.luckyzmj.cn/posts/b04a945b.html","excerpt":"","text":"流程图 流程图名词介绍： SecurityContextPersistenceFilter是承接容器的session与spring security的重要filter，主要工作是从session中获取SecurityContext，然后放到上下文中，之后的filter大多依赖这个来获取登录态。其主要是通过HttpSessionSecurityContextRepository来存取的。 UsernamePasswordAuthenticationFilter是登录页面填写用户名和密码的登录请求。 ExceptionTranslationFilter处理过滤器中抛出的任何AccessDeniedException和AuthenticatedException。 FilterSecurityInterceptor负责权限校验的过滤器。","categories":[{"name":"框架","slug":"框架","permalink":"http://www.luckyzmj.cn/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://www.luckyzmj.cn/tags/spring/"}]},{"title":"nacos集群环境搭建","slug":"nacos集群环境搭建","date":"2022-04-08T03:41:33.000Z","updated":"2022-04-07T07:08:36.482Z","comments":true,"path":"posts/11ca7c3b.html","link":"","permalink":"http://www.luckyzmj.cn/posts/11ca7c3b.html","excerpt":"","text":"Nacos搭建集群环境下载所需软件JDK1.8+ Nacos安装包 nginx安装包 安装步骤安装jdk 官网地址: Java Downloads | Oracle 下载 jdk-8u321-linux-x64.tar.gz 导入到linux系统中，并进行解压 配置环境变量 #编辑此文件 vim /etc/profile #在该文件最底部插入，只需要保证java_home的值跟自己的目录对照就可以，其他保持不变 export JAVA_HOME=/usr/local/jdk1.8.0_181 #jdk安装目录 export JRE_HOME=${JAVA_HOME}/jre export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib:$CLASSPATH export JAVA_PATH=${JAVA_HOME}/bin:${JRE_HOME}/bin export PATH=$PATH:${JAVA_PATH} #环境变量有效 source /etc/profile #测试是否成功 java -version 下载nacos#创建文件夹 mkdir nacos # 进入文件夹 cd nacos #下载压缩包 https://pd.zwc365.com为加速地址 wget https://pd.zwc365.com/seturl/https://github.com/alibaba/nacos/releases/download/2.0.3/nacos-server-2.0.3.tar.gz # 解压文件夹，并重命名文件夹,生成3个nacos文件夹分别为nacos8849、nacos8850、nacos8851 tar zxvf nacos-server-2.0.3.tar.gz mv nacos nacos8849 修改nacos配置 #修改nacos的默认数据库为mysql，application.properties server.port=8849 # 修改端口号 spring.datasource.platform=mysql db.num=1 db.url.0=jdbc:mysql://127.0.0.1:3310/nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC db.user.0=root db.password.0=wlk161536 #集群nacos，修改cluster.conf文件 #example 配置三个nacos的IP地址加端口号 122.112.148.42:8849 122.112.148.42:8850 122.112.148.42:8851 #修改启动文件，防止内存溢出startup.sh，修改集群的内存跟单机一样 JAVA_OPT=\"${JAVA_OPT} -server -Xms512m -Xmx512m -Xmn256m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m\" 启动nacos ./startup.sh #关闭则运行shutdown.sh 配置nginx 安装nginx的过程就忽略了 配置nginx.conf文件 upstream clusterNacos{ server 122.112.148.42:8849; server 122.112.148.42:8850; server 122.112.148.42:8851; } server{ listener 8847; server_name localhost; location /nacos/ { proxy_pass http://clusterNacos/nacos; } }","categories":[{"name":"框架","slug":"框架","permalink":"http://www.luckyzmj.cn/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"springCloud","slug":"springCloud","permalink":"http://www.luckyzmj.cn/tags/springCloud/"}]},{"title":"springCloud Alibaba","slug":"SpringCloud Alibaba","date":"2022-04-07T10:11:47.000Z","updated":"2022-04-10T15:26:19.772Z","comments":true,"path":"posts/undefined.html","link":"","permalink":"http://www.luckyzmj.cn/posts/undefined.html","excerpt":"","text":"SpringCloud 阿里系列的官网地址 https://spring-cloud-alibaba-group.github.io/github-pages/greenwich/spring-cloud-alibaba.html 组件介绍 Nacos Discovery 服务注册发现 Nacos Config 动态配置文件 Ribbon 客户端多项目之间负载均衡 OpenFeign 服务之间的调用，更契合SpringMVC Sentinel 流量管理工具，主要是流控、熔断 seata 分布式事务管理工具 gateWay 网关 skyWalking 链路追踪 Nacos DiscoveryNacos提供基于DNS和基于RPC的服务发现，即能被用来支持https/http的服务注册与发现，也支持RPC如dubbo的服务注册与发现。 Nacos是一种去中心化的架构，属于CAP理论里的AP架构，支持最终一致性，在分布式服务发现与注册场景下具有很不错的性能。 Nacos Eureka Consul Zookeeper 一致性协议 CP+AP AP CP CP 健康检查 TCP/HTTP/MYSQL/Client Beat Client TCP/HTTP/gRPC/Cmd Keep Alive 负载均衡策略 权重/ metadata/Selector/Ribbon Ribbon Fabio — 雪崩保护 有 有 无 无 自动注销实例 支持 支持 不支持 支持 访问协议 HTTP/DNS HTTP HTTP/DNS TCP 监听支持 支持 支持 支持 支持 多数据中心 支持 支持 支持 不支持 跨注册中心同步 支持 不支持 支持 不支持 SpringCloud集成 支持 支持 支持 不支持 Dubbo集成 支持 不支持 不支持 支持 K8S集成 支持 不支持 支持 不支 Nacos ConfigApollo 与 Nacos 功能对比 nacos配置文件支持比较多的格式，支持yaml、text、json、xml、html、Properties，apollo只支持xml、text、Properties的格式，没有兼容springboot中比较通用的yaml配置。 apollo用户管理以及权限管理做的比较好和全面，适合做部门或者公司级的配置中心。nacos比较简洁明了（也可以说没有做权限这一块的开发），适合做小组内，或者小型java团体使用。 apollo区分多环境是直接通过环境指定，可以直接对比和切换，而nacos是通过命名空间进行区分的。 nacos是支持多格式的配置文件，但是解析上没有apollo做的好，apollo虽然支持的配置格式较少，不过会进行解析，使每个配置看起来比较直观，修改的时候比较直观，可以对单个进行修改。 Apollo与nacos对比结论 Nacos部署简化，Nacos整合了注册中心、配置中心功能，且部署相比apollo简单，方便管理和监控。 apollo容器化较困难，Nacos有官网的镜像可以直接部署，总体来说，Nacos比apollo更符合KISS原则 性能方面，Nacos读写tps比apollo稍强一些 Ribbon同一个项目中在不同的服务器之间负载均衡的一种策略,常用的策略轮询、权重，不做过多介绍。 OpenFeign微服务调用中更符合开发人员熟悉的接口调用的工具，也不做过多介绍。 Sentinel 什么是服务雪崩 因服务提供者不可用导致服务调用者不可用，并将服务不可用无线扩大的场景的过程称为服务雪崩。 流控规则解释：用于控制访问的数量。 应用场景：洪峰流量（秒杀、大促等一瞬间很多流量的这种），APIGateway精准控制API流量等。 QPS：每秒请求的数量，一般都是用这种方式进行控制 流控模式简介： 直接模式：我们最常用的模式，对某一个接口进行流量控制。 关联模式：两个接口存在竞争（例如数据库插入和读取竞争），则通过限定一个接口的流量来控制，防止竞争耗内存。 链路模式：针对的方法流量控制，即多个接口调用同一个方法时，我们可以让某个接口限制流量，其他接口正常。 流控效果简介： 快速失败：最常用的，就是如果超过流量控制，直接提示失败 warn Up: 预热冷启动模式,例如某个接口一直不调用，突然需要大批量调用，就可以设置为warn Up模式让他慢慢进来防止数据库压垮，当系统中存在缓存后，直接从缓存中查询，防止了数据库瞬间的压力过大导致系统down且能达到系统能访问的最大流量。 排队等待：适用于脉冲流量，简单来说就是脉底的时间充分利用起来执行超出的流量。 熔断降级 降级策略 慢调用介绍：单位时间内如果接口请求的时间超过最大RT，且请求次数不低于5次，比例小于0.1则进行熔断，熔断时长为30s。 最大RT：接口响应最大时长 比例阈值：单位时间内请求次数比例 熔断时长：熔断之后断开的时间 最小请求数：请求接口的最少次数 统计时长：单位时间 异常比例介绍：单位时间内请求次数大于5，比例小于0.1，则进行熔断，熔断时长为30s. 异常数 热点规则针对的是某个接口某一个参数进行流量控制，即对改接口某个值进行一种特定的流控，其他值走原有的流控模式。 常用场景：某个商品的秒杀、ip地址攻击等具有唯一性的瞬间流量场景。 senta分布式事务实现模式: AT(auto transcation)简介：AT模式采用的是把数据库执行前的数据存入before image,执行后的数据存入after image再进行加行级锁，如果程序执行完成正确则释放锁，错误则把after image的数据回滚到before image的状态。 TCC模式简介：根据自己的业务场景实现一段业务逻辑Try、二段确认confirm、二段回滚cancel三个操作。 和AT模式相比：侵入性更强，但不需要增加行级锁。 消息队列实现 GateWay微服务网关的主要意义是指系统的统一入口，它封装了应用程序内部的实现结构，为客户端提供统一的服务，一些业务本身功能无关的公共逻辑一般都在这里实现，例如认证、鉴权、监控、路由转发等。 专业名词 路由id ： 唯一标识，表示路由到具体的那个服务 路由uri ： 需要转发的地址 路由断言predicates-path：跟路由id一个性质 路由过滤filters-StripPrefix：由于判断路由断言时增加一个唯一标识，到达真正的服务需去除该路由id spring: profiles: active: 8088 cloud: gateway: routes: - id: order-route # 路由的唯一标识，路由到具体的服务 uri: localhost:8080 #路由路径，标识具体到那个路径，后续改成nacos predicates: - Path=/order-server/** #标识前缀带有order-server的都路由到这个服务 # http://localhost:8088/order-server/add/order filters: - StrixPrefix=1 #去除上一层的服务即order-server，真正转发的时候路径就变成了http://localhost:8080/add/order skyWalking目的：主要为了解决微服务中出现问题时更快的定位。","categories":[{"name":"框架","slug":"框架","permalink":"http://www.luckyzmj.cn/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"springCloud","slug":"springCloud","permalink":"http://www.luckyzmj.cn/tags/springCloud/"}]},{"title":"poi读写文件","slug":"poi读写文件","date":"2022-04-07T03:40:14.000Z","updated":"2022-04-07T07:08:36.483Z","comments":true,"path":"posts/2202bf79.html","link":"","permalink":"http://www.luckyzmj.cn/posts/2202bf79.html","excerpt":"","text":"谈谈 POI 常用途径 开发中经常会设计到excel的处理，如导出Excel，导入Excel到数据库中！ 操作Excel目前比较流行的就是 Apache POI 和 阿里巴巴的 easyExcel ！ 官网地址 Apache POI 官网：https://poi.apache.org/ POI-Excel写 创建项目 1、建立一个空项目 Bilibili-狂神说java，创建普通Maven的Moudle kuang-poi 2、引入pom依赖 &lt;dependencies&gt; &lt;!--xls(03)--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;3.9&lt;/version&gt; &lt;/dependency&gt; &lt;!--xlsx(07)--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;3.9&lt;/version&gt; &lt;/dependency&gt; &lt;!--日期格式化工具--&gt; &lt;dependency&gt; &lt;groupId&gt;joda-time&lt;/groupId&gt; &lt;artifactId&gt;joda-time&lt;/artifactId&gt; &lt;version&gt;2.10.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--test--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 03、07版本的对象的不一样，但写法不同，都继承于Workbook 03、07的公共类方法 private void createSheet(Workbook workbook ){ //创建工作表 Sheet sheet = workbook.createSheet(\"用户导入案例\"); //创建第一行 Row row = sheet.createRow(0); //创建单元格第一行第一列（1，1） Cell cell11 =row.createCell(0); cell11.setCellValue(\"姓名\"); //创建单元格第一行第二列（1，2） Cell cell12 =row.createCell(1); cell12.setCellValue(\"手机号\"); //创建单元格第一行第三列（1，3） Cell cell13 =row.createCell(2); cell13.setCellValue(\"邮箱\"); //创建第二行 Row row1 = sheet.createRow(1); //创建单元格第一行第一列（2，1） Cell cell21 =row1.createCell(0); cell21.setCellValue(\"位陆坤\"); //创建单元格第一行第二列（2，2） Cell cell22 =row1.createCell(1); cell22.setCellValue(\"17349756393\"); //创建单元格第一行第三列（2，3） Cell cell23 =row1.createCell(2); cell23.setCellValue(\"wlkjava@163.com\"); } 03版本： @Test public void excelWrite03() throws IOException { //创建工作簿 Workbook workbook =new HSSFWorkbook(); //写入工作表 createSheet(workbook); //文件写出 FileOutputStream outputStream = new FileOutputStream(PATH+\"用户导出案例03.xls\"); workbook.write(outputStream); outputStream.close(); } 07版本： @Test public void excelWrite07() throws IOException { //创建工作簿 Workbook workbook =new XSSFWorkbook(); //写入工作表 createSheet(workbook); //文件写出 FileOutputStream outputStream = new FileOutputStream(PATH+\"用户导出案例07.xlsx\"); workbook.write(outputStream); outputStream.close(); } 07增强版： @Test public void excelWrite07S() throws IOException { //创建工作簿 Workbook workbook =new SXSSFWorkbook(); //写入工作表 createSheet(workbook); //文件写出 FileOutputStream outputStream = new FileOutputStream(PATH+\"用户导出案例07S.xlsx\"); workbook.write(outputStream); //如果超过100条会生成临时文件，删除临时文件 ((SXSSFWorkbook)workbook).dispose(); outputStream.close(); } 三则的不同之处 HSSFWorkbook是03版本的excel后缀是xsl，优点速度比较快，但最多只能处理65536行，否则会抛出异常。 XSSFWorkbook是07版本的excel后缀是xslx，优点是可以写入大数据量，但速度比较慢。 SXSSFWorkbook是加强的07版本， 优点：可以写非常大的数据量，如100万条甚至更多条，写数据速度快，占用更少的内存 注意： 过程中会产生临时文件，需要清理临时文件， 默认由100条记录被保存在内存中 POI-excel读读取和写入所使用的接口都是一样， 读取一般都存在则校验，下面是封装的实体类校验： //表头为姓名、手机号、邮箱、出生日期、年龄、金额、备注，其中前六项都为必填，备注可空。 private final static String PATH =\"D:\\\\study\\\\apachePoi\\\\\"; private final static List&lt;String&gt; titleList = Arrays.asList(\"姓名\",\"手机号\",\"邮箱\",\"出生日期\",\"年龄\",\"金额\",\"备注\"); private final static List&lt;Integer&gt; cellList = Arrays.asList( HSSFCell.CELL_TYPE_STRING, HSSFCell.CELL_TYPE_STRING, HSSFCell.CELL_TYPE_STRING, HSSFCell.CELL_TYPE_NUMERIC, HSSFCell.CELL_TYPE_NUMERIC, HSSFCell.CELL_TYPE_NUMERIC); @Test public void excelRead03() throws IOException { //获取流信息 FileInputStream fileInputStream = new FileInputStream(PATH+\"用户导出案例03.xls\"); //把流信息转换成表格 Workbook workbook = new HSSFWorkbook(fileInputStream); //获取表格信息 以下表获取 Sheet sheet = workbook.getSheetAt(0); //获取第一列信息，一般为表头 Row titleRow =sheet.getRow(0); //把表头的字段和定的枚举字段匹配 for (int i = 0; i &lt; titleList.size(); i++) { if(titleRow.getCell(i)==null){ System.out.println(\"第\"+(i+1)+\"列不能为空,请输入：\"+titleRow.getCell(i)); break; } if(!(titleList.get(i)).equals(titleRow.getCell(i).toString())){ System.out.println(\"第\"+(i+1)+\"列的值应为\"+titleList.get(i)); break; } } //获取列数 int rowCount = sheet.getPhysicalNumberOfRows(); //循环获取表数据（不包括表头） for (int rowNum = 1; rowNum &lt;rowCount ; rowNum++) { Row rowData = sheet.getRow(rowNum); if(rowData!=null){ for (int cellNum = 0; cellNum&lt;cellList.size(); cellNum++) { if(rowData.getCell(cellNum)==null){ System.out.println(\"第\"+(rowNum+1)+\"列第\"+(cellNum+1)+\"行的数据为空\"); continue; } if(!cellList.get(cellNum).equals(rowData.getCell(cellNum).getCellType())){ System.out.println(\"类型不匹配\"); } if(cellNum==3 &amp;&amp; !HSSFDateUtil.isCellDateFormatted(rowData.getCell(3))){ System.out.println(\"日期格式不正确类型不匹配\"); } } } } }","categories":[{"name":"项目基础","slug":"项目基础","permalink":"http://www.luckyzmj.cn/categories/%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://www.luckyzmj.cn/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"mybatisPlus基础总结","slug":"mybatisPlus基础总结","date":"2022-04-07T03:38:51.000Z","updated":"2022-04-07T07:08:36.483Z","comments":true,"path":"posts/b3435bfe.html","link":"","permalink":"http://www.luckyzmj.cn/posts/b3435bfe.html","excerpt":"","text":"搭建前准备工作1、创建数据库 DROP TABLE IF EXISTS user; CREATE TABLE user ( id BIGINT( 20 ) NOT NULL COMMENT '主键ID', name VARCHAR( 30 ) NULL DEFAULT NULL COMMENT '姓名', age INT( 11 ) NULL DEFAULT NULL COMMENT '年龄', email VARCHAR( 50 ) NULL DEFAULT NULL COMMENT '邮箱', PRIMARY KEY (id) ); INSERT INTO user (id, name, age, email) VALUES ( 1 , 'Jone', 18 , 'test1@baomidou.com'), ( 2 , 'Jack', 20 , 'test2@baomidou.com'), ( 3 , 'Tom', 28 , 'test3@baomidou.com'), ( 4 , 'Sandy', 21 , 'test4@baomidou.com'), ( 5 , 'Billie', 24 , 'test5@baomidou.com'); -- 真实开发中，version（乐观锁）、deleted（逻辑删除）、gmt_create、gmt_modified 2、引入依赖 &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- mybatis-plus --&gt; &lt;!-- mybatis-plus 是自己开发，并非官方的！ --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.5&lt;/version&gt; &lt;/dependency&gt; 3、数据库链接 # `mysql 5 驱动不同 com.mysql.jdbc.Driver` # `mysql 8 驱动不同com.mysql.cj.jdbc.Driver、需要增加时区的配置` `serverTimezone=GMT%2B` `spring.datasource.username=root` `spring.datasource.password= 123456` `spring.datasource.url=jdbc:mysql://localhost:3306/mybatis_plus?` `useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B` `spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver` 4、实体类 @Data @AllArgsConstructor @NoArgsConstructor public class User { private Long id; private String name; private Integer age; private String email; } 5、mapper层 package com.kuang.mapper; import com.baomidou.mybatisplus.core.mapper.BaseMapper; import com.kuang.pojo.User; import org.springframework.stereotype.Repository; @Repository // 代表持久层集成baseMapper public interface UserMapper extends BaseMapper&lt;User&gt; { } 基本用法配置日志# 配置日志控制台看到打印的日志 mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl 查询方法@SpringBootTest class MybatisPlusApplicationTests { @Autowired private UserMapper userMapper; @Test void contextLoads() { // 参数是一个 Wrapper ，条件构造器，这里我们先不用 null // 查询全部用户 List&lt;User&gt; users = userMapper.selectList(null); /查询单个用户 User user = userMapper.selectOne(id); users.forEach(System.out::println); } } 插入方法@SpringBootTest class MybatisPlusApplicationTests { @Autowired private UserMapper userMapper; @Test void contextLoads() { //自动生成的id会填充到user中，默认填充是雪花算法 int id = userMapper.insert(user); users.forEach(System.out::println); } } 主键生成策略 默认 ID_WORKER 全局唯一id 分布式系统唯一id生成：https://www.cnblogs.com/haoxinyue/p/5208136.html 常用的id方式有以下几种，其中最常用的是雪花算法和主键id自增。 public enum IdType { AUTO(0), // 数据库id自增 NONE(1), // 未设置主键 INPUT(2), // 手动输入 ID_WORKER(3), // 默认的全局唯一id UUID(4), // 全局唯一id uuid ID_WORKER_STR(5); //ID_WORKER 字符串表示法 } 修改操作@Test public void testUpdate(){ User user = new User(); // 注意：updateById是一个对象，相当于静态拼接sql，id作为条件，其他做为修改的内容 int i = userMapper.updateById(user); System.out.println(i); } 自动填充由于开始时间、修改时间每个表所必须的，需抽取出来用自动填充的方式进行修改或者插入，而无需程序员进行操作 1、在字段上加上注解 // 字段添加填充内容 @TableField(fill = FieldFill.INSERT) //插入 private Date createTime; @TableField(fill = FieldFill.INSERT_UPDATE) //插入及修改 private Date updateTime; 2、用处理器处理该注解 package com.kuang.handler; import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler; import lombok.extern.slf4j.Slf4j; import org.apache.ibatis.reflection.MetaObject; import org.springframework.stereotype.Component; import java.util.Date; @Slf4j @Component // 一定不要忘记把处理器加到IOC容器中！ public class MyMetaObjectHandler implements MetaObjectHandler { // 插入时的填充策略 @Override public void insertFill(MetaObject metaObject) { log.info(\"start insert fill.....\"); this.setFieldValByName(\"createTime\",new Date(),metaObject); this.setFieldValByName(\"updateTime\",new Date(),metaObject); } // 更新时的填充策略 @Override public void updateFill(MetaObject metaObject) { log.info(\"start update fill.....\"); this.setFieldValByName(\"updateTime\",new Date(),metaObject); } } 乐观锁1、加上@Version注解 @Version //乐观锁Version注解 private Integer version; 2、扫描我们的mapper // 扫描我们的 mapper 文件夹 @MapperScan(\"com.wlk.study.mapper\") @EnableTransactionManagement @Configuration // 配置类 public class MyBatisPlusConfig { // 注册乐观锁插件 @Bean public OptimisticLockerInterceptor optimisticLockerInterceptor() { return new OptimisticLockerInterceptor(); } } 3、每次进行修改操作时都会把version的值带上进行修改，如果不匹配则插入不成功。 逻辑删除 物理删除 ：从数据库中直接移除 逻辑删除 ：再数据库中没有被移除，而是通过一个变量来让他失效！ deleted = 0 =&gt; deleted = 1 1、增加deleted属性 @TableLogic //逻辑删除 private Integer deleted; 2、添加bean @Bean public ISqlInjector sqlInjector() { return new LogicSqlInjector(); } 3、增加配置 mybatis-plus.global-config.db-config.logic-delete-value=1 mybatis-plus.global-config.db-config.logic-not-delete-value=0 4、测试 @Test public void testUpdate(){ int id =1; //如果不增加上述3步操作，则执行的是物理删除操作，即把原有的数据从数据库移除 //如果增加上述3步操作，则进行逻辑删除，只是把原有的deleted字段从0-1，且查询时不查询为1的数据 int i = userMapper.deleteById(id); System.out.println(i); } 分页查询1、配置拦截器组件即可 // 分页插件 @Bean public PaginationInterceptor paginationInterceptor() { return new PaginationInterceptor(); } 2、测试 // 测试分页查询 @Test public void testPage(){ // 参数一：当前页 // 参数二：页面大小 // 使用了分页插件之后，所有的分页操作也变得简单的！ Page&lt;User&gt; page = new Page&lt;&gt;(2,5); userMapper.selectPage(page,null); page.getRecords().forEach(System.out::println); System.out.println(page.getTotal()); } 性能分析插件/** * SQL执行效率插件 */ @Bean @Profile({\"dev\",\"test\"})// 设置 dev test 环境开启，保证我们的效率 public PerformanceInterceptor performanceInterceptor() { PerformanceInterceptor performanceInterceptor = new PerformanceInterceptor(); performanceInterceptor.setMaxTime(100); // ms设置sql执行的最大时间，如果超过了则不执行且抛出异常 performanceInterceptor.setFormat(true); // 是否格式化代码 return performanceInterceptor; } 条件构造器wapper 官网地址 条件构造器 | MyBatis-Plus (baomidou.com) queryWapper和lambdaQueryWapper的区别 ​ 前者对应的是数据库字段，后者对应的是实体字段。 常用条件构造器eqeq(R column, Object val) eq(boolean condition, R column, Object val) //等于 = //例: eq(\"name\", \"老王\")---&gt;name = '老王' inin(R column, Collection&lt;?&gt; value) in(boolean condition, R column, Collection&lt;?&gt; value) in(R column, Object... values) in(boolean condition, R column, Object... values) inSqlinSql(R column, String inValue) inSql(boolean condition, R column, String inValue) //字段 IN ( sql语句 ) //例: inSql(\"age\", \"1,2,3,4,5,6\")---&gt;age in (1,2,3,4,5,6) //例: inSql(\"id\", \"select id from table where id &lt; 3\")---&gt;id in (select id from table where id &lt; 3) like、notLike、likeLeft、LikeRightlike(R column, Object val) like(boolean condition, R column, Object val) LIKE '%值%' 例: like(\"name\", \"王\")---&gt;name like '%王%'","categories":[{"name":"中间件","slug":"中间件","permalink":"http://www.luckyzmj.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.luckyzmj.cn/tags/mybatis/"}]},{"title":"常用注解汇总","slug":"常用注解汇总","date":"2022-04-03T14:03:19.000Z","updated":"2022-04-07T07:08:36.501Z","comments":true,"path":"posts/881b3a54.html","link":"","permalink":"http://www.luckyzmj.cn/posts/881b3a54.html","excerpt":"","text":"@Qualifier 如果项目中自定义的注解跟底层一样，则可使用次注解来标识项目中运用。","categories":[{"name":"框架","slug":"框架","permalink":"http://www.luckyzmj.cn/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.luckyzmj.cn/tags/SpringBoot/"}]},{"title":"springSummary","slug":"springSummary","date":"2022-04-02T15:09:56.000Z","updated":"2022-04-07T07:08:36.492Z","comments":true,"path":"posts/75ca60a1.html","link":"","permalink":"http://www.luckyzmj.cn/posts/75ca60a1.html","excerpt":"","text":"什么是CAP理论CAP原则又称CAP定理，指的是在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）。 CAP 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾。一般保证容错性，一致性和可用性二选一。 一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本） 可用性（A）：保证每个请求不管成功或者失败都有响应。 分区容忍性（P）：系统中任意信息的丢失或失败不会影响系统的继续运作。 HTTP和RPC的概述Http是根据网络定义的，具有标准语义的通用接口，里面的资源都可被解释。对系统的可用性、伸缩性有更好的支持，而RPC是根据语言的API来定义的。 RPC主要用于公司内部的服务调用，性能消耗低，传输效率高，服务治理方便。HTTP主要用于对外的异构环境，浏览器接口调用，APP接口调用，第三方接口调用等。 HTTP和RPC的异同 RPC，可以基于TCP协议，也可以基于HTTP协议HTTP，基于HTTP协议 RPC，使用自定义的TCP协议，可以让请求报文体积更小，或者使用HTTP2协议，也可以很好的减少报文的体积，提高传输效率HTTP，如果是基于HTTP1.1的协议，请求中会包含很多无用的内容，如果是基于HTTP2.0，那么简单的封装一下是可以作为一个RPC来使用的，这时标准RPC框架更多的是服务治理性能消耗，主要在于序列化和反序列化的耗时 RPC，可以基于thrift实现高效的二进制传输HTTP，大部分是通过json来实现的，字节大小和序列化耗时都比thrift要更消耗性能负载均衡 RPC，基本都自带了负载均衡策略HTTP，需要配置Nginx，HAProxy来实现服务治理（下游服务新增，重启，下线时如何不影响上游调用者） RPC，能做到自动通知，不影响上游HTTP，需要事先通知，修改Nginx/HAProxy配置 SpringCloud和Dubbo的区别微服务的核心要素在于服务的发现、注册、路由、熔断、降级、分布式配置。 综合上述：dubbo属于早期的微服务框架，少了很多组件。而SpringCloud是一种生态，即把微服务架构所需要的组件都整合在一起使用起来更加方面。 dubbo用的是RPC进行通讯，而SpringCLoud用的是HTTP进行通讯。","categories":[{"name":"总结","slug":"总结","permalink":"http://www.luckyzmj.cn/categories/%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://www.luckyzmj.cn/tags/spring/"}]},{"title":"springCloud","slug":"springCloud","date":"2022-04-01T12:37:34.000Z","updated":"2022-04-07T07:08:36.493Z","comments":true,"path":"posts/103896d2.html","link":"","permalink":"http://www.luckyzmj.cn/posts/103896d2.html","excerpt":"","text":"微服务是什么对于微服务，其实没有太多统一定义，通常而言对于微服务架构来说它只是一个架构风格，就是把所有的应用分成一个个独立的模块，每个独立的模块能运行在自己的进程中并各模块之间相互协助，相互通信去完成一个具体的业务。 微服务的优缺点 优点 每个微服务都很小，这样能聚焦一个指定的业务功能或业务需求 微服务能够被小团队单独开发，这个小团队是2到5人的开发人员组成 微服务是松耦合的，是有功能意义的服务，无论是在开发阶段或部署阶段都是独立的 微服务能使用不同的语言开发 微服务易于被一个开发人员理解，修改和维护，这样小团队能够更关注自己的工作成果。无需通过合作才能体现价值 微服务允许你利用融合最新技术 微服务只是业务逻辑的代码，不会和HTML,CSS 或其他界面组件混合 缺点 开发人员要处理系统的复杂性 随着服务器的增加，运维的工作压力增大 系统部署之间存在依赖关系 服务之间通信需要成本 数据的一致性问题 性能的监控等 什么是SpringCloudSpringCloud是一种微服务框架，也可以说是一种生态，它把微服务之间所需要解决的问题的组件融合在一起来实现微服务架构通信，数据传输等。 SpringBoot和SpringCloud的区别 Sprinboot专注于开发单体微服务项目 SpringCloud是关注全局的微服务协调框架，它把Springboot开发的单体微服务项目整合在一起，并为各个服务之间提供通信、注册和发现、断路器、路由等 Springboot可以离开SpringCloud称为一个单体的服务，但是SpringCloud必须依赖于Springboot开发 Springboot专注为于个体，SpringCloud专注于服务治理 SpringCloud Netflix的组件Eureka服务注册及发现 Eureka的两大组件Eureka Server、Eureka Client Eureka Server是提供节点服务的，每个服务启动之后会在Eureka Server中进行注册，服务节点的信息也可通过界面直观的感受 Eureka Client是一个java客户端，用来检测服务是否有效，即每30秒Eureka Client会想Eureka Server发送一个心跳，如果Eureka Server在多个周期内没有接收到心跳，Eureka Server则会把该服务从注册中心移除。默认周期为90s。 获取Eureka Serve中的以已注册的信息 @RestController @RequestMapping(\"/discover\") public class DiscoverController { @Autowired private DiscoveryClient client; @GetMapping(\"/get\") public Object getDiscover(){ //获取所有的服务 List&lt;String&gt; list = client.getServices(); list.forEach(s -&gt; System.out.println(s)); //获取某个服务的信息 List&lt;ServiceInstance&gt; provide8081 = client.getInstances(\"PROVIDE8081\"); provide8081.forEach(serviceInstance -&gt; System.out.println( \"host:\"+serviceInstance.getHost()+\"----------\" +\"instance:\"+serviceInstance.getInstanceId()+\"----------\" +\"port:\"+serviceInstance.getPort()+\"----------\" +\"uri:\"+serviceInstance.getUri()+\"----------\" +\"metadata:\"+serviceInstance.getMetadata() )); return this.client; } } Eureka和zookeeper的区别 Eureka利用的是CAP理论中AP原则，即可用性和容错性。会造成注册中心返回的是几分钟之前的信息。 zookeeper是利用CAP理论中的CP原则，即一致性和容错性。如果主服务器master宕机之后，会存在一个选举的过程，次选举过程会造成服务不可用。 两则相比之下，对于大部分业务逻辑来说，高可用性更强于一致性。 Ribbon负载均衡工具ribbon是NetFlix的开源项目，提供负载均衡算法，将各个中间件信息链接在一起，简单的来说就是列出所有的机器，通过某种算法实现负载均衡。 ribbon和nginx的区别 Nginx 是客户端所有请求统一交给 nginx 进行实现负载均衡请求转发，属于服务器端负载均衡。是一种集中式的负载均衡器。即请求由 nginx 服务器端进行转发。 Ribbon 是从 eureka 注册中心服务器端上获取服务注册信息列表，缓存到本地，然后在本地实现轮询负载均衡策略。即在客户端实现负载均衡。 Nginx 适合于服务器端实现负载均衡 比如 Tomcat Ribbon 适合与在微服务中 RPC 远程调用实现本地服务负载均衡，比如 Dubbo、SpringCloud 中都是采用本地负载均衡。 常用的负载均衡算法 轮询算法 默认 随机算法 权重算法 负载均衡算法的实现接口为IRule类，我们可以自定义算法来做负载均衡。 ribbon和feign的区别 启动类使用的注解不同，Ribbon用的是@RibbonClient，Feign用的是@EnableFeignClients。 服务的指定位置不同，Ribbon是在@RibbonClient注解上声明，Feign则是在定义抽象方法的接口中使用@FeignClient声明。 调用方式不同，Ribbon需要自己构建http请求，模拟http请求然后使用RestTemplate发送给其他服务，步骤相当繁琐。 总的来说feign是面向接口编程更符合开发人员的思想，而ribbon+restTemplate对http进行了封装，形成了一套模板化带调用方式。 hystrix服务熔断 hystrix的简介 Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，已提高分布式系统的弹性。 “ 断路器 ” 本身是一种开关装置，当某个服务单元发送故障之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个符合预期的、可处理的备选响应（FallBack），而不是长时间的等待或抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。 hystrix的特性 服务熔断：熔断是应对雪崩效应的一种微服务链路保护机制。当扇出链路的某个微服务不可用或者响应实践太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后恢复调用链路。在SpringCloud框架里熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定的阈值，缺省是5秒内20次调用失败就会启动熔断机制。熔断机制的注解是HystrixCommand。 服务降级：降级的目的是为了解决整体项目的压力，而牺牲掉某一服务模块而采取的措施。 服务监控：可视化页面观察服务的信息 服务熔断和服务降级的区别 触发原因不太一样，服务熔断一般是某个服务（下游服务）故障引起，而服务降级一般是从整体负荷考虑； 管理目标的层次不太一样，熔断其实是一个框架级的处理，每个微服务都需要（无层级之分），而降级一般需要对业务有层级之分（比如降级一般是从最外围服务开始） zuul服务网关（已停用） 提供统一服务入口，微服务对前台透明 聚合后台服务，节省流量，提升性能 安全，过滤，流控等API管理功能 提供统一服务出口，解耦 SpringCloud gateway服务网关什么是网关 网关是整个微服务API请求的入口，负责拦截所有请求，分发到服务上去。可以实现日志拦截、权限控制、解决跨域问题、限流、熔断、负载均衡，隐藏服务端的ip，黑名单与白名单拦截、授权等，常用的网关有zuul(netflix的，但是已经停更了)和spring cloud gateway (springcloudalibaba)。这里主要讲springcloud gateway，springcloud gateway是一个全新的项目,其基于spring5.0 以及springboot2.0和项目Reactor等技术开发的网关,其主要的目的是为微服务架构提供一种简单有效的API路由管理方式. 过滤器和网关的对比过滤器：对单个服务器的请求进行拦截控制 网关：对所有的服务器的请求进行拦截控制 zuul和spring cloud gateway的对比zuul：是Netflix的，是基于servlet实现的，阻塞式的api即基于servlet实现，不支持长连接。 gateway：是springcloud自己研制的微服务网关，是基于Spring5构建，能够实现响应式非阻塞式的Api，支持长连接 网关与nginx区别相同点：都是可以实现对api接口的拦截，负载均衡、反向代理、请求过滤等，可以实现和网关一样的效果。 不同点：Nginx采用C语言编写，Gateway属于Java语言编写的， 能够更好让我们使用java语言来实现对请求的处理。 Nginx 属于服务器端负载均衡器。 Gateway 属于本地负载均衡器。 gateway的组成路由 : 网关的基本模块，有ID，目标URI，一组断言和一组过滤器组成 断言：就是访问该旅游的访问规则，可以用来匹配来自http请求的任何内容，例如headers或者参数 过滤器：这个就是我们平时说的过滤器，用来过滤一些请求的，gateway有自己默认的过滤器，具体请参考官网，我们也可以自定义过滤器，但是要实现两个接口，ordered和globalfilter","categories":[{"name":"框架","slug":"框架","permalink":"http://www.luckyzmj.cn/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"springCloud","slug":"springCloud","permalink":"http://www.luckyzmj.cn/tags/springCloud/"}]},{"title":"redis进阶","slug":"redis事务","date":"2022-03-30T02:16:21.000Z","updated":"2022-04-07T07:08:36.496Z","comments":true,"path":"posts/d6c4a96f.html","link":"","permalink":"http://www.luckyzmj.cn/posts/d6c4a96f.html","excerpt":"","text":"Redis事务Redis事务本质是一种命令的集合，一个事务中的所有命令都会被序列化，且按照顺序执行！ Redis事务没有隔离级别的概念，即没有mysql的脏读等事情发生 Redis的单条命令是具有原子性的，多条命令不具有原子性 开启事务（multi） 命令入队（。。。。。） 执行事务（exec） #一个完整的事务执行过程 127.0.0.1:6379&gt; MULTI #开启一个事务 OK 127.0.0.1:6379(TX)&gt; set k1 v1 #在事务中执行操作 QUEUED 127.0.0.1:6379(TX)&gt; set k2 v2 QUEUED 127.0.0.1:6379(TX)&gt; get k2 QUEUED 127.0.0.1:6379(TX)&gt; exec #执行事务 1) OK 2) OK 3) \"v2\" #如果在事务中做了取消操作，则所有操作都不会执行，此时具有原子性 127.0.0.1:6379&gt; MULTI #开启事务 OK 127.0.0.1:6379(TX)&gt; set k1 v1 #执行操作 QUEUED 127.0.0.1:6379(TX)&gt; set k2 v2 QUEUED 127.0.0.1:6379(TX)&gt; DISCARD #取消事务 OK 127.0.0.1:6379&gt; get k1 (nil) #编译时异常，即系统检测出的异常，此时具有原子性 27.0.0.1:6379&gt; MULTI #开启事务 OK 127.0.0.1:6379(TX)&gt; set k1 v1 #执行正确操作 QUEUED 127.0.0.1:6379(TX)&gt; set k2 v2 QUEUED 127.0.0.1:6379(TX)&gt; getset k1 #执行错误操作 (error) ERR wrong number of arguments for 'getset' command 127.0.0.1:6379(TX)&gt; get k2 QUEUED 127.0.0.1:6379(TX)&gt; exec #执行事务时提示所有操作都未成功 (error) EXECABORT Transaction discarded because of previous errors. #运行时异常，即系统运行过程中才检测到异常，此时不具有原子性 127.0.0.1:6379&gt; MULTI #开启事务 OK 127.0.0.1:6379(TX)&gt; set k1 v1 #执行正确操作 QUEUED 127.0.0.1:6379(TX)&gt; set k2 v2 QUEUED 127.0.0.1:6379(TX)&gt; incr k1 #执行错误操作，向String中自增 QUEUED 127.0.0.1:6379(TX)&gt; get k2 QUEUED 127.0.0.1:6379(TX)&gt; exec #执行事务，则提示第三步错误，其他都正常运行 1) OK 2) OK 3) (error) ERR value is not an integer or out of range 4) \"v2\" redis的监控 乐观锁是什么 无论什么时候都认为不会出现问题，所以不用上锁，更新数据的适合判断一下是否有人修改过数据即可。 悲观锁是什么 无论什么时候都认为会出现问题，所以执行过程中都会增加一个锁。效率过慢 redis的乐观锁用watch进行表示 #一个正常的操作 127.0.0.1:6379&gt; set money 100 OK 127.0.0.1:6379&gt; set out 0 OK 127.0.0.1:6379&gt; watch money #开启监控 OK 127.0.0.1:6379&gt; MULTI OK 127.0.0.1:6379(TX)&gt; decrby money 60 #减少60 QUEUED 127.0.0.1:6379(TX)&gt; INCRBY out 60 #增加60 QUEUED 127.0.0.1:6379(TX)&gt; exec 1) (integer) 40 2) (integer) 60 #一个错误信息的执行过程 #线程1 127.0.0.1:6379&gt; WATCH money #监控money OK 127.0.0.1:6379&gt; MULTI OK 127.0.0.1:6379(TX)&gt; DECRby money 10 #对money进行操作 QUEUED 127.0.0.1:6379(TX)&gt; INCRBY out 10 QUEUED 127.0.0.1:6379(TX)&gt; exec #执行事务不成功 (nil) #线程2 127.0.0.1:6379&gt; set money 1000 #线程2修改了监控的money OK 127.0.0.1:6379&gt; UNWATCH #取消所有监控信息 OK 设置redis的密码127.0.0.1:6379&gt; config set requirepass 123456 #设置redis的密码 OK 127.0.0.1:6379&gt; exit root@5a78b143c447:/data# redis-cli 127.0.0.1:6379&gt; ping (error) NOAUTH Authentication required. 127.0.0.1:6379&gt; auth 123456 #密码认证 OK 127.0.0.1:6379&gt; ping PONG RDB（redis database）持久化 触发机制产生dump.rdb文件 配置文件中设置的save规则如果满足条件即可触发，例如save 900 1 （如果900s内存在一次更改或添加操作） 执行flushAll命令，也会触发持久化配置产生rdb文件 退出redis也可产生rdb文件。 如何恢复rdb文件 找到rdb文件需识别的目录，启动redis的适合会自动加载 127.0.0.1:6379&gt; config get dir #输出此命令可查看rdb文件所在目录 1) \"dir\" 2) \"/etc\" 优点 适合大规模的数据恢复 对数据的完整性不高 缺点 需要一定的时间间隔进程操作，如果redis意外down了，则最后一次修改的数据就持久化不成功。 fork进行的时候，暂用一定的内存空间。 AOF（append only file）持久化由于redis的默认持久化方式为RDB，需修改配置文件中的APPENDONLY 为YES则表示AOF持久化 AOF持久化产生的文件名为appendOnly.aof文件 AOF持久化的方式有三种： appendfSync always 每次修改都会sync，比较消耗性能 appendfSync everysec 每秒执行一次sync，可能会丢失这1s的数据，默认的方式 appendfSync no 不执行sync，操作系统回自己同步数据，速度最快 优缺点 相对于rdb的方式，数据的完整性更好 相对于rdb的方式，aof的文件远大于rdb文件，修复速度也比rdb慢 运行效率也比rdb慢 Redis消息队列# 消息接收者 127.0.0.1:6379&gt; SUBSCRIBE wei #设置接收数据的频道wei Reading messages... (press Ctrl-C to quit) 1) \"subscribe\" 2) \"wei\" 3) (integer) 1 1) \"message\" #下三步则为接收到数据信息 2) \"wei\" 3) \"123232\" #消息发送者 127.0.0.1:6379&gt; PUBLISH wei 123232 #发送到wei频道信息 (integer) 1 Redis的主从复制 主从复制的概念 主从复制试讲一台Redis服务器复制到其他服务器，前者称为主节点（master/leader),后者称为从节点（slave/follower）;数据的复制是单向的，只能从主节点到从节点，其中master为主，slave为从。 主从复制的作用是什么 数据冗余：实现了数据的热备份，是持久化之外的一种数据冗余模式 故障恢复：当主节点出现问题时，可以有从节点提供服务，实现快速的故障恢复，实际上是一种服务的冗余。 负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，从节点提供读服务，分担服务器负载。 高可用：除了上述作用外，主从复制还采用了哨兵和集群模式，实现了redis的高可用。 127.0.0.1:6379&gt; INFO replication #查看当前redis的机器信息 # Replication role:master #角色信息（主机） connected_slaves:0 #从机数量 127.0.0.1:6379&gt; info replication # Replication role:master #主机标识 connected_slaves:1 #链接的从机数目 slave0:ip=47.101.169.95,port=6379,state=online,offset=14,lag=0 #从机的基本信息 127.0.0.1:6379&gt; info replication # Replication role:slave #从机 master_host:47.100.3.247 #连接到的主机信息 master_port:6379 哨兵模式 哨兵模式的概念 主从切换技术的方法是：当主服务器down后，需要手动选择一台服务器作为主服务器，需要人工干预，费时费力，并且还会造成一段时间的不可用，因此产生一个全新的自动化模式sentinel来解决这个问题。如果主机down，从机则会根据一定的算法选择从机做为主机。如果主机在连接则只能作为从机，主机还是原来推举出来的。 哨兵的作用 通过发送命令，检测主服务器和从服务器的运行状态 当master宕机，会自动将slave转换为master，然后通知其他服务器，修改配置文件，让他们切换主机。 哨兵也可能存在down的可能，因此会布置多个哨兵互相监控。 哨兵配置 1、配置sentinel.conf # sentinel monitor myredis host port 1 sentinel monitor myredis 47.100.3.247 6379 1 #1表示主机挂了，slave投票谁最多谁成为主机 #具体的配置后续再了解，目前只配置最基础的配置 2、启动哨兵 redis-sentinel sentinel.conf 优点： 哨兵集群，基于主从复制模式，所有的主从配置有点都拥有 主从可以切换，故障可以转移，系统的可用性会更好 哨兵模式是主从模式的升级，手动改为自动更加的健壮 缺点： 哨兵模式的扩容非常麻烦 配置相对来说比较麻烦","categories":[{"name":"中间件","slug":"中间件","permalink":"http://www.luckyzmj.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://www.luckyzmj.cn/tags/redis/"}]},{"title":"redis特殊数据类型","slug":"redis特殊数据类型","date":"2022-03-30T00:28:15.000Z","updated":"2022-04-07T07:08:36.493Z","comments":true,"path":"posts/1e9fc50d.html","link":"","permalink":"http://www.luckyzmj.cn/posts/1e9fc50d.html","excerpt":"","text":"geospatial地理位置应用场景: 朋友圈定位、附近的距离、地理位置的计算 常用命令： geoadd 添加经纬度信息 geopos 查询经纬度信息 geodist 查询两个位置直接的直线距离 geoRadius 查询某个坐标下（经度、维度）的所有位置信息 georadiusBymember 查询某个坐标下（集合内的数据）的位置信息 geohash 返回某个城市的一维数据，11位 #顺序为key、经度、维度、城市 #有效的经度从-180度到180度。 #有效的纬度从-85.05112878度到85.05112878度。 #如果超过则会提示如下错误 127.0.0.1:6379&gt; GEOADD china:city 116.405289 39.904987 beijing #添加地理位置信息 (integer) 1 127.0.0.1:6379&gt; GEOADD china:city 117.190186 39.125595 tianqing 114.502464 38.045475 shijiazhuang 126.642464 45.756966 haerbing 121.472641 31.231707 shanghai (integer) 4 127.0.0.1:6379&gt; GEOADD china:city 113.374375 23.368923 guangzhou (integer) 1 127.0.0.1:6379&gt; keys * 1) \"china:city\" 127.0.0.1:6379&gt; GEOADD china:city 23.368923 113.374375 guangzhou #位置信息添加错误提示 (error) ERR invalid longitude,latitude pair 23.368923,113.374375 127.0.0.1:6379&gt; GEOPOS china:city beijing tianqing #查看当前经纬度的值 1) 1) \"116.40528827905654907\" 2) \"39.90498588819134085\" 2) 1) \"117.19018846750259399\" 2) \"39.12559461779084558\" #获取两人之间的距离 127.0.0.1:6379&gt; GEODIST china:city beijing tianqing km #获取两地之间的距离，单位为km \"109.7753\" #查询附近的人 key、经度、维度、半径、单位、直接距离、总数 127.0.0.1:6379&gt; GEORADIUS china:city 100 30 1000 km withdist count 3 #查询某个经纬度内半径为1000km的地点3个位置 (empty array) #查询以某个集合内的位置作为基础半径内的位置信息 127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city beijing 500 km withdist 1) 1) \"shijiazhuang\" 2) \"264.2750\" 2) 1) \"tianqing\" 2) \"109.7753\" 3) 1) \"beijing\" 2) \"0.0000\" #获取某个城市的一维字符串 127.0.0.1:6379&gt; GEOHASH china:city beijing 1) \"wx4g0b7xru0\" 127.0.0.1:6379&gt; GEOHASH china:city shanghai guangzhou 1) \"wtw3sjt9vs0\" 2) \"ws0sgyhty70\" 地理位置的底层实现是根据zset进行操作的。 127.0.0.1:6379&gt; ZRAnge china:city 0 -1 #查询所有的经纬度信息 1) \"guangzhou\" 2) \"shanghai\" 3) \"shijiazhuang\" 4) \"tianqing\" 5) \"beijing\" 6) \"haerbing\" 127.0.0.1:6379&gt; zrem china:city beijing #删除某个经纬度信息 (integer) 1 127.0.0.1:6379&gt; ZRAnge china:city 0 -1 1) \"guangzhou\" 2) \"shanghai\" 3) \"shijiazhuang\" 4) \"tianqing\" 5) \"haerbing\" Hyperloglog数据类型优点：占用的内存是固定的，可以存取2的64个不同的元素，只需要12kb的内存。 缺点：是有0.81%的错误率，一般可以忽略不计。 目的：处理集合中不同的元素总数，跟set的用途一致。 pfadd 添加元素 pfcount 计算元素总数 pfmegre 合并两个元素为一个全新的元素 127.0.0.1:6379&gt; PFADD key a b c d e f g h i j k #向集合中添加元素 (integer) 1 127.0.0.1:6379&gt; PFCOUNT key #查看当前集合的元素总数 (integer) 11 127.0.0.1:6379&gt; PFADD key1 f f n f e p o #重复元素的按1计算 (integer) 1 127.0.0.1:6379&gt; PFCOUNT key1 (integer) 5 127.0.0.1:6379&gt; PFMERGE key2 key key1 #合并两个key的元素为最新的key OK 127.0.0.1:6379&gt; PFCOUNT key2 (integer) 14 BItMaps数据类型表示位运算，一般应用场景是统计某个事情的真总数，以判断是否成立，例如：统计某员工一个月内的打卡次数 setbit key offset 0/1 给某个key设置一个事件，用0表示假、1表示真 getbit key offset 获取这个key值的事件状态即0/1 bitcount key 查询某个key的真事件的总数 127.0.0.1:6379&gt; setbit key 1 0 #设置某个元素的某种事件值是0或者1 (integer) 0 127.0.0.1:6379&gt; setbit key 2 1 (integer) 0 127.0.0.1:6379&gt; setbit key 2 0 (integer) 1 127.0.0.1:6379&gt; getbit key 2 #获取该元素的事件状态 (integer) 0 127.0.0.1:6379&gt; setbit key 3 0 (integer) 0 127.0.0.1:6379&gt; BITCOUNT key #获取某个元素的为1的时间总数 (integer) 0 127.0.0.1:6379&gt; setbit key 3 1 (integer) 0 127.0.0.1:6379&gt; BITCOUNT key (integer) 1","categories":[{"name":"中间件","slug":"中间件","permalink":"http://www.luckyzmj.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://www.luckyzmj.cn/tags/redis/"}]},{"title":"redis常用命令","slug":"redis常用命令","date":"2022-03-29T13:42:36.000Z","updated":"2022-04-07T07:08:36.497Z","comments":true,"path":"posts/c3982ec0.html","link":"","permalink":"http://www.luckyzmj.cn/posts/c3982ec0.html","excerpt":"","text":"redis的命令查找网址http://www.redis.cn/commands.html redis的基本命令127.0.0.1:6379&gt; FLUSHALL #清空所有数据库 OK 127.0.0.1:6379&gt; set name '123' #设置key为name的值 OK 127.0.0.1:6379&gt; set age 1 #设置key为age的值 OK 127.0.0.1:6379&gt; get name #获取key为name的值，如果不存在key值则返回nil。 \"123\" 127.0.0.1:6379&gt; gea age (error) ERR unknown command `gea`, with args beginning with: `age`, 127.0.0.1:6379&gt; get age #获取key为age的值 \"1\" 127.0.0.1:6379&gt; EXISTS naem #查询是否存在此key值，存在返回1，否则返回0 (integer) 0 127.0.0.1:6379&gt; EXISTS name (integer) 1 127.0.0.1:6379&gt; move name 1 #移除key值，成功返回1，失败返回0 (integer) 1 127.0.0.1:6379&gt; keys * #查询当前存在的key值 1) \"age\" 127.0.0.1:6379&gt; EXPIRE age 15 #设置key值得过期时间 (integer) 1 127.0.0.1:6379&gt; ttl name (integer) -2 127.0.0.1:6379&gt; ttl age #查看当前key的剩余时间，如果key值不存在则返回-2 (integer) 7 127.0.0.1:6379&gt; ttl age (integer) 4 127.0.0.1:6379&gt; ttl age (integer) -2 127.0.0.1:6379&gt; type age #查看key值得返回类型 String String基本数据类型127.0.0.1:6379&gt; FLUSHALL OK 127.0.0.1:6379&gt; keys * (empty array) 127.0.0.1:6379&gt; set key1 1 OK 127.0.0.1:6379&gt; get key1 \"1\" 127.0.0.1:6379&gt; EXISTS key1 (integer) 1 127.0.0.1:6379&gt; EXISTS key1 (integer) 1 127.0.0.1:6379&gt; EXISTS key2 (integer) 0 127.0.0.1:6379&gt; APPEND key1 2 #给某个key追加一个值，如果当前值不存在则创建当前key，返回的当前value的长度 (integer) 2 127.0.0.1:6379&gt; keys * 1) \"key1\" 127.0.0.1:6379&gt; get key1 \"12\" 127.0.0.1:6379&gt; STRLEN key1 #查看当前key的长度 (integer) 2 127.0.0.1:6379&gt; append key1 '321321' (integer) 8 127.0.0.1:6379&gt; STRLEN key1 (integer) 8 127.0.0.1:6379&gt; get key1 \"12321321\" 127.0.0.1:6379&gt; set view 0 OK 127.0.0.1:6379&gt; get view \"0\" 127.0.0.1:6379&gt; incr view #给某个字段字段增加1 (integer) 1 127.0.0.1:6379&gt; incr view (integer) 2 127.0.0.1:6379&gt; incr view (integer) 3 127.0.0.1:6379&gt; decr view #给某个字段自动减少1 (integer) 2 127.0.0.1:6379&gt; INCRBY view 10 #给某个字段增加10 (integer) 12 127.0.0.1:6379&gt; INCRBY view 10 (integer) 22 127.0.0.1:6379&gt; decrby view 5 #给某个字段减少5 (integer) 17 127.0.0.1:6379&gt; incr key1 #如果自增的数据不是Integer类型则提示错误 (error) ERR value is not an integer or out of range 127.0.0.1:6379&gt; set key1 abcde OK 127.0.0.1:6379&gt; get key1 \"abcde\" 127.0.0.1:6379&gt; GETRANGE key1 0 3 #获取下表0-3的数据 \"abcd\" 127.0.0.1:6379&gt; GETRANGE key1 0 -1 #获取全部的数据 \"abcde\" 127.0.0.1:6379&gt; SETRANGE key1 0 111 #从下表为0开始替换数据，长度为值得长度 (integer) 5 127.0.0.1:6379&gt; get key1 \"111de\" 127.0.0.1:6379&gt; clear 127.0.0.1:6379&gt; keys * 1) \"key1\" 127.0.0.1:6379&gt; get key1 \"111de\" 127.0.0.1:6379&gt; SETNX key1 'abcde' #设置某个值如果存在则不替换，不存在则添加 (integer) 0 127.0.0.1:6379&gt; get key1 \"111de\" 127.0.0.1:6379&gt; SETEX key1 30 abcde #设置某个值存在即替换，不存在则添加，且设置其过去时间为30s. OK 127.0.0.1:6379&gt; get key1 \"abcde\" 127.0.0.1:6379&gt; ttl key1 #查看剩余时间，如果过期或者不存在则返回0 (integer) 22 127.0.0.1:6379&gt; ttl key1 (integer) 0 127.0.0.1:6379&gt; keys * (empty array) 127.0.0.1:6379&gt; FLUSHdb OK 127.0.0.1:6379&gt; keys * (empty array) 127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3 #设置多个key/value值 OK 127.0.0.1:6379&gt; keys * 1) \"k3\" 2) \"k2\" 3) \"k1\" 127.0.0.1:6379&gt; mset k1 v1 k4 v4 #设置多个，如果存在则替换，不存在则添加 OK 127.0.0.1:6379&gt; keys * 1) \"k3\" 2) \"k2\" 3) \"k1\" 4) \"k4\" 127.0.0.1:6379&gt; MSETNX k1 v1 k5 v5 #设置多个，如果存在则全部失败，因为redis具有原子性。 (integer) 0 127.0.0.1:6379&gt; keys * 1) \"k3\" 2) \"k2\" 3) \"k1\" 4) \"k4\" 127.0.0.1:6379&gt; get k5 (nil) 127.0.0.1:6379&gt; GETSET db redis #获取key值并设置key值，返回值为实现get的key值 (nil) 127.0.0.1:6379&gt; get db \"redis\" 127.0.0.1:6379&gt; getset db mysql \"redis\" 127.0.0.1:6379&gt; get db \"mysql\" List基本数据类型127.0.0.1:6379&gt; FLUSHdb OK 127.0.0.1:6379&gt; keys * (empty array) 127.0.0.1:6379&gt; LPUSH list a b c #从左侧插入一直list，返回的是当前集合的长度 (integer) 3 127.0.0.1:6379&gt; lpush list d e (integer) 5 127.0.0.1:6379&gt; RPUSH list f g #从右侧插入一个list (integer) 7 127.0.0.1:6379&gt; LRANGE list 0 -1 #获取list的所有值 1) \"e\" 2) \"d\" 3) \"c\" 4) \"b\" 5) \"a\" 6) \"f\" 7) \"g\" 127.0.0.1:6379&gt; LRANGE list 1 5 #获取list下标为1-5的值 1) \"d\" 2) \"c\" 3) \"b\" 4) \"a\" 5) \"f\" 127.0.0.1:6379&gt; RPOP list #移除右边的第一个元素 \"g\" 127.0.0.1:6379&gt; RPOP list 2 #移除右边的2个元素 1) \"f\" 2) \"a\" 127.0.0.1:6379&gt; LPOP list 2 #移除左边边的2个元素 1) \"b\" 2) \"c\" 127.0.0.1:6379&gt; LRANGE list 0 -1 1) \"e\" 2) \"d\" 127.0.0.1:6379&gt; LINDEX list 1 #获取当前集合下标为1的元素 \"d\" 127.0.0.1:6379&gt; LLEN list #获取list集合的长度 (integer) 2 127.0.0.1:6379&gt; LRANGE list 0 -1 1) \"e\" 2) \"d\" 127.0.0.1:6379&gt; LPUSH list e #王list中添加一个重复元素 (integer) 3 127.0.0.1:6379&gt; LREM list 2 e #删除list中为e的元素，且值的个数为2 (integer) 2 127.0.0.1:6379&gt; LRANGE list 0 -1 1) \"d\" 127.0.0.1:6379&gt; FLUSHdb OK 127.0.0.1:6379&gt; keys * (empty array) 127.0.0.1:6379&gt; clear 127.0.0.1:6379&gt; lpush list hello1 (integer) 1 127.0.0.1:6379&gt; lpush list hello2 (integer) 2 127.0.0.1:6379&gt; lpush list hello2 (integer) 3 127.0.0.1:6379&gt; lpush list hello3 (integer) 4 127.0.0.1:6379&gt; lpush list hello4 (integer) 5 127.0.0.1:6379&gt; LREM list 1 hello 2 (error) ERR wrong number of arguments for 'lrem' command 127.0.0.1:6379&gt; LREM list 1 hello2 (integer) 1 127.0.0.1:6379&gt; LRANGE list 0 -1 1) \"hello4\" 2) \"hello3\" 3) \"hello2\" 4) \"hello1\" 127.0.0.1:6379&gt; LPUSH list hello5 (integer) 5 127.0.0.1:6379&gt; LRANGE list 0 -1 1) \"hello5\" 2) \"hello4\" 3) \"hello3\" 4) \"hello2\" 5) \"hello1\" 127.0.0.1:6379&gt; LTRIM list 1 2 #截取当前key的下标为1到2的值 OK 127.0.0.1:6379&gt; LRANGE list 0 -1 1) \"hello4\" 2) \"hello3\" 127.0.0.1:6379&gt; RPOPLPUSH list mylist #截取list右侧第一个元素把他存入到mylist的最左侧 \"hello3\" 127.0.0.1:6379&gt; LRANGE list 0 -1 #查看list的所有值 1) \"hello4\" 127.0.0.1:6379&gt; LRANGE mylist 0 -1 #查看mylist的所有值 1) \"hello3\" 127.0.0.1:6379&gt; FLUSHdb OK 127.0.0.1:6379&gt; EXISTS list #查看是否存在当前key值 (integer) 0 127.0.0.1:6379&gt; lset list 0 redis #往当前key值中set一个下标为0的数据，如果不存在则提示错误，存在则替换 (error) ERR no such key 127.0.0.1:6379&gt; LPUSH list mysql (integer) 1 127.0.0.1:6379&gt; lset list 0 redis OK 127.0.0.1:6379&gt; LRANGE list 0 -1 1) \"redis\" 127.0.0.1:6379&gt; lset list 1 redis (error) ERR index out of range ############################################## 127.0.0.1:6379&gt; LRANGE list 0 -1 1) \"redis\" 127.0.0.1:6379&gt; lpush list myql (integer) 2 127.0.0.1:6379&gt; LRANGE list 0 -1 1) \"myql\" 2) \"redis\" 127.0.0.1:6379&gt; LINSERT list before 'mysql' mysql1 (integer) -1 127.0.0.1:6379&gt; LRANGE list 0 -1 1) \"myql\" 2) \"redis\" 127.0.0.1:6379&gt; LINSERT list after 'mysql' mysql1 (integer) -1 127.0.0.1:6379&gt; LRANGE list 0 -1 1) \"myql\" 2) \"redis\" 127.0.0.1:6379&gt; keys * 1) \"list\" 127.0.0.1:6379&gt; LRANGE list 0 -1 1) \"myql\" 2) \"redis\" 127.0.0.1:6379&gt; LINSERT list after \"redis\" \"mysql1\" #往某个key得之前或之后插入一个值，值不能是下标为0的数据。 (integer) 3 127.0.0.1:6379&gt; LRANGE list 0 -1 1) \"myql\" 2) \"redis\" 3) \"mysql1\" 127.0.0.1:6379&gt; LINSERT list before \"redis\" \"mysql1\" (integer) 4 127.0.0.1:6379&gt; LRANGE list 0 -1 1) \"myql\" 2) \"mysql1\" 3) \"redis\" 4) \"mysql1\" 127.0.0.1:6379&gt; LINSERT list before \"mysql\" \"mysql1\" (integer) -1 127.0.0.1:6379&gt; LINSERT list after \"mysql\" \"mysql1\" (integer) -1 Set基本数据类型127.0.0.1:6379&gt; sadd key hello #向key值添加一个元素，如果存在，则返回0，如果不存在则返回1 (integer) 1 127.0.0.1:6379&gt; sadd key world (integer) 1 127.0.0.1:6379&gt; sadd key world (integer) 0 127.0.0.1:6379&gt; SMEMBERS key #查看key的所有元素 1) \"world\" 2) \"hello\" 127.0.0.1:6379&gt; SISMEMBER key hellp #查看当前key是否存在某个值，如果存在则返回1，不存在则返回0 (integer) 0 127.0.0.1:6379&gt; SISMEMBER key hello (integer) 1 127.0.0.1:6379&gt; scard key #查看当前key的所有值 (integer) 2 127.0.0.1:6379&gt; SREM key hello #移除某个元素，如果原有元素存在则返回1，原有元素不存在则返回0 (integer) 1 27.0.0.1:6379&gt; SMEMBERS key 1) \"world\" 127.0.0.1:6379&gt; Sadd key 1 (integer) 1 127.0.0.1:6379&gt; Sadd key 2 (integer) 1 127.0.0.1:6379&gt; Sadd key 3 (integer) 1 127.0.0.1:6379&gt; SMEMBERS key 1) \"3\" 2) \"1\" 3) \"world\" 4) \"2\" 127.0.0.1:6379&gt; SRANDMEMBER key #随机抽取一个key值 \"world\" 127.0.0.1:6379&gt; SRANDMEMBER key \"world\" 127.0.0.1:6379&gt; SRANDMEMBER key \"1\" 127.0.0.1:6379&gt; SRANDMEMBER key \"2\" 127.0.0.1:6379&gt; SRANDMEMBER key \"world\" 127.0.0.1:6379&gt; SRANDMEMBER key \"3\" 127.0.0.1:6379&gt; SRANDMEMBER key 2 #随机抽取指定个数key值 1) \"3\" 2) \"2\" 127.0.0.1:6379&gt; SPOP key #随机删除一个元素，也可跟个数 \"2\" 127.0.0.1:6379&gt; SPOP key \"1\" 127.0.0.1:6379&gt; SMEMBERS key 1) \"3\" 2) \"world\" 127.0.0.1:6379&gt; FLUSHdb OK 127.0.0.1:6379&gt; sadd key 1 (integer) 1 127.0.0.1:6379&gt; sadd key 2 3 4 5 (integer) 4 127.0.0.1:6379&gt; SMOVE key key1 2 #把某个key的值移动另外一个key中 (integer) 1 127.0.0.1:6379&gt; keys * 1) \"key\" 2) \"key1\" 127.0.0.1:6379&gt; SMEMBERS key 1) \"1\" 2) \"3\" 3) \"4\" 4) \"5\" 127.0.0.1:6379&gt; SMEMBERS key1 1) \"2\" 127.0.0.1:6379&gt; sadd key1 1 3 4 (integer) 3 127.0.0.1:6379&gt; SMEMBERS key #查询key的value值 1) \"1\" 2) \"3\" 3) \"4\" 4) \"5\" 127.0.0.1:6379&gt; SMEMBERS key1 1) \"1\" 2) \"2\" 3) \"3\" 4) \"4\" 127.0.0.1:6379&gt; sdiff key key1 #以key为基准，求两个key的差集 1) \"5\" 127.0.0.1:6379&gt; SINTER key key1 #求两个集合的交集 1) \"1\" 2) \"3\" 3) \"4\" 127.0.0.1:6379&gt; SUNION key key1 #求两个集合的并集 1) \"1\" 2) \"2\" 3) \"3\" 4) \"4\" 5) \"5\" Hash的基本命令（key-(key-value)127.0.0.1:6379&gt; hset hash key 1 #向某个key值中添加一个key/value键值对 其中外层key为hash,内层key为key，value为1 (integer) 1 127.0.0.1:6379&gt; hset hash key 1 key1 2 key2 3 #向key值hash中添加多个元素 (integer) 2 127.0.0.1:6379&gt; HGET hash key #获取hash中的key的值 \"1\" 127.0.0.1:6379&gt; HMGET hash key key1 key2 #获取多个值 1) \"1\" 2) \"2\" 3) \"3\" 127.0.0.1:6379&gt; HGETALL hash #获取hash的所有key、value信息 1) \"key\" 2) \"1\" 3) \"key1\" 4) \"2\" 5) \"key2\" 6) \"3\" 127.0.0.1:6379&gt; HDEL hash key key1 #删除hash的key和key1的值 (integer) 2 127.0.0.1:6379&gt; HGETALL hash 1) \"key2\" 2) \"3\" 127.0.0.1:6379&gt; HLEN hash #获取hash的键值对总数 (integer) 1 127.0.0.1:6379&gt; HEXISTS hash key1 #查看hash中是否存在某个key值，如果存在返回1，如果不存在返回0 (integer) 0 127.0.0.1:6379&gt; HGETALL hash 1) \"key2\" 2) \"3\" 127.0.0.1:6379&gt; HEXISTS hash key2 (integer) 1 127.0.0.1:6379&gt; HKEYS hash #获取hash里面所有的key值 1) \"key2\" 127.0.0.1:6379&gt; HVALS hash #获取hash中所有value值 1) \"3\" 127.0.0.1:6379&gt; hset hash key3 5 (integer) 1 127.0.0.1:6379&gt; HKEYS hash 1) \"key2\" 2) \"key3\" 127.0.0.1:6379&gt; HVALS hash 1) \"3\" 2) \"5\" 127.0.0.1:6379&gt; HINCRBY hash key3 5 #给hash的key3值增加5 (integer) 10 127.0.0.1:6379&gt; HINCRBY hash key3 -1 #给hash的key3值增加-1 (integer) 9 127.0.0.1:6379&gt; HSETNX hash key3 8 #如果存在则给某个key添加至，不存在则返回0. (integer) 0 Hset的基础类型127.0.0.1:6379&gt; zadd salary 800 lk #向某个元素添加至，其中key为salary,800为位置，即排序的标准 (integer) 1 127.0.0.1:6379&gt; zadd salary 900 wl 1000 ml (integer) 2 127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf +inf #查看所有的value值， 1) \"lk\" 2) \"wl\" 3) \"ml\" 127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf 900 withscores #查看小于900的value值，显示score 1) \"lk\" 2) \"800\" 3) \"wl\" 4) \"900\" 127.0.0.1:6379&gt; ZRAnge salary 0 -1 #查询所有key值，无排序，按插入顺序 1) \"lk\" 2) \"wl\" 3) \"ml\" 127.0.0.1:6379&gt; ZRem salary lw #移除某个元素，如果存在返回1，不存在返回0 (integer) 0 127.0.0.1:6379&gt; ZRem salary lk (integer) 1 127.0.0.1:6379&gt; ZRAnge salary 0 -1 1) \"wl\" 2) \"ml\" 127.0.0.1:6379&gt; ZCARD salary #获取集合中的个数 (integer) 2 127.0.0.1:6379&gt; ZREVRANGE salary 0 -1 withscores #按socre从大到小排序 1) \"ml\" 2) \"1000\" 3) \"wl\" 4) \"900\" 127.0.0.1:6379&gt; ZCOUNT salary 0 900 #获取集合内的总数 (integer) 1","categories":[{"name":"中间件","slug":"中间件","permalink":"http://www.luckyzmj.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://www.luckyzmj.cn/tags/redis/"}]},{"title":"redis简介","slug":"redis简介","date":"2022-03-29T13:42:01.000Z","updated":"2022-04-07T07:08:36.497Z","comments":true,"path":"posts/1313dd35.html","link":"","permalink":"http://www.luckyzmj.cn/posts/1313dd35.html","excerpt":"","text":"NoSQL简介 NoSQL的全称 not only SQL 方便扩展，数据之间没有关系 大数据高性能（读取11万次每秒，写8万次每秒） 数据类型多种多样且不需要事先设计数据库的表，有更好的扩展性 传统的数据库和NoSQL的区别传统数据库： 结构化组织 数据都存储在表中 需要用sql进行查询 严格的一致性 数据定义语言 NoSQL： 不仅仅是数据库 没有固定的查询语言 键值对存储、列存储、文档存储、图形数据库等 最终一致性 CAP定理和BASE理论 高性能、高可用、高扩展 NoSQL的4种存储方式 k-v键值对 常见的有redis、Tair、Memcache 文档数据库：MongoDB 列存储数据库：HBase、分布式文件系统 图形数据库：Neo4j Redis的概述英文官网： https://redis.io/ 中文官网： http://www.redis.cn/ redis是什么Redis（Remote Dictionary Server )，即远程字典服务。 是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 redis能做什么 内存存储，持久化，常用的持久化是RDB、AOF 效率高用于缓存 发布订阅系统 地图信息分析 计时器、计数器 ……………… redis的特性 多样的数据类型 持久化 集群 事务 redis数据库redis有16个数据库，默认数据库是0号数据库 127.0.0.1:6379&gt; select 3 #切换数据库到3 OK 127.0.0.1:6379[3]&gt; dbsize #显示当前数据库的key值数量 (integer) 0 127.0.0.1:6379[3]&gt; set key 1 #设置一个值 OK 127.0.0.1:6379[3]&gt; get key #获取值 \"1\" 127.0.0.1:6379[3]&gt; select 1 #切换到1号数据库 OK 127.0.0.1:6379[1]&gt; get key #得到的数据为nil，也即是在3号数据库设置的值在1号数据库查不到 (nil) 127.0.0.1:6379[1]&gt; keys * #查询当前数据库的所有key值 127.0.0.1:6379[1]&gt; FLUSHALL #清空所有数据库的值 OK 127.0.0.1:6379[1]&gt; FLUSHdb #清空当前数据库的值 OK redis的原理redis是单线程的，redis是基于内存操作的，CPU不是redis的性能瓶颈，redis的性能瓶颈是由内存和网络带宽决定的。 redis是用c语言编写的，每秒大概100000QPS，性能不比Memcache差。 由于redis的数据都存储在内存中，所以单线程操作更加快速。多线程操作会存在CPU之间的切换消耗资源。对于内存系统，没有CPU切换效率最高。","categories":[{"name":"中间件","slug":"中间件","permalink":"http://www.luckyzmj.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://www.luckyzmj.cn/tags/redis/"}]},{"title":"mysql简单介绍","slug":"mysql","date":"2022-03-29T12:58:48.000Z","updated":"2022-04-07T07:08:36.487Z","comments":true,"path":"posts/cac25959.html","link":"","permalink":"http://www.luckyzmj.cn/posts/cac25959.html","excerpt":"","text":"mysql中innodb和myisam innodb myisam 事务 支持 不支持 外键 支持 不支持 全文索引 不支持 支持 锁级别 行级锁 表锁 表空间大小 较大，约为myisam的2倍 较小 索引 聚簇索引、索引就是数据，顺序存储，因此能缓存索引，也能缓存数据 非聚簇索引、索引和文件分开，随机存储，只能缓存索引 备份和恢复 拷贝数据文件、备份 binlog，或者用 mysqldump，数据量大时很慢 数据是以文件的形式存储，所以在跨平台的数据转移中会很方便 myisam：节约空间，速度快，如果不注重事务或读取操作较多时选择myisam，其他情况选择innodb。 innodb：安全性高、事务处理、多表多用户操作。 mysql的数据库信息都存在data目录下： InnoDB基于磁盘的资源是InnoDB表空间数据文件和它的日志文件，InnoDB 表的大小只受限于操作系统文件的大小 MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型， .frm文件存储表定义，数据文件的扩展名为.MYD， 索引文件的扩展名是.MYI mysql的事务ACID 原子性(A)：事务是最小单位，不可再分 一致性©：事务要求所有的DML语句操作的时候，必须保证同时成功或者同时失败 隔离性(I)：事务A和事务B之间具有隔离性 持久性(D)：是事务的保证，事务终结的标志(内存的数据持久到硬盘文件中) 隔离存在的并发问题 脏读：事务A读取了事务B更新的数据，然后B回滚操作（即未提交），那么A读取到的数据是脏数据 不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。 幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。 隔离级别的分类 事务隔离级别 脏读 不可重复读 幻读 读未提交（read-uncommitted） 是 是 是 不可重复读（read-committed） 否 是 是 可重复读（repeatable-read） 否 否 是 串行化（serializable） 否 否 否 mysql默认的事务隔离级别为repeatable-read mysql事务的常用方法 set autocommit =0 #关闭自动提交 set autocommit =1 #开启自动提交 Start Transaction #开启事务 Commit #提交事务 Rollback #回滚事务 End Transaction #事务结束 索引 indexB-Tree索引 InnoDB使用的是B+Tree，每一个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的范围遍历。 B-Tree通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同，很适合查找范围数据。 B-Tree可以对&lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN，以及不以通配符开始的LIKE使用索引。 索引的优缺点 优点： 建立索引的列可以保证行的唯一性，生成唯一的rowId 建立索引可以有效缩短数据的检索时间 建立索引可以加快表与表之间的连接 为用来排序或者是分组的字段添加索引可以加快分组和排序顺序 缺点： 创建索引和维护索引需要时间成本，这个成本随着数据量的增加而加大 创建索引和维护索引需要空间成本，每一条索引都要占据数据库的物理存储空间，数据量越大，占用空间也越大（数据表占据的是数据库的数据空间） 会降低表的增删改的效率，因为每次增删改索引需要进行动态维护，导致时间变长 常见的索引类型 普通索引 index 普通索引是最基本的索引，它没有任何限制。 唯一索引 uniqe index 唯一索引和普通索引类似，主要的区别在于，唯一索引限制列的值必须唯一，但允许存在空值（只允许存在一条空值）。 主键索引 primary key 主键索引是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引 组合索引 index 复合索引是在多个字段上创建的索引。复合索引遵守“最左前缀”原则，即在查询条件中使用了复合索引的第一个字段，索引才会被使用。因此，在复合索引中索引列的顺序至关重要。 全文索引 fullText FULLTEXT 索引在 MySQL 5.6 版本之后支持 InnoDB，而之前的版本只支持 MyISAM 表。一般用于模糊查询 索引失效场景 在where后使用or，导致索引失效（尽量少用or） 使用like ，like查询是以%开头 复合索引遵守“最左前缀”原则，即在查询条件中使用了复合索引的第一个字段，索引才会被使用 如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引 在索引字段上使用not，&lt;&gt;，!=。不等于操作符是永远不会用到索引的，因此对它的处理只会产生全表扫描 DATE_FORMAT()格式化时间，格式化后的时间再去比较，可能会导致索引失效。 is null， is not null也无法使用索引 什么情况下不适合建立索引 小数据量的表不超过10万 数据变动强的字段不建立索引 大字段不建立索引 有枚举类型的字段不建议索引，或者建立组合索引","categories":[{"name":"中间件","slug":"中间件","permalink":"http://www.luckyzmj.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.luckyzmj.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"docker进阶","slug":"docker进阶","date":"2022-03-29T12:23:13.000Z","updated":"2022-04-07T07:08:36.499Z","comments":true,"path":"posts/abdfa13a.html","link":"","permalink":"http://www.luckyzmj.cn/posts/abdfa13a.html","excerpt":"","text":"容器卷技术容器卷技术的目的是为了持久化和同步操作！容器件也可以进行同步。 #容器与本地数据挂载 # 一、命令挂载 docker run -it -v linux文件目录:容器目录 容器id /bin/bash #把linux目录和容器目录进行同步 # 二、dockerFile 挂载 # 1、建立dockerFile文件 其中书写指令是必须都大写 FROM centos #要挂载的镜像 VOLUME [\"volume01\",\"volume2\"] #要挂载的卷 CMD echo \"----end----\" CMD /bin/bash # 2、运行文件 docker build -f 创建的dockerFile目录 -t 生成的名字 #容器之间挂载 把两容器关联起来 docker run -it --name 新建容器 --volume-from 要挂载的容器 moer/centos:1.0 Dockerfile构建过程基础知识1、每个指令必须的大写 2、指令的执行顺序从上到下 3、#表示注释 4、每个指令都会提交一个镜像，层层提交。 DokcerFile的基础命令 FROM #基础镜像 MAINRAINER #姓名+邮箱 RUN #运行命令 ADD #添加分层镜像 WORKDIR #工作目录 VOLUME #挂载卷 EXPOSE #暴露端口号 CMD #指定容器运行的适合要启动的命令，只有最后一个命令生效，不可追加 ENTRYPOINT #指定容器运行的适合要启动的命令，可以追加命令 ENV #构建的时候设置环境变量 COPY #把一个镜像拷贝进去类似ADD docker 网络docker network ls #查看所有的docker网络 b6fbe2727cc1 bridge bridge local e8ea254fb069 host host local 4956a8e7920a none null local #其中bridge 是桥接模式（默认） host是主机模式 none不配置网络 springboot项目打包成Docker镜像1、编写成功Springboot项目 2、达成jar包 3、编写dockerFile进行发布 4、构建镜像 5、发布运行","categories":[{"name":"中间件","slug":"中间件","permalink":"http://www.luckyzmj.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.luckyzmj.cn/tags/docker/"}]},{"title":"docker常用命令汇总","slug":"docker常用命令汇总","date":"2022-03-28T15:36:29.000Z","updated":"2022-04-07T07:08:36.501Z","comments":true,"path":"posts/a2145400.html","link":"","permalink":"http://www.luckyzmj.cn/posts/a2145400.html","excerpt":"","text":"普通指令# 启动docker systemctl start docker #停止docker systemctl stop docker #重启docker systemctl restart docker #查看版本 docker version #查看docker信息 docker info #帮助 docker --help 镜像命令# 查看已安装的镜像 docker images # 查询镜像 docker search 镜像名 #例如：docker search tomcat # 拉取镜像 docker pull 镜像名 #例如：docker pull tomcat:8.5 如果后面不跟版本后则默认下载最新版本 # 删除镜像 docker rmi 镜像名 #例如 docker rmi tomcat docker rmi -f 镜像id #镜像id是创建镜像的唯一表示 # 删除所有镜像 docker rmi -f ${docker images -qa} #即查询出所有镜像并删除 # 打包一个镜像 docker commit -a 作者信息 -m=\"要提交的信息\" 镜像id 要生产的镜像名称 # 运行一个镜像,运行成功之后则生成一个容器 docker run -it -p 外部端口号:内部端口号 镜像名称 容器命令# 通过镜像生成容器的常用命令 --name #给容器起一个名字 -d #表示后台运行 -it #表示进入控制台运行与-d功能相同 -P #随机分配一个端口号不常用 -p #端口映射 外部端口：内部端口 -v #卷挂载 宿主机路径：内部路径 用途是挂载文件是同步的，即可通过修改外部文件已到达修改内部文件的目的 # 查询docker正在运行的容器 docker ps #后续的常用参数 -a #查看所有容器 -l #最近创建的容器 -n #最近创建的n个容器 # 退出容器 exit #退出并停止 ctrl+p+Q #退出但不停止 # 启动、停止、重启、杀死容器 docker start/stop/restart/kill 容器id或容器名 # 删除容器 docker rm 容器id或容器名 #只能删除已停止的容器 docker rm -f 容器id或容器名 #强制删除容器 docker rm -f ${docker ps -qa} #删除所有容器 #重新进入容器 docker attach 容器id或容器名 #这种方式太慢 docker exex -it 容器id或容器名 /bin/bash #进入正在执行的容器并进行交互 # 拷贝文件从内部到外部 docker cp 容器id或容器名:文件路径 宿主机路径 日志命令docker logs -f -t --tail 10 容器id或容器名 -t #表示显示时间 -f #最新的日志打印 --tail #行数 -n #全部打印 docker top 容器id或容器名 #查看容器内的进程","categories":[{"name":"中间件","slug":"中间件","permalink":"http://www.luckyzmj.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.luckyzmj.cn/tags/docker/"}]},{"title":"docker基础","slug":"docker基础","date":"2022-03-28T04:49:37.000Z","updated":"2022-04-07T07:08:36.500Z","comments":true,"path":"posts/5ae6092.html","link":"","permalink":"http://www.luckyzmj.cn/posts/5ae6092.html","excerpt":"","text":"docker的默认工作路径是 /var/lib/dockerdocker的基础是镜像与容器docker的官网地址：https://docs.docker.com/Docker的基本命令：docker version #查看docker的基本信息 docker info #显示docker的系统信息，包括镜像和容器镜像 docker 命令 --help #docker命令帮助查询 12321312 Docker的镜像常用命令：docker images -a #查看所有镜像信息 docker images -q #查看所有镜像id docker images -filter ...... #过滤信息 docker搜索镜像：docker search 服务名称 例如：docker search java docker search mysql docker search mysql --filter=stars=200 #查询星数在200以上 拉取镜像：docker pull (镜像名称)：（镜像版本） #例如 docker pull mysql:5.7 docker pull (镜像名称) #拉取最新版本的镜像信息 删除镜像：docker rmi -f (镜像id) #删除镜像信息，镜像d可通过docker images进行查询 docker rmi -f $（dokcer images） #删除所有镜像信息 dokker rmi -f 镜像id 镜像id #删除多个镜像信息 Docker的容器命令：首先我们先下载个centos镜像命令进行学习docker pull centos 容器命令：docker run [可选参数] image #常用参数 --name #容器名字，用来区分容器 -d #后台方式运行 -it #使用交互方式运行，进入容器查看内容 -p #指定容器的端口 -p 主机端口：容器端口 -P #随机指定端口 运行查看容器： docker run -it centos /bin/bash #进入centos docker ps #查看正在运行的容器 docker ps -a #查看历史运行的容器 docker ps -n=？ #查看最近运行的容器,如果加上=？则表示最近几条 退出容器： exit #容器停止并退出 CTRL+P+Q #容器不停止退出 删除容器： docker rm 容器id #删除非运行的容器，如果运行会报错 docker rm -f 容器id #强制删除容器 docker rm -f $(docker ps -aq) #删除所有容器id 启动容器命令：docker start 容器id #启动容器 docker restart 容器id #重启容器 docker stop 容器id #停止正在运行的容器 docker kill 容器id #强制停止当前容器 日志命令：docker logs -tf tail 10 容器id #查询后十条日志信息 tail 10 可省略 常用其他命令：docker top 容器id #查看容器进程 docker inspect 容器id #查看容器的基本信息 docker exec -it 容器id /bin/bash #进入正在启动的容器，并开启一个新容器 docker attach 容器id #进入正在启动的容器，不会启动新的容器 docker cp 容器id:容器内路径 容器外路径 #复制文件从内部容器到外部容器 docker stats #查询docker的内存使用率 下载nginx镜像到linux服务器docker search nginx #查看镜像 docker pull nginx #下载最新版本的镜像 docker images #查看下载的容器 docker run -d --name nginx01 -p 3344:80 nginx #-d 后台运行 # --name 给容器起个名字以便分辨 # -p 3344 宿主机端口,即外部端口 # 80 内部容器端口即nginx端口 下载mysql5.7到linux服务器#获取mysql镜像 docker pull mysql:5.7 # -v 卷挂载 # -e 环境配置 # -d 后台运行 # -p 端口映射 # --name 给容器命名 # 配置mysql地址环境 docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=wlk161536 --name mysql01 mysql:5.7 #-v的目的是映射到本地 前面的表示宿主机文件，后面表示docker内文件 提交镜像docker commit -m=\"描述提交的信息\" -a=\"作者\" 容器id 目录镜像名:[tags版本] 例如： 1、先运行一个tomcat镜像 docker run -it 容器id /bin/bash 2、启动tomcat镜像 docker exec -it 容器id /bin/bash 3、由于docker中的webApps下没有目录，需要webApps.dist文件复制到webApps下 cp -r webApps.dist/* webApps 4、把修改后的镜像提交 docker commit -m =\"添加webbApps信息\" -a=\"moerWolld\" 容器id tomcat2:1.0 #查看镜像的历史构建记录 可查看构造方式仿造一个同样的镜像 docker history 镜像id","categories":[{"name":"中间件","slug":"中间件","permalink":"http://www.luckyzmj.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://www.luckyzmj.cn/tags/docker/"}]},{"title":"mybatis简单介绍","slug":"mybatis","date":"2022-03-27T12:16:25.000Z","updated":"2022-04-07T07:08:36.487Z","comments":true,"path":"posts/bac22b86.html","link":"","permalink":"http://www.luckyzmj.cn/posts/bac22b86.html","excerpt":"","text":"mybatis的中文官网地址https://mybatis.org/mybatis-3/zh/ mybatis的主要核心部件 SqlSession 表示和数据库交互的会话，完成必要的数据库增删改查功能 Executor 执行器，是mybatis的核心，负责sql语句的执行，缓存的查询 StatementHandler 封装了JDBC Statement操作，负责对JDBC statement的操作，如设置参数，或将结果集转换成List ParameterHandler 负责对用户传递的参数转换成JDBC Statement所需要的参数 ResultSetHandler 负责将jdbc返回的结果集转换成List集合 TypeHandler 负责将java的数据类型和jdbc数据类型之间的转换 Configuration 配置mybatis的信息 SqlSource 负责用户传递的paramterObject,动态的生成SQL语句，将信息封装到BoundSql中 BoundSql 表示动态生成SQL语句以及相应的参数信息 mybatis 工作流程 读取mybatis的配置信息，可以是xml的格式，也可以是基于Configuration的对象。 实例化SqlSessionFactoryBuilder,并通过build配置文件生成SqlSessionFactory实例 创建一个SqlSession会话，用于实现CRUD。 创建会话时也会创建一个新的Executor执行器，用于执行SQL或者查询缓存 执行完成，返回结果并关闭SqlSession会话。 mybatis的缓存一级缓存SqlSessionmybatis的一级缓存是默认开启的，是SqlSession级别的，即拿到这个链接到结束连接的过程中缓存是有效的。其特点有以下： 映射语句文件中的所有 select 语句的结果将会被缓存。 映射语句文件中的所有 insert、update 和 delete 语句会刷新缓存。 缓存会使用最近最少使用算法（LRU, Least Recently Used）算法来清除不需要的缓存。 缓存不会定时进行刷新（也就是说，没有刷新间隔）。 缓存会保存列表或对象（无论查询方法返回哪种）的 1024 个引用。 缓存会被视为读/写缓存，这意味着获取到的对象并不是共享的，可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。 &lt;!--可以设置缓存算法，刷新间隔、引用大小、只读表示等 --&gt; &lt;cache eviction=\"FIFO\" flushInterval=\"60000\" size=\"512\" readOnly=\"true\"/&gt; 二级缓存nameSpacemybatis的二级缓存也叫全局缓存，由于一级缓存的作用域只在sqlSession中（太窄了），所以诞生了二级缓存，它是基于nameSpace级别的缓存，相当于一个nameSpace对应一个二级缓存。mybatis的二级缓存需要手动开启。 二级缓存的工作机制： 当一个会话查询到一条数据时首先会存储到一级缓存中 如果当前会话关闭，则一级缓存不存在了，则会把一级缓存的信息过渡到二级缓存 当我们再次在此nameSPace空间内查询时则会从二级缓存中获得内容 不同的nameSpace有不同的缓存集合 自定义缓存自定义缓存只需实现Cache就可以了！具体可查看官方文档！","categories":[{"name":"中间件","slug":"中间件","permalink":"http://www.luckyzmj.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.luckyzmj.cn/tags/mybatis/"}]},{"title":"闲杂时间0326","slug":"闲杂时间0326","date":"2022-03-26T12:27:03.000Z","updated":"2022-04-07T07:08:36.504Z","comments":true,"path":"posts/dc93815f.html","link":"","permalink":"http://www.luckyzmj.cn/posts/dc93815f.html","excerpt":"","text":"http的请求中get、post、put、delete的区别在原始的springmvc请求时只有post和get两种请求，那时候的区分如下： GET在浏览器回退时是无害的，而POST会再次提交请求。 GET产生的URL地址可以被Bookmark（存书签），而POST不可以。 GET请求会被浏览器主动cache，而POST不会，除非手动设置。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET请求在URL中传送的参数是有长度限制的，而POST么有。 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。 GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 GET参数通过URL传递，POST放在Request body中。 进入Spring4.3时代之后，新增加put、delete两种常用的请求方式，四种的区别如下：谈论这四个的区别，不得不提的一个词为幂等，即get\\put\\delete都具有幂等性。 幂等（idempotent、idempotence）是一个数学或计算机学概念，常见于抽象代数中。 幂等有一下几种定义： 对于单目运算，如果一个运算对于在范围内的所有的一个数多次进行该运算所得的结果和进行一次该运算所得的结果是一样的，那么我们就称该运算是幂等的。比如 绝对值运算就是一个例子，在实数集中，有 abs(a) = abs(abs(a))。 对于双目运算，则要求当参与运算的两个值是等值的情况下，如果满足运算结果与参与运算的两个值相等，则称该运算幂等，如求两个数的最大值的函数，有在在实数集中幂等，即 max(x,x) = x。 简单的来说： get请求 查询语句，即一次查询跟多次查询的效果一样 post请求 插入语句，每次插入的数据都不一样，不存在幂等性且数据量更适合post请求 put请求 修改语句，每次修改成同样的值也具有幂等性 delete请求 删除语句，每次删除也具有幂等性 理论如上所说，但实际操作中，如果为了方便一切都是用post也可以保证以便出现不可预估的错误。","categories":[{"name":"java基础","slug":"java基础","permalink":"http://www.luckyzmj.cn/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"http://www.luckyzmj.cn/tags/java%E5%9F%BA%E7%A1%80/"}]},{"title":"linux基础命令","slug":"linux基础命令","date":"2022-03-26T12:03:20.000Z","updated":"2022-04-07T07:08:36.498Z","comments":true,"path":"posts/6463939c.html","link":"","permalink":"http://www.luckyzmj.cn/posts/6463939c.html","excerpt":"","text":"# 查看版本信息 uname -r # 查看系统版本 cat /etc/os-release #centos7的查看关闭开启防火墙命令 firewall-cmd --state #查看防火墙状态 systemctl stop firewalld.service #停止防火墙 systemctl disable firewalld.service #开机自启 文件处理命令# 显示目录文件 ls # 显示带隐藏的目录文件 ls -a # 创建目录 mkdir 目录名 # 创建文件 touch 文件名 # 切换目录 cd /目录 # 返回上一级目录 cd .. # 显示当前目录 pwd # 删除空目录 rmdir /目录 # 复制目录或者文件 cp -rp /源文件或者目录 /目标目录 # 剪切文件或目录 mv /源文件或者目录 /目标目录 # 删除文件或目录 rm -rf /目录或文件 # 查询文件信息 cat 文件名 tail -f 文件名 #实时查询信息 tail -n 1000 文件名 #倒叙查询1000行信息 权限管理命令chmod 参数 文件名 #更改文件的读写执行权限 参数有-r -w -x 读 写 执行 u所有人 g所属组 例如：chown U+x 123.log chown 用户 文件名 #更改某个文件用户权限 用户必须是真实存在的 文件查询命令find /目录或文件 -name *init* #查询含有init的文件 *可以匹配任意个字符 find /目录或文件 -name *init？？？ #一个？只能匹配一个字符 用户管理命令whoami #查看当前用户 useradd -m 账号 #新建一个账号 passwd 账号 #给此账号输入密码 userdel -r 账号 #删除账号信息 其他命令cal -1 5 2020 #查看2020年5月份的日历 wc -lc 文件名 &gt;要创建的文件 # 统计某个文件的行数和列数要书写到某个文件 wget 远程地址 #下载某个文件从远程地址中","categories":[{"name":"linux","slug":"linux","permalink":"http://www.luckyzmj.cn/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://www.luckyzmj.cn/tags/linux/"}]},{"title":"jvm基础","slug":"jvm","date":"2022-03-25T13:35:16.000Z","updated":"2022-04-07T07:08:36.488Z","comments":true,"path":"posts/3e03f605.html","link":"","permalink":"http://www.luckyzmj.cn/posts/3e03f605.html","excerpt":"","text":"jvm（hotSpot）的体系结构 类加载器类加载器的种类 启动类根加载器 lib/rb.jar 扩展类加载器 lib/exc/*.jar 应用程序加载器 classpath 类加载器概念我们编写号类文件之后，通过类加载器class loader加载成class文件，class文件也可通过getClassload转换到class loader里，如果我们需要实例化，则一般常用new的方式实例化成具体的对象，对象也可通过getClass得到想要的class文件。其中class是抽象的，对象是具体的实现。每个对象都是一个实例化。 双亲委派机制优点：双亲委派模型是为了保证Java核心库的类型安全。所有Java应用都至少需要引用java.lang.Object类，在运行时这个类需要被加载到Java虚拟机中。如果该加载过程由自定义类加载器来完成，可能就会存在多个版本的java.lang.Object类，而且这些类之间是不兼容的。 通过双亲委派模型，对于Java核心库的类的加载工作由启动类加载器来统一完成，保证了Java应用所使用的都是同一个版本的Java核心库的类，是互相兼容的。 流程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的加载器都是如此，因此所有的类加载请求都会传给顶层的启动类加载器，只有当父加载器反馈自己无法完成该加载请求（该加载器的搜索范围中没有找到对应的类）时，子加载器才会尝试自己去加载。三种加载器的子父关系：启动类根加载器/扩展类加载器 /应用程序加载器 native关键字 凡是用native修饰的方法，说明java程序的作用范围达不到，需要调用底层的C语言 会进入本地方法栈调用本地方法接口JNI JNI的作用是扩展java的应用，融合不同的语言为java使用 存储native方法的区域叫做native Method Stack即本地方法栈 在最终执行的时候会加载到本地方法库通过JNI进行调用 PC寄存器 它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域 在jvm规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致 任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的java方法的JVM指令地址；或者，如果在执行native方法，则是未指定值（undefined）,因为程序计数器不负责本地方法栈。 它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令 它是唯一一个在java虚拟机规范中没有规定任何OOM（Out Of Memery）情况的区域,而且没有垃圾回收 方法区、元空间 方法区（Method Area）与 Java 堆一样，是所有线程共享的内存区域。 JDK7 之前（永久代）用于存储已被虚拟机加载的类信息、常量、字符串常量、类静态变量、即时编译器编译后的代码等。即static、final、Class、常量池。 JDK8 彻底将永久代移除出 HotSpot JVM，将其原有的数据迁移至 Java Heap 或 Native Heap，取代它的是另一个内存区域被称为元空间(Metaspace） 元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。 栈stack 栈内存主管程序的运行和线程同步 线程结束，栈内存也就释放不存在垃圾回收机制 栈存储的有8大基本数据类型+对象引用+实例方法 栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活。 如果栈满则会抛出stackOverFlowError错误 堆heap 一个jvm只有一个堆内存，堆内存的大小是可以调节的。 类加载器读取类文件之后，会把类、方法、常亮放入堆中，保存我们引用类型的真实对象 堆分为：新生区（伊甸园区eden、from、to）、老年区 -Xms1024m -Xmx1024m -XX:+PrintGCDetails //自定义堆的内存空间为1024m，其中xms时初始化内存大小，xmx时最大分配内存· //新生代总内存 305664K, PSYoungGen total 305664K, used 47186K [0x00000000eab00000, 0x0000000100000000, 0x0000000100000000) //伊甸园区 使用率 eden space 262144K, 18% used [0x00000000eab00000,0x00000000ed914aa0,0x00000000fab00000) //幸村一区、幸存0区的内次使用率 from space 43520K, 0% used [0x00000000fd580000,0x00000000fd580000,0x0000000100000000) to space 43520K, 0% used [0x00000000fab00000,0x00000000fab00000,0x00000000fd580000) //养老区的内存总数 ParOldGen total 699392K, used 0K [0x00000000c0000000, 0x00000000eab00000, 0x00000000eab00000) //养老区内存使用率 object space 699392K, 0% used [0x00000000c0000000,0x00000000c0000000,0x00000000eab00000) //元空间的 的逻辑内存，实际上存储在本地内存中 Metaspace used 3396K, capacity 4500K, committed 4864K, reserved 1056768K class space used 369K, capacity 388K, committed 512K, reserved 1048576K -Xms16m -Xmx16m -XX:+PrintGCDetails //自定义空间为16m，可以看出明显的差别 PSYoungGen total 4608K, used 851K [0x00000000ffb00000, 0x0000000100000000, 0x0000000100000000) eden space 4096K, 8% used [0x00000000ffb00000,0x00000000ffb586f0,0x00000000fff00000) from space 512K, 97% used [0x00000000fff00000,0x00000000fff7c7a0,0x00000000fff80000) to space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000) ParOldGen total 11264K, used 786K [0x00000000ff000000, 0x00000000ffb00000, 0x00000000ffb00000) object space 11264K, 6% used [0x00000000ff000000,0x00000000ff0c4a28,0x00000000ffb00000) Metaspace used 3447K, capacity 4500K, committed 4864K, reserved 1056768K class space used 370K, capacity 388K, committed 512K, reserved 1048576K //当运行的对象过多时会进行轻量级的GC清理和重量级的GC清理，如果重量级的GC清理也不成功，则会提示 java.lang.OutOfMemoryError: Java heap space内存溢出 [GC (Allocation Failure) --[PSYoungGen: 3072K-&gt;3072K(3584K)] 14077K-&gt;14333K(14848K), 0.0025489 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (Ergonomics) [PSYoungGen: 3072K-&gt;3071K(3584K)] [ParOldGen: 11208K-&gt;11208K(11264K)] 14280K-&gt;14279K(14848K), [Metaspace: 36735K-&gt;36735K(1083392K)], 0.0202492 secs] [Times: user=0.01 sys=0.00, real=0.02 secs] 2021-05-11 21:38:46.349 ERROR 8084 --- [ restartedMain] com.alibaba.druid.pool.DruidDataSource : {dataSource-1} init error java.lang.OutOfMemoryError: Java heap space 垃圾回收GC1、分代收集算法： 堆中的每个对象都会添加一个引用计数器。每当一个地方引用这个对象时，计数器值 +1；当引用失效时，计数器值 -1。任何时刻计数值为 0 的对象就是不可能再被使用的。这种算法无法解决对象之间相互引用的情况。 2、复制算法：将可用内存分为两块，每次只用其中一块，当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已经使用过的内存空间一次性清理掉。这种算法适用于对象存活率低的场景，比如新生代。 3、标记、清除、压缩算法：首先垃圾回收器此时会找出哪些内存在使用中，那些未使用，接着删除未使用对象并内存分配器会保留指向可用内存的引用，以供分配新对象，最后为了提升性能，删除了未引用对象后，还可以将剩下的已引用对象放在一起（压缩），这样就能更简单快捷地分配新对象了。一般可以设置N次标记清除之后，压缩一次。其中N最多15次。 4、分代收集算法： 新生代的目标就是尽可能快速的收集掉那些生命周期短的对象，一般情况下，所有新生成的对象首先都是放在新生代的。新生代内存按照 8:1:1 的比例分为一个eden区和两个survivor(survivor0，survivor1)区，大部分对象在Eden区中生成。在进行垃圾回收时，先将eden区存活对象复制到survivor0区，然后清空eden区，当这个survivor0区也满了时，则将eden区和survivor0区存活对象复制到survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后交换survivor0区和survivor1区的角色（即下次垃圾回收时会扫描Eden区和survivor1区），即保持survivor0区为空，如此往复。特别地，当survivor1区也不足以存放eden区和survivor0区的存活对象时，就将存活对象直接存放到老年代。如果老年代也满了，就会触发一次FullGC，也就是新生代、老年代都进行回收。注意，新生代发生的GC也叫做MinorGC，MinorGC发生频率比较高，不一定等 Eden区满了才触发。 老年代存放的都是一些生命周期较长的对象，就像上面所叙述的那样，在新生代中经历了N次垃圾回收后仍然存活的对象就会被放到老年代中。此外，老年代的内存也比新生代大很多(大概比例是1:2)，当老年代满时会触发Major GC(Full GC)，老年代对象存活时间比较长，因此FullGC发生的频率比较低。","categories":[{"name":"java基础","slug":"java基础","permalink":"http://www.luckyzmj.cn/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"http://www.luckyzmj.cn/tags/jvm/"}]},{"title":"java8常用","slug":"java8","date":"2022-03-24T23:21:00.000Z","updated":"2022-04-07T07:08:36.488Z","comments":true,"path":"posts/3cd8ec21.html","link":"","permalink":"http://www.luckyzmj.cn/posts/3cd8ec21.html","excerpt":"","text":"一、接口里可以书写默认方法// 定义一个公式接口 interface Formula { // 计算 double calculate(int a); // 求平方根 default double sqrt(int a) { return Math.sqrt(a); } } 通过 default 关键字这个新特性，可以非常方便地对之前的接口做拓展，而此接口的实现类不必做任何改动。 二、函数式接口Functional Interface所谓函数式接口（Functional Interface）就是只包含一个抽象方法的声明。针对该接口类型的所有 Lambda 表达式都会与这个抽象方法匹配。 例如： @FunctionalInterface public interface Supplier&lt;T&gt; { /** * Gets a result. * * @return a result */ T get(); } 总结：只要接口中仅仅包含一个抽象方法，我们就可以将其改写为 Lambda 表达式。为了保证一个接口明确的被定义为一个函数式接口（Functional Interface），我们需要为该接口添加注解：@FunctionalInterface。这样，一旦你添加了第二个抽象方法，编译器会立刻抛出错误提示，如果此接口中添加默认方法无影响。且函数式接口都可用lambda进行书写。 三、jdk中常用的函数式接口PredicatePredicate断言可以指定入参类型，并返回 boolean 值的函数式接口。它内部也提供了一些带有默认实现的方法，可以 被用来组合一个复杂的逻辑判断（and, or, negate）。 //定义一个断言的实现 Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; 0; //测试 predicate.test(\"foo\"); // true predicate.negate().test(\"foo\"); // false Predicate&lt;String&gt; isEmpty = String::isEmpty; //实现默认方法negate Predicate&lt;String&gt; isNotEmpty = isEmpty.negate(); functionfunction有一个入参类型和一个返回值类型，它的默认方法有组合,链行处理(compose, andThen)； Function&lt;String, Integer&gt; toInteger = Integer::valueOf; Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf); backToString.apply(\"123\"); // \"123\" SupplierSupplier 与 Function 不同，它不接受入参，直接为我们生产一个指定的结果； Supplier&lt;Person&gt; personSupplier = Person::new; personSupplier.get(); // new Person ConsumerConsumer和Supplier不同之处在于，Consumer接受一个入参，但无返回值。 Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(\"Hello, \" + p.firstName); greeter.accept(new Person(\"Luke\", \"Skywalker\")); 总结：其他后续多入参，多出参可去函数式接口中查询对应的关键字四：optional Optional 看做是包装对象（可能是 null, 也有可能非 null）的容器。当你定义了 一个方法，这个方法返回的对象可能是空，也有可能非空的时候，你就可以考虑用 Optional 来包装它，这也是在 Java 8 被推荐使用的做法。 Optional&lt;String&gt; optional = Optional.of(\"bam\"); optional.isPresent(); // true optional.get(); // \"bam\" optional.orElse(\"fallback\"); // \"bam\" optional.ifPresent((s) -&gt; System.out.println(s.charAt(0))); // \"b\" 五、Stream流Stream对一个包含一个或多个元素的集合做各种操作。这些操作可能是 中间操作 亦或是 终端操作。 终端操作会返回一个结果，而中间操作会返回一个 Stream 流。 需要注意的是，你只能对实现了 java.util.Collection 接口的类做流的操作。但不支持对Map进行操作。 常用的Stream流的方法 首先创建一个List集合 List&lt;String&gt; stringCollection = new ArrayList&lt;&gt;(); stringCollection.add(\"ddd2\"); stringCollection.add(\"aaa2\"); stringCollection.add(\"bbb1\"); stringCollection.add(\"aaa1\"); stringCollection.add(\"bbb3\"); stringCollection.add(\"ccc\"); stringCollection.add(\"bbb2\"); stringCollection.add(\"ddd1\"); foreach（终端操作）终端操作一般都需要搭配 stringCollection .stream() //把集合转换成流进行操作 .forEach(System.out::println); filter过滤（中间操作）stringCollection .stream() .filter((s) -&gt; s.startsWith(\"a\")) .forEach(System.out::println); // \"aaa2\", \"aaa1\" sorted排序(中间操作)stringCollection .stream() .sorted() .filter((s) -&gt; s.startsWith(\"a\")) .forEach(System.out::println); // \"aaa1\", \"aaa2\" map转换(中间操作)stringCollection .stream() .map(String::toUpperCase) .sorted((a, b) -&gt; b.compareTo(a)) .forEach(System.out::println); // \"DDD2\", \"DDD1\", \"CCC\", \"BBB3\", \"BBB2\", \"AAA2\", \"AAA1\" map匹配(中间操作)// 验证 list 中 string 是否有以 a 开头的, 匹配到第一个，即返回 true boolean anyStartsWithA = stringCollection .stream() .anyMatch((s) -&gt; s.startsWith(\"a\")); System.out.println(anyStartsWithA); // true // 验证 list 中 string 是否都是以 a 开头的 boolean allStartsWithA = stringCollection .stream() .allMatch((s) -&gt; s.startsWith(\"a\")); System.out.println(allStartsWithA); // false // 验证 list 中 string 是否都不是以 z 开头的, boolean noneStartsWithZ = stringCollection .stream() .noneMatch((s) -&gt; s.startsWith(\"z\")); System.out.println(noneStartsWithZ); // true count计数(终端操作)// 先对 list 中字符串开头为 b 进行过滤，让后统计数量 long startsWithB = stringCollection .stream() .filter((s) -&gt; s.startsWith(\"b\")) .count(); System.out.println(startsWithB); // 3 Reduce归约（终端操作）//返回类型是Optional Optional&lt;String&gt; reduced = stringCollection .stream() .sorted() .reduce((s1, s2) -&gt; s1 + \"#\" + s2); reduced.ifPresent(System.out::println); // \"aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2\" 六、parallelStream并行流stream 流是支持顺序和并行的。顺序流操作是单线程操作，而并行流parallelStream是通过多线程来处理的，能够充分利用物理机 多核 CPU 的优势，同时处理速度更快。他们常用操作方式是一样的。 七、Map集合map 是不支持 Stream 流的，因为 Map 接口并没有像 Collection 接口那样，定义了 stream() 方法。但是，我们可以对其 key, values, entry 使用 流操作，如 map.keySet().stream(), map.values().stream() 和 map.entrySet().stream(). 八、日期此处不做代码总结了，后续可看api进行总结。 LocalTimeLocalDateLocalDateTIme","categories":[{"name":"java基础","slug":"java基础","permalink":"http://www.luckyzmj.cn/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.luckyzmj.cn/tags/java/"}]},{"title":"自定义注解","slug":"自定义注解","date":"2022-03-24T12:50:02.000Z","updated":"2022-04-07T07:08:36.502Z","comments":true,"path":"posts/db829ad7.html","link":"","permalink":"http://www.luckyzmj.cn/posts/db829ad7.html","excerpt":"","text":"@Target ：用于描述注解的使用范围@Retention： 表示需在该级别保存注释信息，用于描述生命周期，常用的有（SOURCE&lt;CLASS&lt;RUNTIME）@Document : 说明该注解被包含在javadoc中@inherited：说明之类可以继承父类中的注解注解参数的注意事项，如果注解的参数只有一个且为value时，可以省略value参数。@MyAnnotations(name=\"微录客\",schools = {\"北京大学\",\"清华大学\"}) public class MyAnnotation { @MyAnnotations(name=\"微录客\",schools = {\"北京大学\",\"清华大学\"}) public void test(){ } } @Target(value = {ElementType.METHOD,ElementType.TYPE}) // 描述在方法、包、类上等等 @Retention(value = RetentionPolicy.RUNTIME ) //表示该注释的生命周期为 @Documented //该注解包含在文档中 @Inherited //该注解可以被之类继承 @interface MyAnnotations{ //注解的参数 如果没有默认值必须在注解上加上该注解的参数，可以为String类型也可以为数组 String name(); String value() default \"\"; String [] schools(); }","categories":[{"name":"java基础","slug":"java基础","permalink":"http://www.luckyzmj.cn/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"注解","slug":"注解","permalink":"http://www.luckyzmj.cn/tags/%E6%B3%A8%E8%A7%A3/"}]},{"title":"全局捕获日志","slug":"Spingboot全局日志","date":"2022-03-23T12:53:43.000Z","updated":"2022-04-07T07:08:36.503Z","comments":true,"path":"posts/f30fde46.html","link":"","permalink":"http://www.luckyzmj.cn/posts/f30fde46.html","excerpt":"","text":"问题：记录所有方法运行时间用来判断哪些方法的书写不规范导致运行时间过长，如果超过规定的秒数(2000ms)则存储到日志表，以便后续优化。一、引入常用jar包 &lt;!--web依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--lombok --&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!--测试依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--aop依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--日志依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;!--swagger依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--swagger图形页面 --&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatisPlus依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatisPlus生成代码依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatisPlus生成模板前端模板依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.30&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;!--热部署依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;version&gt;2.3.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--druid连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.29&lt;/version&gt; &lt;/dependency&gt; &lt;!--hutool工具类 --&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.5.2&lt;/version&gt; &lt;/dependency&gt; 二、书写aop切入方法 @Component @Aspect @Slf4j public class LogAspectConfig { @Resource private LogOverTimeMapper logOverTimeMapper; //设置切入点的值为LogAnnotation注解 //如果嫌注解麻烦，可以配置具体的类上例如：@Pointcut(\"execution(* com.example.aop.controller.TestController.*(..)) || @annotation(com.example.aop.annotation.LogAnnotation)\") @Pointcut(value = \"@annotation(com.example.aop.annotation.LogAnnotation)\") public void pointCut(){ } //使用环绕通知，在方法的执行前后分别记录一个时间相减 @Around(\"pointCut()\") public Object doLog(ProceedingJoinPoint proceedingJoinPoint){ long startTime = System.currentTimeMillis(); Object object=null; try { object=proceedingJoinPoint.proceed(); } catch (Throwable throwable) { throwable.printStackTrace(); log.info(throwable.getMessage()); }finally { long endTime = System.currentTimeMillis(); //如果最后时间减去开始时间大于2000ms则插入日志表 if ((endTime-startTime)&gt;new Long(2000)){ LogOverTime logOverTime = new LogOverTime(); logOverTime.setLastDate( LocalDateTime.now()); logOverTime.setLastName(\"admin\"); logOverTime.setMethod(proceedingJoinPoint.getSignature().toShortString()); logOverTime.setRunMillisecond(new Integer((int) (endTime-startTime))); logOverTimeMapper.insert(logOverTime); } log.info(proceedingJoinPoint.getSignature().toShortString() + \"方法执行了：\" + (endTime - startTime) + \"ms\"); } return object; } } 三、书写注解LogAnnotation @Target(value = ElementType.METHOD) @Retention(value = RetentionPolicy.RUNTIME) @Documented public @interface LogAnnotation { } 四、书写实体类 @Data @EqualsAndHashCode(callSuper = false) @ApiModel(value=\"LogOverTime对象\", description=\"方法超时日志表\") public class LogOverTime implements Serializable { private static final long serialVersionUID = 1L; @ApiModelProperty(value = \"主键自增\") @TableId(value = \"id\", type = IdType.AUTO) private Integer id; @ApiModelProperty(value = \"方法\") private String method; @ApiModelProperty(value = \"运行时间\") private Integer runMillisecond; @ApiModelProperty(value = \"最后修改时间\") private LocalDateTime lastDate; @ApiModelProperty(value = \"最后修改人\") private String lastName; } 五、书写Mapper //此Mapper用的增强mybatis（mybatis_plus） public interface LogOverTimeMapper extends BaseMapper&lt;LogOverTime&gt; { } 六、书写测试类 @RestController @RequestMapping(\"/testApi\") public class TestController { @LogAnnotation @PostMapping(\"/test1\") public String testAop(){ try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } return \"123132\"; } @LogAnnotation @PostMapping(\"/test2\") public void testAop2(){ try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } } }","categories":[{"name":"框架","slug":"框架","permalink":"http://www.luckyzmj.cn/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"设计","slug":"设计","permalink":"http://www.luckyzmj.cn/tags/%E8%AE%BE%E8%AE%A1/"}]},{"title":"常用排序算法","slug":"常用排序算法","date":"2022-03-22T13:01:12.000Z","updated":"2022-04-07T07:08:36.505Z","comments":true,"path":"posts/5b90526d.html","link":"","permalink":"http://www.luckyzmj.cn/posts/5b90526d.html","excerpt":"","text":"1、选择排序 选择排序就是每趟排序从中找出最小的一个放在最前面，直至最后排序完成。 通俗的讲：假设有N条数据，首先第一趟排序从1-N中找出最小的一个，然后把1的数据的和最小的数据进行交换，第二趟则从2-N中找出最小的一个，再让2与最小的数据进行交换。以此类推，直到N-1趟结束。由此可推断比较次数为N+（N-1）+…..+2+1; public static void main(String[] args) { int[] chooseArray = {10,11,12,16,2,18,9,5,4,29,11}; for (int ele:chooseArray) { System.out.print(ele+\",\"); } System.out.println(\"排序前的遍历数据\"); for (int i =0;i&lt;chooseArray.length-1;i++){ int start = chooseArray[i]; //每次循环的开始数据 int index = i; //获取每次循环的最小下标 int temp = 0; //交换是临时存放值 for (int ele:chooseArray) { System.out.print(ele+\",\"); } System.out.println(\"每一次调用过程数据遍历\"); for (int j=i+1;j&lt;chooseArray.length;j++){ if (start&gt;chooseArray[j]){ //如果开始值大于当前值 start=chooseArray[j]; //把当前值赋予开始值，并与后续的值进行循环大小比较 index=j; //并记录当前下标 } } if(index!=i){ //如果本次循环下标不等于index则表示当前循环的最小值非开始值 temp = chooseArray[i]; //把开始值赋给临时值 chooseArray[i]=start; //把最小值赋给开始位置 chooseArray[index] =temp; //把临时值赋给最小值的下标位置 } } for (int ele:chooseArray) { System.out.print(ele+\",\"); } System.out.println(\"排序后的遍历数据\"); } #每一趟排序后遍历的结果 10,11,12,16,2,18,9,5,4,29,11,每一次调用过程数据遍历 2,11,12,16,10,18,9,5,4,29,11,每一次调用过程数据遍历 2,4,12,16,10,18,9,5,11,29,11,每一次调用过程数据遍历 2,4,5,16,10,18,9,12,11,29,11,每一次调用过程数据遍历 2,4,5,9,10,18,16,12,11,29,11,每一次调用过程数据遍历 2,4,5,9,10,18,16,12,11,29,11,每一次调用过程数据遍历 2,4,5,9,10,11,16,12,18,29,11,每一次调用过程数据遍历 2,4,5,9,10,11,11,12,18,29,16,每一次调用过程数据遍历 2,4,5,9,10,11,11,12,18,29,16,每一次调用过程数据遍历 2,4,5,9,10,11,11,12,16,29,18,每一次调用过程数据遍历 2,4,5,9,10,11,11,12,16,18,29,排序后的遍历数据 2、冒泡排序 冒泡排序是相邻的两个数据进行比较，如果前者大于后者，两则进行交换。每趟比较之后最后一个则为最大数值。 通俗的讲：假设有N条数据，第一趟则先让第一条与第二条比较，如果第一条大于第二条则两条数据进行交换，否则不进行交互，即值大的放后面，然后第二条在于第三条进行比较得出比较大的值放第三条的位置，以此类推得出最大的一条放在最后面。第二趟还是第一条与第二条相比，得出最大与第三条相比，知道N-1次（最后一条已经为最大了）。由此可推断比较次数为N+（N-1）+…..+2+1。 冒泡排序可中途进行打断，即当发现排序过程中已经排序成功则可进行break打断当前循环，以减少资源浪费。 public static void main(String[] args) { int[] bubbleArray = {10,11,12,16,2,18,9,5,4,29,11}; for (int i =0;i&lt;bubbleArray.length-1;i++){ boolean changeFlag = false; //控制后续如果值无改变可调出循环代表已排序完成 int temp = 0; for (int ele:bubbleArray) { System.out.print(ele+\",\"); } System.out.println(\"第\"+i+\"趟排序前数据\"); for (int j=0;j&lt;bubbleArray.length-1-i;j++){ if (bubbleArray[j]&gt;bubbleArray[j+1]){ //如果第j条数据大于后一条数据 temp=bubbleArray[j]; //则把第j条数据赋给临时数据 bubbleArray[j]=bubbleArray[j+1]; //把后条数据赋给第j条数据 bubbleArray[j+1] =temp; //再把临时数据赋给第j+1条 changeFlag=true; //说明有排序的动作 } } if(!changeFlag){ //如果无排序的动作则进行打断当前循环 break; } } } #当前做了8次循环，如果不打断则会循环数组的11-1=10次 10,11,12,16,2,18,9,5,4,29,11,第0趟排序前数据 10,11,12,2,16,9,5,4,18,11,29,第1趟排序前数据 10,11,2,12,9,5,4,16,11,18,29,第2趟排序前数据 10,2,11,9,5,4,12,11,16,18,29,第3趟排序前数据 2,10,9,5,4,11,11,12,16,18,29,第4趟排序前数据 2,9,5,4,10,11,11,12,16,18,29,第5趟排序前数据 2,5,4,9,10,11,11,12,16,18,29,第6趟排序前数据 2,4,5,9,10,11,11,12,16,18,29,第7趟排序前数据 3、插入排序 插入排序是每次拿出一个值与已排序好的进行比较，直至排序完成。 通俗的讲：假设有N条数据，第一趟让第二条数据与第一条比较如果大于则不交换，小于则进行交换，第二趟则让第三条数据与第二条相比较，如果大于则表明，第三条比第一条也大，无需比较，如果小于则让第三条与第一条进行比较，如果小于则第一条、第二条后移一位，第三条存放第一位数据，如果大于则第一条不变，第二条与第三条交换位置。这样可以保证每次循环过后前面的数据都是排序完成的。由此可推断比较的次数为1+2+……+N-1。 public static void main(String[] args) { int[] insertArray = {10,11,12,16,2,18,9,5,4,29,11}; for (int i =1;i&lt;insertArray.length;i++){ int temp = insertArray[i]; //把要比较的值存入临时 int j ; for (int ele:insertArray) { System.out.print(ele+\",\"); } System.out.println(\"每趟比较前的遍历数据\"); for (j=i;j&gt;0&amp;&amp;insertArray[j-1]&gt;temp;j--){ //如果临时值小于要循环的数值， insertArray[j] =insertArray[j-1]; //需要把当前值往后移位以保证空出一个位置存放临时值 } insertArray[j] =temp; //把临时值存放到循环比较的j的位置 } for (int ele:insertArray) { System.out.print(ele+\",\"); } System.out.println(\"排序完成遍历数据\"); } 10,11,12,16,2,18,9,5,4,29,11,每趟比较前的遍历数据 10,11,12,16,2,18,9,5,4,29,11,每趟比较前的遍历数据 10,11,12,16,2,18,9,5,4,29,11,每趟比较前的遍历数据 10,11,12,16,2,18,9,5,4,29,11,每趟比较前的遍历数据 2,10,11,12,16,18,9,5,4,29,11,每趟比较前的遍历数据 2,10,11,12,16,18,9,5,4,29,11,每趟比较前的遍历数据 2,9,10,11,12,16,18,5,4,29,11,每趟比较前的遍历数据 2,5,9,10,11,12,16,18,4,29,11,每趟比较前的遍历数据 2,4,5,9,10,11,12,16,18,29,11,每趟比较前的遍历数据 2,4,5,9,10,11,12,16,18,29,11,每趟比较前的遍历数据 2,4,5,9,10,11,11,12,16,18,29,排序完成遍历数据 4、快速排序 暂不书写，过程有点复杂，理解排序流程即可。 选取一个参数为基准，依次进行比较，如果比这个基准大放在不动，如果比这个基准小则移动到前面。 5、归并排序 归并排序采用的是归并的思想，即把长的的数组等分分割成小的数组进行排序，最后在一步一步的合成排序。 public static void main(String []args){ int []arr = {9,5,3,7,1,8,4,2,6}; sort(arr); System.out.println(Arrays.toString(arr)); } public static void sort(int []arr){ int []temp = new int[arr.length];//在排序前，先建好一个长度等于原数组长度的临时数组 } private static void sort(int[] arr,int left,int right,int []temp){ if(left&lt;right){ int mid = (left+right)/2; sort(arr,left,mid,temp);//左边归并排序，使得左子序列有序 sort(arr,mid+1,right,temp);//右边归并排序，使得右子序列有序 merge(arr,left,mid,right,temp);//将两个有序子数组合并操作 System.out.println(Arrays.toString(arr)); } } private static void merge(int[] arr,int left,int mid,int right,int[] temp){ int i = left;//左序列指针 int j = mid+1;//右序列指针 int t = 0;//临时数组指针 while (i&lt;=mid &amp;&amp; j&lt;=right){ if(arr[i]&lt;=arr[j]){ temp[t++] = arr[i++]; }else { temp[t++] = arr[j++]; } } while(i&lt;=mid){//将左边剩余元素填充进temp中 temp[t++] = arr[i++]; } while(j&lt;=right){//将右序列剩余元素填充进temp中 temp[t++] = arr[j++]; } t = 0; //将temp中的元素全部拷贝到原数组中 while(left &lt;= right){ arr[left++] = temp[t++]; } } 6、希尔排序 希尔排序(Shell’s Sort)是插入排序的一种又称“缩小增量排序”（Diminishing Increment Sort），是直接插入排序算法的一种更高效的改进版本。即把数组按组进行比较，分组步数为数组的长度除以2的n次方，直至余数为1的时候，进行全局排序，可查看下图。 public static void main(String []args){ int []arr = {9,5,3,7,1,8,4,2,6}; shellSort(arr); System.out.println(Arrays.toString(arr)); } public static void shellSort(int[] arrays) { //增量每次都/2 for (int step = arrays.length / 2; step &gt; 0; step /= 2) { //从增量那组开始进行插入排序，直至完毕 for (int i = step; i &lt; arrays.length; i++) { int j = i; int temp = arrays[j]; // j - step 就是代表与它同组隔壁的元素 while (j - step &gt;= 0 &amp;&amp; arrays[j - step] &gt; temp) { arrays[j] = arrays[j - step]; j = j - step; } arrays[j] = temp; } } }","categories":[{"name":"java基础","slug":"java基础","permalink":"http://www.luckyzmj.cn/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.luckyzmj.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"入门多线程","slug":"入门多线程","date":"2022-03-22T07:32:36.000Z","updated":"2022-04-07T07:08:36.491Z","comments":true,"path":"posts/cfb9084e.html","link":"","permalink":"http://www.luckyzmj.cn/posts/cfb9084e.html","excerpt":"","text":"实现线程的方式有哪些 实现Runnable接口 继承Thread类 实现Callable接口 继承Thread类的调用过程 书写一个类继承Thread类让其具有多线程的功能，并实现run（）方法 启动线程，该类调用start（）方法进行调用 实现runnable接口的调用过程 书写一个类实现Runnable接口让其具有多线程的功能，并实现run()方法 启动线程，new Thread(类的对象)调用start()方法。 实现Callable接口的调用过程//书写一个类实现Callable接口让其具有多线程的功能，并实现call（）方法，且需要自定义一个返回值类型 //实例化对象 CallableTest callableTest = new CallableTest(); //创建一个线程池 1代表之启动一个线程 ExecutorService executorService = Executors.newFixedThreadPool(1); //执行 Future&lt;Boolean&gt; future = executorService.submit(callableTest); //获取结果 boolean f1 = future.get(); //关闭服务 executorService.shutdown(); 线程启动之后，不一定立即执行，而是等待CPU调度，即多个线程执行时结果顺序是不一致的。推荐使用runnable接口，由于java的单继承概念，如果继承Thread类灵活性会很差。 实现callable接口相对于其他两个优点是有返回值且可以抛出异常，缺点是实现比较麻烦。 线程中常用的方法停止线程停止线程的方式不建议使用stop等方法，而是建立一个标志位，如果标志位不成立，则停止该线程，即用手动控制，避免死锁。 public class TestStop implements Runnable{ //设置一个标志位标识是否停止 private boolean flag =true; @Override public void run() { int i=0; while (flag){ System.out.println(\"new Thread\"+i); } } //如果运行此方法标识停止 private void stop(){ this.flag =false; } public static void main(String[] args) { TestStop testStop = new TestStop(); new Thread(testStop).start(); for (int i = 0; i &lt; 500; i++) { System.out.println(\"main\"+i); if(i==450){ testStop.stop(); System.out.println(\"线程停止了\"); } } } } 线程休眠sleep sleep休眠的时间指的是毫秒数 sleep的时间达到后线程进入就绪状态 sleep一般应用于倒计时、网络延迟等 每个对象都会有一个锁，sleep不会释放锁 线程礼让yield//正常流程a线程开始执行、a线程结束执行、b线程开始执行、b线程结束执行 //Thread.yield()可重新让cpu调度，即有可能礼让成功，有可能礼让失败 public class YieldTest implements Runnable{ @Override public void run() { System.out.println(Thread.currentThread().getName()+\"线程开始执行\"); //礼让线程 Thread.yield(); System.out.println(Thread.currentThread().getName()+\"线程结束执行\"); } public static void main(String[] args) { YieldTest yieldTest = new YieldTest(); new Thread(yieldTest,\"a\").start(); new Thread(yieldTest,\"b\").start(); } } 线程插队join//即线程在执行过程中如果添加Thread.join，则需强制执行该对象所在的线程 public class JoinTest implements Runnable { @Override public void run() { for (int i = 0; i &lt; 1000; i++) { System.out.println(\"vip\"+i); } } public static void main(String[] args) throws InterruptedException { JoinTest joinTest = new JoinTest(); Thread thread = new Thread(joinTest); thread.start(); for (int i = 0; i &lt; 500; i++) { if(i==200){ thread.join(); } System.out.println(\"main\"+i); } } } 线程状态观测//锁定状态 Thread.State blocked1 = Thread.State.BLOCKED; //新生状态 运行start方法 Thread.State blocked2 =Thread.State.NEW; //运行状态 运行run方法 Thread.State blocked3 =Thread.State.RUNNABLE; //死亡状态 最后结束时的状态 Thread.State blocked4 =Thread.State.TERMINATED; //睡眠状态 sleep方法 Thread.State blocked5 =Thread.State.TIMED_WAITING; //等待状态 wait方法 Thread.State blocked6 =Thread.State.WAITING; 线程优先级//设置线程的优先级t3.setPriority（数值），最小为1，最大为10，超过抛出异常，优先级高的不一定最先执行，但大概率会优先执行 public class PriorityTest implements Runnable{ @Override public void run() { System.out.println(Thread.currentThread().getName()+\"-&lt;&lt;\"+Thread.currentThread().getPriority()); } public static void main(String[] args) { System.out.println(Thread.currentThread().getName()+\"-&lt;&lt;\"+Thread.currentThread().getPriority()); PriorityTest priorityTest = new PriorityTest(); Thread t1 = new Thread(priorityTest); Thread t2 = new Thread(priorityTest); Thread t3 = new Thread(priorityTest); Thread t4 = new Thread(priorityTest); Thread t5 = new Thread(priorityTest); t1.start(); t2.setPriority(2); t2.start(); t3.setPriority(Thread.MAX_PRIORITY); t3.start(); t4.setPriority(9); t4.start(); t5.setPriority(Thread.MIN_PRIORITY); t5.start(); } } 线程守护 线程分为守护线程和用户线程，我们平常用的都是用户线程 虚拟机必须确保用户线程执行完毕 虚拟机不必等待守护线程执行完毕 守护线程一般用作操作日志、垃圾回收、监控内存等 设置线程为守护线程的方式是Thread.setDaemon(true); //设置线程的优先级t3.setPriority（数值），最小为1，最大为10，超过抛出异常，优先级高的不一定最先执行，但大概率会优先执行 public class PriorityTest implements Runnable{ @Override public void run() { System.out.println(Thread.currentThread().getName()+\"-&lt;&lt;\"+Thread.currentThread().getPriority()); } public static void main(String[] args) { System.out.println(Thread.currentThread().getName()+\"-&lt;&lt;\"+Thread.currentThread().getPriority()); PriorityTest priorityTest = new PriorityTest(); Thread t1 = new Thread(priorityTest); Thread t2 = new Thread(priorityTest); Thread t3 = new Thread(priorityTest); Thread t4 = new Thread(priorityTest); Thread t5 = new Thread(priorityTest); t1.start(); t2.setPriority(2); t2.start(); t3.setPriority(Thread.MAX_PRIORITY); t3.start(); t4.setPriority(9); t4.start(); t5.setPriority(Thread.MIN_PRIORITY); t5.start(); } } 线程同步锁synchronized 锁的对象是变换的对象，即this信息。 用synchronized修饰的方法或者代码块表示同步信息，即一个线程进入某个方法之后，其他线程只能等待当前线程结束才能访问 上锁的功能都是修改的功能 由于每个线程都需要上锁，造成资源浪费 如果线程内部存在调用且也是同步方法时可能会造成死锁 显式锁lock lock是显式锁即需要加锁和解锁的过程，synchronized是隐式锁即出了锁定域自动解锁 lock只能锁定代码块，synchronized能锁定方法和代码块 lock锁的性能更好 线程死锁死锁产生的4个必要条件 互斥条件：一个资源每次只能被一个进程使用 请求和保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放 不可剥夺条件：进程已获得的资源，在未使用完成，不能强行剥夺 循环等待条件：若干进程之间形成一种头尾相接的循环等待关系","categories":[{"name":"java基础","slug":"java基础","permalink":"http://www.luckyzmj.cn/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://www.luckyzmj.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"入门集合","slug":"入门集合","date":"2022-03-21T13:30:41.000Z","updated":"2022-04-07T07:08:36.489Z","comments":true,"path":"posts/4714db61.html","link":"","permalink":"http://www.luckyzmj.cn/posts/4714db61.html","excerpt":"","text":"数组和集合的区别？ 数组是同一类型的数据汇总，长度是固定的，可以通过下标的形式获取值，存入值。 集合是具有某种特质的抽象对象汇成的集体。 相对来说数组适用于简单固定的数据操作，而集合不仅适用于简单的数据操作，也可操作复杂的数据信息。 对简单数据操作来说数组更方便快捷。 //数组的三种创建方式 int[] createOne = new int[]{1,2,3,4,5}; int[] createTwo = {1,2,3,4,5}; int[] createThree = new int[5]; //数组存储值方式，获取值方式 createThree[0] = 1; System.out.println(createThree[0]); createThree[0] = 2; System.out.println(createThree[0]); 谈谈你对集合的理解 集合分为Collection和Map两个大的方向，Collection有包含了Set不重复集合、List可重复集合两种。 Set集合描述 Set是存储无序元素集合，且集合内的元素不会重复。 Set接口的实现方式有很多，例如HashSet、TreeSet、LinkedHashSet等 HashSet的特点是无重复、无序，存储位置是通过特定的hash算法进行获得，存储方式时数组结构，如果两个元素hashCode()相等但equals()不相等时，存储的方式时在数组的基础上增加链表。如果两则均相等则表示重复，具体存储方式可了解hashMap的存储方式。 TreeSet的特点是自然排序，无重复，存储机构是红黑树的形式，判断两个元素是否重复（重写了Comparable的CompareTo方法来判断返回值是否为0，如果0则表示重复） LinkedHashSet的特点是按插入顺序排序，无重复，判断是否重复的方式跟HashSet一致。 //常见的集合操作 Set&lt;String&gt; setOne = new LinkedHashSet&lt;String&gt;(); Set&lt;String&gt; setTwo = new HashSet&lt;String&gt;(); Set&lt;String&gt; setThree = new TreeSet&lt;String&gt;(); //添加元素 setOne.add(\"ea\"); setOne.add(\"a\"); setOne.add(\"dc\"); setOne.add(\"nb\"); setOne.add(\"md\"); setTwo.add(\"ea\"); setTwo.add(\"a\"); setTwo.add(\"dc\"); setTwo.add(\"nb\"); setTwo.add(\"md\"); setThree.add(\"ea\"); setThree.add(\"a\"); setThree.add(\"dc\"); setThree.add(\"nb\"); setThree.add(\"md\"); //遍历元素 setOne.forEach(set-&gt;System.out.print(set+\" \")); System.out.println(\"LinkedHashSet的遍历结果\"); setTwo.forEach(set-&gt;System.out.print(set+\" \")); System.out.println(\"HashSet的遍历结果\"); setThree.forEach(set-&gt;System.out.print(set+\" \")); System.out.println(\"TreeSet的遍历结果\"); //删除元素 setOne.remove(\"d\"); //查看集合是否有值 setOne.isEmpty(); //查看集合的个数 setOne.size(); //查看是否包含元素 setOne.contains(\"d\"); #这是上述三种集合遍历的结果，可看出三种集合的排序方式 ea a dc nb md LinkedHashSet的遍历结果 a nb md ea dc HashSet的遍历结果 a dc ea md nb TreeSet的遍历结果 List集合描述 List集合是存储有序的集合，且集合内的元素是可重复的。 List接口的实现方式有ArrayList,Vector,LinkedList三种方式 ArrayList底层实现方式是数组的结构，方便查找。 Vector底层实现方式也是数组结构，与ArrayList不同之处在于它是线程安全的，所以性能消耗更大，不建议使用 LinkedList底层实现方式时双向链表结构，方便插入、删除。 由于ArrayList插入方式大部分都是尾插法，与LinkedList相比两则在数据插入时ArrayList的效率更高。 再删除时，ArrayList删除的数据更靠后或数据量很小时移动的次数也会很少，两则的效率差不太多，故使用场景中ArrayList运用比较广泛。 //常见的集合操作 List&lt;String&gt; listOne = new ArrayList&lt;String&gt;(); List&lt;String&gt; listTwo = new LinkedList&lt;&gt;(); listOne.add(\"aaa\"); listOne.add(\"bbb\"); listOne.add(\"ccc\"); listTwo.add(\"aaa\"); listTwo.add(\"bbb\"); listTwo.add(\"ccc\"); //遍历操作 listOne.forEach(System.out::print); //集合大小 System.out.println(listOne.size()); //是否为空 System.out.println(listOne.isEmpty()); //是否包含某个数据 System.out.println(listOne.contains(\"aaa\")); //通过下标获取元素 System.out.println(listOne.get(0)); //移除某个元素 System.out.println(listOne.remove(\"aaa\")); //替换某个元素 System.out.println(listOne.set(1,\"aaaaaaa\")); //截取集合 System.out.println(listOne.subList(0,1)); //获取某个元素的下标 System.out.println(listOne.indexOf(\"bbb\")); Map集合描述 Map是一个key/value的键值对集合，key不可重复，value可重复的。 Map接口的实现方式有HashMap、HashTable、TreeMap、LinkedHashMap HashMap是我们最常用且最快速的，key底层数据结构是数组+链表+红黑树形式的，key/value都可为null。 HashTable和HashMap是线程安全的，效率较慢，故不经常用，且key/value都不允许为null。 TreeMap的存储是根据比较器进行排序，跟TreeSet的数据结构层上一致，key不可以为null。 LinkedHashMap是按存储的先后位置进行确定的，key/value都可为null。 Map&lt;String,String&gt; mapOne = new HashMap&lt;String,String&gt;(); //添加数据 mapOne.put(\"aaa\",\"aaaaaaaaaaa\"); //遍历数据 mapOne.forEach((str,str1)-&gt;{ System.out.println(str1); }); //根据key值获取value System.out.println(mapOne.get(\"aaa\")); //判断集合是否为null System.out.println( mapOne.isEmpty()); //查看集合的大小 System.out.println( mapOne.size()); //查看集合是否包含某个key值 System.out.println( mapOne.containsKey(\"aaa\")); //查看集合是否包含某个value值 System.out.println( mapOne.containsValue(\"aaaaaaa\")); //移除某个key值 System.out.println( mapOne.remove(\"aaaaaaa\")); //替换某个key的value值 System.out.println( mapOne.replace(\"aaa\",\"bbbbbbb\")); //清除value的值 mapOne.clear();","categories":[{"name":"java基础","slug":"java基础","permalink":"http://www.luckyzmj.cn/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://www.luckyzmj.cn/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"入门反射基础","slug":"入门反射基础","date":"2022-03-21T12:55:32.000Z","updated":"2022-04-07T07:08:36.490Z","comments":true,"path":"posts/6aeb3d27.html","link":"","permalink":"http://www.luckyzmj.cn/posts/6aeb3d27.html","excerpt":"","text":"正常方式: 引入包名、类名_————————&gt;new对象————————&gt;取得实例化对象 package com.annotation.example.demo.controller; import com.annotation.example.demo.entity.Student; //引入类名 public class Reflection { public void test(){ Student student = new Student(); //new对象 student.getAddress(); //获取对象信息 } } 反射方式： 实例化对象—————————&gt;getClass()方法—————————&gt;获取完整的包类信息 全路径信息—————————&gt;forName()方法—————————&gt;获取完整的包类信息 类名————————————&gt;.class——————————————&gt;获取完整的包类信息 public static void main(String[] args) throws ClassNotFoundException { // 方式1----通过全路径获取student信息 Class c= Class.forName(\"com.annotation.example.demo.entity.Student\"); System.out.println(c.hashCode()); //方式2----通过new对象的getClass()方法获取student信息 Student student = new Student(); Class c2 = student.getClass(); System.out.println(c2.hashCode()); //方式3----通过类名获取student信息 Class c1 = Student.class; System.out.println(c1.hashCode()); } 反射获取基本信息：更多方法可自行测试查看 public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException { // 方式1----通过全路径获取student信息 Class c= Class.forName(\"com.annotation.example.demo.entity.Student\"); System.out.println(c.hashCode()); //获得包名+类名 System.out.println(c.getName()); //获得类名 System.out.println(c.getSimpleName()); //获取public的信息 Field[] fields = c.getFields(); for (Field field : fields) { System.out.println(field); } //获取全部的信息 Field[] declaredFields = c.getDeclaredFields(); for (Field field : declaredFields) { System.out.println(field); } //获取具体某一个的字段 Field name = c.getDeclaredField(\"name\"); System.out.println(name); //获取本类的方法及其父类的额所有方法 Method[] methods = c.getMethods(); for (Method method : methods) { System.out.println(method); } //只获取本类的基本信息 Method[] declaredMethods = c.getDeclaredMethods(); for (Method declaredMethod : declaredMethods) { System.out.println(declaredMethod); } } 常用的获取对象信息的方式 public static void main(String[] args) throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException { Class c = Student.class; //通过newInstance的方式获取对象信息 Student student = (Student) c.newInstance(); student.setName(\"小婉\"); System.out.println(student.getName()); //通过构造器创建对象 Constructor declaredConstructor = c.getDeclaredConstructor(String.class, String.class, int.class); Student student1 = (Student) declaredConstructor.newInstance(\"小婉\", \"驻马店\", 30); System.out.println(student1); //通过获取方法获得对象信息 Student student2 = (Student) c.newInstance(); Method setName = c.getDeclaredMethod(\"setName\", String.class); setName.invoke(student2, \"小婉\"); System.out.println(student2.getName()); //通过反射操作属性 Student student3 = (Student) c.newInstance(); Field name1 = c.getDeclaredField(\"name\"); //不能直接操作私有属性,关闭安全检测，如果反射运用比较多，可以关闭检测提高性能 name1.setAccessible(true); name1.set(student3,\"小婉\"); System.out.println(student3.getName()); } 获取参数类型及返回值类型步骤 public static void main(String[] args) throws NoSuchMethodException { Method method = Reflection2.class.getMethod(\"test1\", Map.class, List.class); //获取test1的方法 Type[] types = method.getGenericParameterTypes(); //获取方法内所有的参数 for (Type type : types) { //便利参数 System.out.println(type); //输出参数 if (type instanceof ParameterizedType){ //查看参数是否属于参数化类型 Type[] typeArguments = ((ParameterizedType) type).getActualTypeArguments(); //把参数强转为参数化类型在获取具体的参数 for (Type typeArgument : typeArguments) { System.out.println(typeArgument); //便利参数并打印 } } } Method method1 = Reflection2.class.getMethod(\"test2\"); Type genericReturnType = method1.getGenericReturnType(); //获取返回参数类型 System.out.println(genericReturnType); if (genericReturnType instanceof ParameterizedType){ //查看参数是否属于参数化类型 Type[] typeArguments = ((ParameterizedType) genericReturnType).getActualTypeArguments(); //把参数强转为参数化类型在获取具体的参数 for (Type typeArgument : typeArguments) { System.out.println(typeArgument); //便利参数并打印 } } } public void test1(Map&lt;String, Student&gt; map, List&lt;Student&gt; list){ System.out.println(\"test1\"); } public Map&lt;String,Student&gt; test2(){ System.out.println(\"test2\"); return null; } 获取注解的值及参数信息 public class Reflection3 { public static void main(String[] args) throws NoSuchFieldException { classAnnotation annotation = Student2.class.getAnnotation(classAnnotation.class); System.out.println(annotation.value()); Field name = Student2.class.getDeclaredField(\"name\"); filedAnnotation annotation1 = name.getAnnotation(filedAnnotation.class); System.out.println(annotation1.id()); System.out.println(annotation1.length()); //db_student //db_id //10 } } @Data @classAnnotation(\"db_student\") class Student2{ @filedAnnotation(id=\"db_id\",length = 10) private String name; @filedAnnotation(id=\"db_address\",length = 19) private String address; @filedAnnotation(id=\"db_age\",length = 3) private int age; } /** * 类注解 */ @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @interface classAnnotation{ String value(); } /** * 字段注解 */ @Target(ElementType.FIELD) @Retention(RetentionPolicy.RUNTIME) @interface filedAnnotation{ String id(); int length(); }","categories":[{"name":"java基础","slug":"java基础","permalink":"http://www.luckyzmj.cn/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"反射","slug":"反射","permalink":"http://www.luckyzmj.cn/tags/%E5%8F%8D%E5%B0%84/"}]},{"title":"序列化","slug":"过时序列化","date":"2022-03-20T13:31:40.000Z","updated":"2022-04-07T07:08:36.503Z","comments":true,"path":"posts/693bdb7c.html","link":"","permalink":"http://www.luckyzmj.cn/posts/693bdb7c.html","excerpt":"","text":"java序列化和反序列化是什么？序列化：把对象转换为字节序列的过程称为对象的序列化。 反序列化：把字节序列恢复为对象的过程称为对象的反序列化。 为什么要用java序列化，它的作用是什么？1、 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中。 2、在网络上传送对象的字节序列。 实现java序列化的方式？javaBean实现Serializable接口。 为什么实现序列化的时要设置 serialVersionUID如果一个M实体在序列化的时候存在A、B、C三个字段，则反序列化的时候也会返回这三个字段。由于需求的变化导致M实体增加了字段D，由于序列化的内容只有三个字段，在进行反序列化的时则会提示异常。故需设置标识来保证反序列化时serialVersionUID是否改变。 javaBean中的字段不被序列化可以吗？使用Transient修饰关键字可以保证字段不被序列化，被反序列化时如果类型为int则默认值为0，对象型的默认值为null。 static修饰的字段为什么不被序列化由于static修饰的字段存在于静态方法区，而不是堆内存中，故不被序列化 总结：使用序列化的目的是把javaBean信息存入到磁盘中，方便进行网络中传输，特别是现在微服务盛行的时代。目前最常见的实现序列化的方式时实现Serializable接口，并且要设置serialVersionUID的版本号以便对象更改时反序列化出错。对于敏感信息不想被序列化可以用Transient关键字进行隐藏，或者用static关键字设置为静态字段。","categories":[{"name":"java基础","slug":"java基础","permalink":"http://www.luckyzmj.cn/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"序列化","slug":"序列化","permalink":"http://www.luckyzmj.cn/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"shiro","slug":"shiro","date":"2022-03-19T12:54:09.000Z","updated":"2022-04-07T07:08:36.486Z","comments":true,"path":"posts/1c025fc.html","link":"","permalink":"http://www.luckyzmj.cn/posts/1c025fc.html","excerpt":"","text":"shiro的核心组件 Subject即主体，外部应用与subject进行交互，subject记录了当前的操作用户，将用户的概念理解为当前操作的主体。外部程序通过subject进行认证授权，而subject是通过SecurityManager安全管理器进行认证授权。 SecurityManager即安全管理器，对全部的subject进行安全管理，它是shiro的核心，负责对所有的subject进行安全管理。通过SecurityManager可以完成subject的认证、授权等，实质上SecurityManager是通过Authenticator进行认证，通过Authorizer进行授权，通过SessionManager进行会话管理等 Authenticator即认证器，对用户身份进行认证，Authenticator是一个接口，shiro提供ModularRealmAuthenticator实现类，通过ModularRealmAuthenticator基本上可以满足大多数需求，也可以自定义认证器 Authorizer即授权器，用户通过认证器认证通过，在访问功能时需要通过授权器判断用户是否有此功能的操作权限 Realm即领域，相当于datasource数据源，securityManager进行安全认证需要通过Realm获取用户权限数据，比如：如果用户身份数据在数据库那么realm就需要从数据库获取用户身份信息 sessionManager即会话管理，shiro框架定义了一套会话管理，它不依赖web容器的session，所以shiro可以使用在非web应用上，也可以将分布式应用的会话集中在一点管理，此特性可使它实现单点登录 CacheManager即缓存管理，将用户权限数据存储在缓存，这样可以提高性能 CredentialsMatcher即密码管理，shiro提供了一套加密/解密的组件，方便开发。比如提供常用的散列、加/解密等功能。 shiro配置的核心代码//自定义的Realm public class CustomRealm extends AuthorizingRealm { //授权方法 @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) { SimpleAuthorizationInfo info=new SimpleAuthorizationInfo(); return info; } //认证方法 @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException { SimpleAuthenticationInfo info=new SimpleAuthenticationInfo(\"\",\"密码\",\"\"); return info; } } //实现自定义的Realm @Bean public CustomRealm customRealm(){ CustomRealm customRealm=new CustomRealm(); return customRealm; } //securityManager安全管理器 @Bean public SecurityManager securityManager(){ DefaultWebSecurityManager defaultWebSecurityManager=new DefaultWebSecurityManager(); defaultWebSecurityManager.setRealm(customRealm()); return defaultWebSecurityManager; } //配置过滤器，过滤或拦截请求 @Bean public ShiroFilterFactoryBean shiroFilterFactoryBean(SecurityManager securityManager){ ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); shiroFilterFactoryBean.setSecurityManager(securityManager); return shiroFilterFactoryBean; } 总结shiro的Realm负责认证和授权功能，认证成功之后统一交给SecurityManager进行管理，ShiroFilterFactoryBean则负责总工程，对一些必要的数据进行过滤。 subject是认证成功之后的主体，可以通过下面代码获取用户信息 Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = (UsernamePasswordToken) subject.getPrincipal(); sessionManager是shiro的session，用来存储密码认证成功之后的数据 cacheManager是缓存管理，如果我们自定义缓存可实现此接口，用途是提高性能、扩展性。 CredentialsMatcher是密码加密策略。","categories":[{"name":"框架","slug":"框架","permalink":"http://www.luckyzmj.cn/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://www.luckyzmj.cn/tags/spring/"}]},{"title":"springboot","slug":"springboot","date":"2022-03-18T15:11:15.000Z","updated":"2022-04-12T00:19:45.125Z","comments":true,"path":"posts/8049be4c.html","link":"","permalink":"http://www.luckyzmj.cn/posts/8049be4c.html","excerpt":"","text":"dependencyManagement和dependencies的区别 dependencyManagement只声明依赖，不实现引入。因此如果子项目需要引入依赖的话需要自己再次声明。目的是为了统一多module之间的version。 如果子项目的dependencies实现了具体依赖，可不加版本号直接实现父类即dependencyManagement内声明的版本号 如果子项目的dependencies实现了具体依赖且有版本号则以子项目声明的为准。 总结类似于java的继承关系。","categories":[{"name":"框架","slug":"框架","permalink":"http://www.luckyzmj.cn/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://www.luckyzmj.cn/tags/spring/"}]},{"title":"springBootSummary","slug":"springBootSummary","date":"2022-03-18T12:58:30.000Z","updated":"2022-04-07T07:08:36.485Z","comments":true,"path":"posts/9cd83123.html","link":"","permalink":"http://www.luckyzmj.cn/posts/9cd83123.html","excerpt":"","text":"dependencyManagement和dependencies的区别 dependencyManagement只声明依赖，不实现引入。因此如果子项目需要引入依赖的话需要自己再次声明。目的是为了统一多module之间的version。 如果子项目的dependencies实现了具体依赖，可不加版本号直接实现父类即dependencyManagement内声明的版本号 如果子项目的dependencies实现了具体依赖且有版本号则以子项目声明的为准。 总结类似于java的继承关系。","categories":[{"name":"总结","slug":"总结","permalink":"http://www.luckyzmj.cn/categories/%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://www.luckyzmj.cn/tags/spring/"}]},{"title":"小技巧","slug":"小技巧","date":"2022-03-15T10:05:37.000Z","updated":"2022-04-22T02:26:45.530Z","comments":true,"path":"posts/a40d665e.html","link":"","permalink":"http://www.luckyzmj.cn/posts/a40d665e.html","excerpt":"","text":"idea中autowired修饰的方法报红点击file-&gt;settings -&gt; Editor-&gt;Inspections 如图：输入spring core 点击Autowring for Bean Class将级别由之前的error改成warning 如果需要去除@Autowired的波浪线，直接把code改为warning即可","categories":[{"name":"java基础","slug":"java基础","permalink":"http://www.luckyzmj.cn/categories/java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"知识点自贴","slug":"知识点自贴","permalink":"http://www.luckyzmj.cn/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%E8%87%AA%E8%B4%B4/"}]},{"title":"idea的常用快捷键","slug":"idea的常用快捷键","date":"2022-03-10T15:31:57.000Z","updated":"2022-04-22T02:05:57.658Z","comments":true,"path":"posts/b5ebccd2.html","link":"","permalink":"http://www.luckyzmj.cn/posts/b5ebccd2.html","excerpt":"","text":"CTRL+ 快捷键 介绍 Ctrl + F 在当前文件进行文本查找 （必备） Ctrl + R 在当前文件进行文本替换 （必备） Ctrl + Z 撤销 （必备） Ctrl + Y 删除光标所在行 或 删除选中的行 （必备） Ctrl + X 剪切光标所在行 或 剪切选择内容 Ctrl + C 复制光标所在行 或 复制选择内容 Ctrl + D 复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 （必备） Ctrl + W 递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围 （必备） Ctrl + E 显示最近打开的文件记录列表 Ctrl N 根据输入的 类名 查找类文件 Ctrl + G 查找当前文件中某一行的信息 Ctrl + J 插入自定义的模板 Ctrl + P 用于提示当前的方法需要哪些参数 Ctrl + Q 光标所在的变量 / 类名 / 方法名的路径 Ctrl + B 进入光标所在的方法/变量的接口或是定义出，等效于 Ctrl + 左键单击 Ctrl + O 选择可重写的方法 Ctrl + I 选择可继承的方法 Ctrl + + 展开代码 Ctrl + - 折叠代码 Ctrl + / 注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 （必备） Ctrl + [ 移动光标到当前所在代码的花括号开始位置 Ctrl + ] 移动光标到当前所在代码的花括号结束位置 Ctrl + F3 调转到所选中的词的下一个引用位置 Ctrl + F4 关闭当前编辑文件 Ctrl + F8 在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点 Ctrl + F9 执行 Make Project 操作 Ctrl + F12 弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选 Ctrl + Tab 编辑窗口切换，如果在切换的过程又加按上delete，则是关闭对应选中的窗口 ALT+ 快捷键 介绍 Alt + Insert 代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等 Alt + F3 选中文本，逐个往下查找相同文本，并高亮显示 Alt + F7 查找光标所在的方法 / 变量 / 类被调用的地方 Alt + F8 在 Debug 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果 Alt + 左方向键 按左方向切换当前已打开的文件视图 Alt + 右方向键 按右方向切换当前已打开的文件视图 Alt + 前方向键 当前光标跳转到当前文件的前一个方法名位置 Alt + 后方向键 当前光标跳转到当前文件的后一个方法名位置 SHIFT+ 快捷键 介绍 Shift + F4 对当前打开的文件，使用新Windows窗口打开，旧窗口保留 Shift + F7 在 Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法 Shift + F8 在 Debug 模式下，跳出，表现出来的效果跟 F9 一样 Shift + Tab 取消缩进 Shift + 左键单击 在打开的文件名上按此快捷键，可以关闭当前打开文件 Shift + 滚轮前后滚动 当前文件的横向滚动轴滚动 CTRL+ALT 快捷键 介绍 Ctrl + Alt + L 格式化代码，可以对当前文件和整个包目录使用 （必备） Ctrl + Alt + B 在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口） Ctrl + Alt + I 光标所在行 或 选中部分进行自动代码缩进，有点类似格式化 Ctrl + Alt + V 快速引进变量 Ctrl + Alt + S 打开 IntelliJ IDEA 系统设置 Ctrl + Alt + F11 切换全屏模式 Ctrl + Alt + Enter 光标所在行上空出一行，光标定位到新行 Ctrl + Alt + 左方向键 退回到上一个操作的地方 （必备）（注意与其他软件快捷键冲突） Ctrl + Alt + 右方向键 前进到上一个操作的地方 （必备）（注意与其他软件快捷键冲突） Ctrl + Alt + 前方向键 在查找模式下，跳到上个查找的文件 Ctrl + Alt + 后方向键 在查找模式下，跳到下个查找的文件 CTRL+SHIFT 快捷键 介绍 Ctrl + Shift + R 根据输入内容查找或替换对应内容，范围为整个项目 或 指定目录内文件 （必备） Ctrl + Shift + J 自动将下一行合并到当前行末尾 （必备） Ctrl + Shift + Z 取消撤销 （必备） Ctrl + Shift + W 递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 （必备） Ctrl + Shift + U 对选中的代码进行大 / 小写轮流转换 （必备） Ctrl + Shift + C 复制当前文件磁盘路径到剪贴板 Ctrl + Shift + + 展开所有代码 Ctrl + Shift + - 折叠所有代码 Ctrl + Shift + F7 高亮显示所有该选中文本，按Esc高亮消失 Ctrl + Shift + F12 编辑器最大化 Ctrl + Shift + Enter 自动结束代码，行末自动添加分号 （必备） Ctrl + Shift + Backspace 退回到上次修改的地方 Ctrl + Shift + 左/右方向键 在代码上选中区域调试，在文件上结构宽度调试 Ctrl + Shift + 后方向键 在代码上上下文件换位，在文件上选中文件 其他 快捷键 介绍 F2 跳转到下一个高亮错误 或 警告位置 （必备） F3 在查找模式下，定位到下一个匹配处 F4 编辑源 F7 在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中 F8 在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内 Tab 缩进 连按两次Shift 弹出 Search Everywhere 弹出层 ​","categories":[{"name":"工具","slug":"工具","permalink":"http://www.luckyzmj.cn/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"idea","slug":"idea","permalink":"http://www.luckyzmj.cn/tags/idea/"}]},{"title":"swagger总结","slug":"swagger总结","date":"2021-04-06T12:57:48.000Z","updated":"2022-04-07T07:08:36.484Z","comments":true,"path":"posts/581519cc.html","link":"","permalink":"http://www.luckyzmj.cn/posts/581519cc.html","excerpt":"","text":"Swagger简介swagger即是一个接口文档生成工具，也是一个接口调用工具，主要目的是解决前后端的即时交互问题。swagger的配置： ApiInfo 文档的简介 enable 是否启动swagger 以便保证生产环境不启动 select ().apis () 可扫描的路径 select().paths() 可匹配的路径 build是固定结束格式 @Configuration @EnableSwagger2 //开启swagger2 public class SwaggerConfig { @Bean public Docket docket(Environment environment){ //读取application.yml读取的环境 Profiles profiles = Profiles.of(\"dev\",\"test\"); //判断运行的环境是否是可读取的环境 boolean flag = environment.acceptsProfiles(profiles); return new Docket(DocumentationType.SWAGGER_2) .apiInfo(new ApiInfo(\"小婉Swagger\", //title \"当一个闲鱼\", //description \"v.1.0\", //版本 \"47.100.69.105\", //服务器地址 new Contact( \"小婉\", \"47.100.69.105\", \"wlkjava@163.com\" ), //个人介绍 \"Apache 2.0\", \"http://www.apache.org/licenses/LICENSE-2.0\", new ArrayList() ) ) //右上角的命名path .groupName(\"learn\") //设置swagger是否启动 .enable(flag) .select() //RequestHandlerSelectors.basePackage扫描包下的所有接口 //RequestHandlerSelectors.any扫描所有接口 具体的可查看源码 .apis(RequestHandlerSelectors.basePackage(\"com.example.swagger.controller\")) //匹配所有符合的路径 .paths(PathSelectors.any()) .build(); } } swagger的常用注解 @ApiModel 用在实体类上的注解 @ApiModelProperty 用在字段上的注解 @ApiOperation 用在方法上的注解 @ApiParam 用在入参上的注解 @Data @ApiModel(value = \"用户信息表\") public class User { @ApiModelProperty(value = \"用户名\") private String userName; @ApiModelProperty(value = \"密码\") private String password; } @ApiOperation(\"测试\") @PostMapping(value = \"/test\") public String test(@ApiParam(value =\"用户名\") String userName){ return userName; } 总结：1、swagger在一些比较难理解的属性或者接口上增加注释信息 （替换了平常书写接口文档的office、wps等） 2、接口文档实时更新（更易于前后端对接、其各部分之间的对接） 3、在线测试工具（替换了接口测试工具，如POSTMan等）","categories":[{"name":"中间件","slug":"中间件","permalink":"http://www.luckyzmj.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[{"name":"swagger","slug":"swagger","permalink":"http://www.luckyzmj.cn/tags/swagger/"}]},{"title":"LuckyBlog开源搭建教程","slug":"BlogOpen","date":"2020-09-16T16:00:00.000Z","updated":"2022-04-07T04:13:22.463Z","comments":true,"path":"posts/d74d8b76.html","link":"","permalink":"http://www.luckyzmj.cn/posts/d74d8b76.html","excerpt":"","text":"前言之前在B站上发布了个人博客的视频，播放量也破千了，有网友私聊也想要搭建一个这样的博客。经过一段时间的准备，现将本人博客的源代码公布出来，大家只需要根据以下的步骤，即可快速搭建一个漂亮完善的博客。 0x01 LuckyBlog 介绍上一个LuckyBlog版本发布于2020年的9月份，是在 洪卫の博客 基础上进行修改的。自从发布以来有很多网友都私信搭建了博客，同时也发现了旧版本中存在的一些问题需要解决，例如：搜索框不适配XML代码搜索，部分图片失效，代码块问题以及各种小问题。现在将最新的LuckyBlog版本代码发布出来，修复改进了不少的BUG，使其更加稳定运行。同时完善了博客的基础功能，例如：音乐、视频、相册、百宝箱等页面。同时增加了不少的新功能，例如：适配Hexo5.x、黑白天浏览模式、仿Windows页面，站点统计等。 博客演示地址：http://luckyzmj.cn/ 开源项目地址：https://github.com/LuckyZmj/LuckyBlog 主题特性 简单漂亮，文章内容美观易读 Material Design 设计 响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现 首页轮播文章及每天动态切换 Banner 图片 瀑布流式的博客文章列表（文章无特色图片时会有 24 张漂亮的图片代替） 时间轴式的归档页 词云的标签页和雷达图的分类页 丰富的关于我页面（包括关于我、文章统计图、我的项目、我的技能、相册等） 可自定义的数据的友情链接页面 支持文章置顶和文章打赏 支持 MathJax TOC 目录，优化了目录显示效果 可设置复制文章内容时追加版权信息 可设置阅读文章时做密码验证 Gitalk、Gitment、Valine 和 Disqus 评论模块（推荐使用 Valine） 集成了不蒜子统计、谷歌分析（Google Analytics）和文章字数统计等功能 支持在首页的音乐播放和视频播放功能 修改了原主题以及基础主题中的一些BUG 加入图片懒加载功能，在根目录配置文件开启和关闭 增加留言板功能 在关于板块,加入简历功能页 增加完善音乐、相册、视频等功能页面 支持emoji表情，用markdown emoji语法书写直接生成对应的能跳跃的表情 增加网站运行时间显示 增加live2d 动漫人物模型 整体替换Banner图片和文章特色图片 增加实用的快捷导航栏功能 修改了一些控件的参数以及部分样式 优化了代码显示块的效果 增加页面樱花飘落动效 增加鼠标点击烟花爆炸动效 增加页面雪花飘落动效 增加博客白云背景效果 增加天气接口控件 加入鼠标点击文字特效 增加DaoVoice在线聊天插件 增加博客代码、图片压缩功能 增加黑白天浏览模式功能 增加仿Windows功能 增加站点统计功能 增加留言版一言功能 其他 0x02 LuckyBlog 安装1. 安装GitGit是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git的作用是将本地的网页文件传到github上。 Git下载地址 Git教程 windows： 到git官网上下载.exe文件,Download git,安装选项全部默认即可。 2. 安装node.jsHexo是基于node.js编写的，所以需要安装一下node.js和里面的npm工具。 windows： 到Node.js官网下载.exe文件，安装选项全部默认。安装好之后，按Win+R打开cmd命令提示符，输入node -v和npm -v，若出现版本号，则说明安装成功。 3. 添加npm国内源使用阿里的国内镜像进行加速下载 npm config set registry https://registry.npm.taobao.org 4. 安装Hexo前面git和nodejs安装好后，就可以安装hexo了，你可以先创建一个文件夹MyBlog，用来存放自己的博客文件，然后cd到这个文件夹下（或者在这个文件夹下直接鼠标右键git bash打开）。 比如我的博客文件都存放在C:\\MyBlog目录下。 在该目录下右键点击Git Bash Here，打开git的控制台窗口，以后我们所有的操作都在git控制台进行，就不用Windows自带的cmd了。 定位到该目录下，输入npm install -g hexo-cli安装Hexo。可能会有几个报错，不用理会。 npm install -g hexo-cli 安装完后输入hexo -v验证是否安装成功。 接下来初始化一下hexo,即初始化我们的博客网站。例如我的在C:\\MyBlog文件夹下的命令行中，输入hexo init初始化文件夹 hexo init 新建完成后，指定文件夹MyBlog目录下有： node_modules: 依赖包 public：存放生成的页面 scaffolds：生成文章的一些模板 source：用来存放你的文章 themes：主题** _config.yml: 博客的配置文件** 到此为止，本地的Hexo基础环境搭建完成了。 5. 安装LuckyBlog下载源代码到本地文件下 git clone https://github.com/LuckyZmj/LuckyBlog.git 将下载好的LuckyBlog全部复制到MyBlog目录下，如果复制过程中出现重复文件，点击替换。 最后使用 npm i 或者 npm install 安装依赖环境包即可。 如果安装依赖环境出错，可以参考这篇文章。 最后执行 hexo clean 和 hexo s -g 启动Hexo本地预览，即可看到效果。 到此为止LuckyBlog安装完成，接下来就是个性化设置了。 0x03 LuckyBlog 个性化 注意！注意！注意！在阅读以下博客个性化之前，最好希望大家有Hexo博客配置主题的基础。如果是完全小白，建议去网上搜索学习相关Hexo搭建博客的过程，另外去B站上也有很多视频教程。博客个性化是需要大家有耐心的，因为每个人的操作不同，在配置过程中可能会遇到一些不可预期的问题，希望大家可以克服这些困难，如有需要帮助，也可以私信博主帮助大家解决问题。 1. 修改部署平台编辑根目录下的配置文件MyBlog/_config.yml，找到如下内容并修改 deploy: - type: git repo: git@github.com:LuckyZmj/LuckyZmj.github.io.git # 替换为你的部署平台地址 branch: master 2. 修改网站信息编辑根目录下的配置文件MyBlog/_config.yml，找到如下内容并修改 # Site title: Luckey subtitle: 'Luckeyの博客' description: '本科 | 计算机科学与技术 | 网络安全' keywords: 'luckyzmj 计算机 网络安全 渗透测试' # 博客网站关键词 author: Luckey # 博主名称 language: zh-CN timezone: '' # URL ## If your site is put in a subdirectory, set url as 'http://example.com/child' and root as '/child/' url: http://www.luckyzmj.cn # 更改为你的博客地址 root: / # permalink: :year/:month/:day/:title/ permalink: posts/:abbrlink.html # p 是自定义的前缀 abbrlink: alg: crc32 #算法： crc16(default) and crc32 rep: hex #进制： dec(default) and hex permalink_defaults: pretty_urls: trailing_index: true # Set to false to remove trailing 'index.html' from permalinks trailing_html: true # Set to false to remove trailing '.html' from permalinks 3. 修改博客头像编辑主题目录下的配置文件MyBlog/themes/matery/_config.yml，找到如下内容并修改 # Configure website favicon and LOGO # 将以下改为自己的头像链接即可 favicon: https://s1.ax1x.com/2020/05/17/YR20js.jpg logo: https://s1.ax1x.com/2020/05/17/YRWsYT.png 4. 修改留言板简介演示效果如下： 编辑 /MyBlog/contact/index.md，修改你想要内容即可 --- title: contact date: 2019-10-25 00:00:00 type: \"contact\" layout: \"contact\" --- ## 畅所欲言 --- 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ ## 友链 --- Lucky_Meの友链信息 博客名称: Lucky_Meの博客 博客网址: http://luckyzmj.cn 博客头像: https://s1.ax1x.com/2020/05/17/YRWsYT.png 博客介绍: 知识面决定攻击面，知识链决定攻击深度！ 5. 修改音乐列表想要修改自己喜欢的音乐之前，需要先获取音乐列表的id。 以QQ音乐为例：先登录QQ音乐网页版，点击打开自己喜欢的音乐列表，在网页的URL处包含了音乐列表的id，如下图所示 编辑主题目录下的配置文件MyBlog/themes/matery/_config.yml，找到如下内容并修改 # 默认是博主的QQ音乐的id，大家可以改为自己音乐喜欢列表的id # 更新完id，就可以同步加载自己喜欢的列表音乐了 # Whether to display the musics. # 是否在首页显示音乐. music: enable: true title: #非吸底模式有效 enable: true show: 听听音乐 autoHide: true # hide automaticaly server: tencent #require music platform: netease, tencent, kugou, xiami, baidu type: playlist #require song, playlist, album, search, artist id: 1776127550 #require song id / playlist id / album id / search keyword fixed: true # 开启吸底模式 autoplay: false # 是否自动播放 theme: '#42b983' loop: 'all' # 音频循环播放, 可选值: 'all', 'one', 'none' order: 'random' # 音频循环顺序, 可选值: 'list', 'random' preload: 'auto' # 预加载，可选值: 'none', 'metadata', 'auto' volume: 0.7 # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效 listFolded: true # 列表默认折叠 hideLrc: true # 隐藏歌词 # Whether to display the musics. # 单独的音乐页面. musics: enable: true title: #非吸底模式有效 enable: true show: 听听音乐 server: tencent #require music platform: netease, tencent, kugou, xiami, baidu type: playlist #require song, playlist, album, search, artist id: 1776127550 #require song id / playlist id / album id / search keyword fixed: false # 开启吸底模式 autoplay: true # 是否自动播放 theme: '#42b983' loop: 'all' # 音频循环播放, 可选值: 'all', 'one', 'none' order: 'random' # 音频循环顺序, 可选值: 'list', 'random' preload: 'auto' # 预加载，可选值: 'none', 'metadata', 'auto' volume: 0.7 # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效 listFolded: false # 列表默认折叠 listMaxHeight: \"525px\" #列表最大高度 6. 绑定 Valine 评论编辑主题目录下的配置文件MyBlog/themes/matery/_config.yml，找到如下内容并修改 # Valine 评论模块的配置，默认为不激活，如要使用，就请激活该配置项，并设置 appId 和 appKey. valine: enable: true appId: Ucrxxxxxxxxxxxxxxxx-xxxxsz # 自行注册valine获取 appKey: zPsLxxxxxxxxxxxxxxerLmd # 自行注册valine获取 notify: true verify: true visitor: true avatar: 'monsterid' # Gravatar style : mm/identicon/monsterid/wavatar/retro/hide pageSize: 10 placeholder: '留下你的足迹..' # Comment Box placeholder background: /medias/comment_bg.png count: true enableQQ: 16463223 # 改为自己的QQ号 recordIP: true requiredFields: - nick - mail guest_info: - nick - mail - link master: - 46606772953bed0812789d6dc955614e # md5加密后的博主邮箱 metaPlaceholder: # 输入框的背景文字 nick: 昵称/QQ号(必填) mail: 邮箱(必填) link: 网址(https://) lang: zh-CN tagMeta: # The String Array of Words to show Flag.[Just Only xCss Style mode] - 博主 - 小伙伴 - 访客 friends: # The MD5 String Array of friends Email to show friends Flag.[Just Only xCss Style mode] - cb3e577ff029d6073400d5557effd41f - 7. 绑定 DaoVoice 在线聊天编辑主题目录下的配置文件MyBlog/themes/matery/_config.yml，找到如下内容并修改 daovoice: enable: true app_id: 4xxxxxxxe #DaoVoice中的app_id 8. 快捷导航页面个性化编辑文件MyBlog/source/tools/index.html，以下简单标记出几处，还有其他涉及到博客信息的内容都需要改为你自己的博客信息即可。 9. 添加友情链接编辑文件MyBlog/suorce/_data/friends.json，按如下格式添加友情 [ { \"avatar\": \"https://s1.ax1x.com/2020/05/17/YRWsYT.png\", \"name\": \"Luckey\", \"introduction\": \"越努力，越幸运\", \"url\": \"http://www.luckyzmj.cn\", \"title\": \"访问主页\" },{ \"avatar\": \"https://sunhwee.com/hwsun.jpg\", \"name\": \"洪卫の博客\", \"introduction\": \"UESTC CVer\", \"url\": \"http://sunhwee.com\", \"title\": \"访问主页\" } ] 10. 添加相册比如你的图片上传图床后，链接地址如下 https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed/galleries/璀璨星空/01.jpg https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed/galleries/璀璨星空/02.jpg https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed/galleries/动漫风景/01.jpg https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed/galleries/动漫风景/02.jpg ... 首先提取出图片链接公共的部分，作为图床地址 https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed/galleries/ 然后再提取图片地址中不同的部分，作为图片地址 璀璨星空/01.jpg 璀璨星空/02.jpg 动漫风景/01.jpg 动漫风景/03.jpg ... 具体怎么分割根据你自己图床的链接格式而定，以上为我的github图床格式为例。 将相册图床的地址改为你自己的图床地址，需要更改两处文件 # 例如我的图床地址为： https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed/galleries/ themes/matery/layout/galleries.ejs themes/matery/layout/gallerie.ejs 为每个相册添加链接地址，在根目录/source/List/galleries/下新建 相册名称 文件夹，并在该文件夹下新建 index.md 最后，在根目录/source/_data/galleries.json中添加图片链接，格式如下, [ { \"name\": \"璀璨星空\", \"cover\": \"璀璨星空/01.jpg\", \"description\": \"璀璨星空\", \"photos\": [ \"璀璨星空/01.jpg\", \"璀璨星空/02.jpg\", \"璀璨星空/03.jpg\", \"璀璨星空/04.jpg\", \"璀璨星空/05.jpg\", \"璀璨星空/06.jpg\", \"璀璨星空/07.jpg\", \"璀璨星空/08.jpg\", \"璀璨星空/09.jpg\", \"璀璨星空/10.jpg\", \"璀璨星空/11.jpg\", \"璀璨星空/12.jpg\", \"璀璨星空/13.jpg\", \"璀璨星空/14.jpg\", \"璀璨星空/15.jpg\", \"璀璨星空/16.jpg\" ] }, { \"name\": \"动漫风景\", \"cover\": \"动漫风景/01.jpg\", \"description\": \"动漫风景\", \"photos\": [ \"动漫风景/01.jpg\", \"动漫风景/02.jpg\", \"动漫风景/03.jpg\", \"动漫风景/04.jpg\", \"动漫风景/05.jpg\", \"动漫风景/06.jpg\", \"动漫风景/07.jpg\", \"动漫风景/08.jpg\", \"动漫风景/09.jpg\", \"动漫风景/10.jpg\", \"动漫风景/11.jpg\", \"动漫风景/12.jpg\", \"动漫风景/13.jpg\", \"动漫风景/14.jpg\", \"动漫风景/15.jpg\", \"动漫风景/16.jpg\" ] } ] 11. 站点统计功能站点统计的数据来源于百度统计,当你的网站被百度收录后就会在百度统计中出现数据，具体效果如下： 由于博客的统计页面数据不能直接从百度站点中调用，因此需要自行从百度站点中将相应数据填入博客站点统计页面的源代码文件中，个人建议每隔一个月手动更新一次数据。 打开MyBlog\\themes\\matery\\layout\\census.ejs文件，将百度统计中的数据填入源代码中，修改代码如下： 11. 仿Windows个性化仿Windows页面是采用YLUI实现的，YLUI提供了社区版本供大家学习使用，具体效果如下： 大家可以查看YLUI官方的开发文档进行开发，有不懂的可以加官方的QQ群：191372634 进行讨论。 12. 博客动漫风格背景图因为在上一个LuckyBlog版本发布的网站风格是偏向动漫风格的，如果大家喜欢动漫风格，只需要替换以下配置即可。 博客每日轮播图： 以下链接图片全部下载保存到MyBlog\\themes\\matery\\source\\medias\\banner中，以0~7.jpg的文件名格式命名即可。 https://cdn.jsdelivr.net/gh/LuckyZmj/LuckyBlog@master/themes/matery/source/medias/banner/0.jpg https://cdn.jsdelivr.net/gh/LuckyZmj/LuckyBlog@master/themes/matery/source/medias/banner/1.jpg https://cdn.jsdelivr.net/gh/LuckyZmj/LuckyBlog@master/themes/matery/source/medias/banner/2.jpg https://cdn.jsdelivr.net/gh/LuckyZmj/LuckyBlog@master/themes/matery/source/medias/banner/3.jpg https://cdn.jsdelivr.net/gh/LuckyZmj/LuckyBlog@master/themes/matery/source/medias/banner/4.jpg https://cdn.jsdelivr.net/gh/LuckyZmj/LuckyBlog@master/themes/matery/source/medias/banner/5.jpg https://cdn.jsdelivr.net/gh/LuckyZmj/LuckyBlog@master/themes/matery/source/medias/banner/6.jpg https://cdn.jsdelivr.net/gh/LuckyZmj/LuckyBlog@master/themes/matery/source/medias/banner/7.jpg 无文章特色背景图： 打开主题配置文件MyBlog\\themes\\matery\\_config.yml，修改替换如下代码即可： # The post featured images that needs to be displayed when there is no image. # 无文章特色图片时需要显示的文章特色图片. featureImages: - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/01.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/02.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/04.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/06.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/07.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/10.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/11.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/12.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/09.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/14.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/15.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/16.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/06.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/02.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/03.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/04.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/07.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/08.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/11.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/10.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/09.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/12.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/13.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/14.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/16.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/15.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/11.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/09.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/03.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/08.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/03.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/13.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/01.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/05.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/14.jpg - https://cdn.jsdelivr.net/gh/LuckyZmj/imgbed@master/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/01.jpg 0x04 更多内容优化以上简单介绍了 LuckyBlog 中一些要修改的个性化地方，其他更详细的优化参考其他关于Matery的文章。以下几篇文章都是基于hexo-theme-matery主题优化的教程，大家如果遇到问题，可以参考其中的方法。 个人博客搭建 Hexo+Github博客搭建完全教程 hexo-theme-matery作者教程 Hexo+github搭建博客(超级详细版，精细入微) hexo（matery）背景、滚动条优化+增加点击跳评论","categories":[{"name":"博客篇","slug":"博客篇","permalink":"http://www.luckyzmj.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"hexo-blog-lucky","slug":"hexo-blog-lucky","permalink":"http://www.luckyzmj.cn/tags/hexo-blog-lucky/"},{"name":"博客搭建教程","slug":"博客搭建教程","permalink":"http://www.luckyzmj.cn/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"}],"author":"luckyzmj"},{"title":"Hexo之渲染绕过","slug":"Hexo-xr","date":"2020-04-27T16:00:00.000Z","updated":"2022-04-07T04:13:22.463Z","comments":true,"path":"posts/17fd92ae.html","link":"","permalink":"http://www.luckyzmj.cn/posts/17fd92ae.html","excerpt":"","text":"0x001 Hexo 渲染 在Hexo部署时会默认渲染source下的所有html页面，但有时候想在Hexo博客上单独自定义html页面或README.md时，却不希望被Hexo渲染。因此对某个文件或者目录进行排除渲染是非常必要的。 0x002 方法一：font matterHexo新建网站页面，然后将你的代码直接写入 index.md 中 在 Front matter 中添加 layout: false，此方法适用于单一的纯HTMLCSS 页面。 --- title: tools date: 2020-04-28 00:00:00 type: \"tools\" layout: false --- 0x003 方法二：skip render在博客根目录下的 _config.yml，找到 skip_render，大概在32行左右，写入你想要的跳过渲染的路径，注意缩进和空格。 # 指定目录跳过hexo渲染 skip_render: - 'tools/*' - 'tools/**' 注释：tools/* 表示在目录 source/fireworks 下的文件全部跳过渲染，tools/** 表示在博客根目录 source/tools/ 文件夹下的文件全部跳过渲染（例如页面的 js、css 在另一个文件夹中）。 0x004 案例：webstack 导航webstack是一个纯静态的网址导航网站，内容均由viggo收集并整理。项目基于bootstrap前端框架开发。 Github：https://github.com/WebStackPage/WebStackPage.github.io 在博客根目录 source/下新建tools，然后新建index.html,将webstack网页源码全选复制粘贴到里面。 本站的webstack源码：view-source:http://luckyzmj.cn/tools/ 注意：将源码里的部分信息以及跳转链接按照你真实个人博客的环境进行修改。 然后打开博客根目录下配置文件_config.yml，找到skip_render，做如下修改： skip_render: - 'tools/*' - 'tools/**' 最后执行hexo clean和hexo s -g 本地预览，检查无误后hexo g -d部署到服务器上即可。 参考文章 https://xiabor.com/2020/04/21/hexo3/#%E5%A6%82%E4%BD%95%E8%B7%B3%E8%BF%87hexo%E7%9A%84%E6%B8%B2%E6%9F%93","categories":[{"name":"博客篇","slug":"博客篇","permalink":"http://www.luckyzmj.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.luckyzmj.cn/tags/Hexo/"},{"name":"渲染绕过","slug":"渲染绕过","permalink":"http://www.luckyzmj.cn/tags/%E6%B8%B2%E6%9F%93%E7%BB%95%E8%BF%87/"}],"author":"Luckey"},{"title":"文字背景粒子特效","slug":"jQuery+CSS3","date":"2020-03-26T16:00:00.000Z","updated":"2022-04-07T04:13:22.473Z","comments":true,"path":"posts/4b3510a4.html","link":"","permalink":"http://www.luckyzmj.cn/posts/4b3510a4.html","excerpt":"","text":"前言一款jQuery+CSS3的文字背景粒子动画特效，一共6种粒子效果，每种文字背景的粒子效果都不同，有漂浮的有坠落的等等。 0x001 特效演示 This is fires This is lines This is hearts This is bubbles This is confetti This is sunbeams .particletext { } .fire > .particle { position: absolute; background-color: rgba(255, 193, 7, 0.5); border-radius: 40px; border-top-right-radius: 0px; -webkit-animation: fires 0.8s linear infinite; animation: fires 0.8s linear infinite; -webkit-transform: rotate(-45deg); transform: rotate(-45deg); opacity: 0; } /*css keyframes 动画*/ @-webkit-keyframes fires { 0% { -webkit-transform: rotate(-70deg) translateY(0%); transform: rotate(-70deg) translateY(0%); } 25% { -webkit-transform: rotate(-20deg) translateY(-5%); transform: rotate(-20deg) translateY(-5%); opacity: 1; } 50% { -webkit-transform: rotate(-70deg) translateY(-10%); transform: rotate(-70deg) translateY(-10%); } 75% { -webkit-transform: rotate(-20deg) translateY(-20%); transform: rotate(-20deg) translateY(-20%); } 100% { -webkit-transform: rotate(-70deg) translateY(-40%); transform: rotate(-70deg) translateY(-40%); opacity: 1; } } @keyframes fires { 0% { -webkit-transform: rotate(-70deg) translateY(0%); transform: rotate(-70deg) translateY(0%); } 25% { -webkit-transform: rotate(-20deg) translateY(-5%); transform: rotate(-20deg) translateY(-5%); opacity: 1; } 50% { -webkit-transform: rotate(-70deg) translateY(-10%); transform: rotate(-70deg) translateY(-10%); } 75% { -webkit-transform: rotate(-20deg) translateY(-20%); transform: rotate(-20deg) translateY(-20%); } 100% { -webkit-transform: rotate(-70deg) translateY(-40%); transform: rotate(-70deg) translateY(-40%); opacity: 1; } } function fire() { $.each($(\".particletext.fire\"), function(){ var firecount = ($(this).width()/50)*20; for(var i = 0; i .particle { position: absolute; background-color: rgba(244, 67, 54, 0.5); -webkit-animation: lines 3s linear infinite; animation: lines 3s linear infinite; } @-webkit-keyframes lines { 0%, 50%, 100% { -webkit-transform: translateY(0%); transform: translateY(0%); } 25% { -webkit-transform: translateY(100%); transform: translateY(100%); } 75% { -webkit-transform: translateY(-100%); transform: translateY(-100%); } } @keyframes lines { 0%, 50%, 100% { -webkit-transform: translateY(0%); transform: translateY(0%); } 25% { -webkit-transform: translateY(100%); transform: translateY(100%); } 75% { -webkit-transform: translateY(-100%); transform: translateY(-100%); } } function lines() { $.each($(\".particletext.lines\"), function(){ var linecount = ($(this).width()/50)*10; for(var i = 0; i .particle { opacity: 0; position: absolute; background-color: #cc2a5d; -webkit-animation: hearts 3s ease-in infinite; animation: hearts 3s ease-in infinite; } .hearts > .particle:before,.hearts > .particle:after { position: absolute; content: ''; border-radius: 100px; top: 0px; left: 0px; width: 100%; height: 100%; background-color: #cc2a5d; } .hearts > .particle:before { -webkit-transform: translateX(-50%); transform: translateX(-50%); } .hearts > .particle:after { -webkit-transform: translateY(-50%); transform: translateY(-50%); } @-webkit-keyframes hearts { 0% { opacity: 0; -webkit-transform: translate(0, 0%) rotate(45deg); transform: translate(0, 0%) rotate(45deg); } 20% { opacity: 0.8; -webkit-transform: translate(0, -20%) rotate(45deg); transform: translate(0, -20%) rotate(45deg); } 100% { opacity: 0; -webkit-transform: translate(0, -1000%) rotate(45deg); transform: translate(0, -1000%) rotate(45deg); } } @keyframes hearts { 0% { opacity: 0; -webkit-transform: translate(0, 0%) rotate(45deg); transform: translate(0, 0%) rotate(45deg); } 20% { opacity: 0.8; -webkit-transform: translate(0, -20%) rotate(45deg); transform: translate(0, -20%) rotate(45deg); } 100% { opacity: 0; -webkit-transform: translate(0, -1000%) rotate(45deg); transform: translate(0, -1000%) rotate(45deg); } } function hearts() { $.each($(\".particletext.hearts\"), function(){ var heartcount = ($(this).width()/50)*5; for(var i = 0; i .particle { opacity: 0; position: absolute; background-color: rgba(33, 150, 243, 0.5); -webkit-animation: bubbles 3s ease-in infinite; animation: bubbles 3s ease-in infinite; border-radius: 100%; } @-webkit-keyframes bubbles { 0% { opacity: 0; } 20% { opacity: 1; -webkit-transform: translate(0, -20%); transform: translate(0, -20%); } 100% { opacity: 0; -webkit-transform: translate(0, -1000%); transform: translate(0, -1000%); } } @keyframes bubbles { 0% { opacity: 0; } 20% { opacity: 1; -webkit-transform: translate(0, -20%); transform: translate(0, -20%); } 100% { opacity: 0; -webkit-transform: translate(0, -1000%); transform: translate(0, -1000%); } } function bubbles() { $.each($(\".particletext.bubbles\"), function(){ var bubblecount = ($(this).width()/50)*10; for(var i = 0; i .particle { opacity: 0; position: absolute; -webkit-animation: confetti 3s ease-in infinite; animation: confetti 3s ease-in infinite; } .confetti > .particle.c1 { background-color: rgba(76, 175, 80, 0.5); } .confetti > .particle.c2 { background-color: rgba(156, 39, 176, 0.5); } @-webkit-keyframes confetti { 0% { opacity: 0; -webkit-transform: translateY(0%) rotate(0deg); transform: translateY(0%) rotate(0deg); } 10% { opacity: 1; } 35% { -webkit-transform: translateY(-800%) rotate(270deg); transform: translateY(-800%) rotate(270deg); } 80% { opacity: 1; } 100% { opacity: 0; -webkit-transform: translateY(2000%) rotate(1440deg); transform: translateY(2000%) rotate(1440deg); } } @keyframes confetti { 0% { opacity: 0; -webkit-transform: translateY(0%) rotate(0deg); transform: translateY(0%) rotate(0deg); } 10% { opacity: 1; } 35% { -webkit-transform: translateY(-800%) rotate(270deg); transform: translateY(-800%) rotate(270deg); } 80% { opacity: 1; } 100% { opacity: 0; -webkit-transform: translateY(2000%) rotate(1440deg); transform: translateY(2000%) rotate(1440deg); } } function confetti() { $.each($(\".particletext.confetti\"), function(){ var confetticount = ($(this).width()/50)*10; for(var i = 0; i .particle { position: absolute; background-color: rgba(253, 216, 53, 0.5); -webkit-animation: sunbeams 3s linear infinite; animation: sunbeams 3s linear infinite; } @-webkit-keyframes sunbeams { 0% { -webkit-transform: translateY(40%) rotate(0deg); transform: translateY(40%) rotate(0deg); } 50% { -webkit-transform: translateY(-40%) rotate(180deg); transform: translateY(-40%) rotate(180deg); } 100% { -webkit-transform: translateY(40%) rotate(360deg); transform: translateY(40%) rotate(360deg); } 0%,14%,17%,43%,53%,71%,80%,94%,100% { opacity: 0; } 6%,15%,24%,28%,48%,55%,78%,82%,99% { opacity: 1; } } @keyframes sunbeams { 0% { -webkit-transform: translateY(40%) rotate(0deg); transform: translateY(40%) rotate(0deg); } 50% { -webkit-transform: translateY(-40%) rotate(180deg); transform: translateY(-40%) rotate(180deg); } 100% { -webkit-transform: translateY(40%) rotate(360deg); transform: translateY(40%) rotate(360deg); } 0%,14%,17%,43%,53%,71%,80%,94%,100% { opacity: 0; } 6%,15%,24%,28%,48%,55%,78%,82%,99% { opacity: 1; } } function sunbeams() { $.each($(\".particletext.sunbeams\"), function(){ var linecount = ($(this).width()/50)*10; for(var i = 0; i","categories":[{"name":"前端篇","slug":"前端篇","permalink":"http://www.luckyzmj.cn/categories/%E5%89%8D%E7%AB%AF%E7%AF%87/"}],"tags":[{"name":"jQuery+CSS3","slug":"jQuery-CSS3","permalink":"http://www.luckyzmj.cn/tags/jQuery-CSS3/"},{"name":"粒子特效","slug":"粒子特效","permalink":"http://www.luckyzmj.cn/tags/%E7%B2%92%E5%AD%90%E7%89%B9%E6%95%88/"}],"author":"Luckey"},{"title":"PicGo+GitHub 图床搭建","slug":"PicGo-GitHub","date":"2020-03-14T16:00:00.000Z","updated":"2022-04-07T04:13:22.472Z","comments":true,"path":"posts/7a46f93c.html","link":"","permalink":"http://www.luckyzmj.cn/posts/7a46f93c.html","excerpt":"","text":"前言用GitHub搭建图床，在很久之前我就有了解，但由于市面上有挺多免费的图床，比如我之前一直在用的 路过图床，所以一直懒得动手搭建GitHub图床。一直到前两天我在完善博客的相册时，发现 路过图床 免费版的有这么多限制，比如：每小时限制上传50张图片，每天限制上传100张图片，而且免费版用户的存储容量貌似不过300M，这才意识到有一个自己的GitHub图床是多么重要。 0x001 PicGO 介绍PicGo是一款图片上传工具，目前支持 SM.MS图床、腾讯云COS、GitHub图床、七牛图床、Imgur图床、阿里云OSS、又拍云图床，未来将支持更多图床。 在支持的这些图床中，SM.MS和Imgur有免费版和收费版，免费版的肯定有很多的使用限制，比如每小时限制上传次数，限制用户的上传容量等等；腾讯云COS、阿里云、有拍云都是要收费使用的；七牛云貌似前期使用免费，后期又要收费才能使用，就剩下的GitHub才是免费且最可靠的。 PicGo源项目GitHub地址已给出，但是去GitHub下载速度非常慢，这里额外提供一个蓝奏云的快速下载地址。 GitHub地址：https://github.com/Molunerfinn/PicGo 蓝奏云地址：https://luckyzmj.lanzous.com/id3e0id 0x002 GitHub 图床1. 创建GitHub图床仓库首先需要有一个登录GitHub的账号，没有的话去GitHub官网注册一个 创建一个新的图床仓库，点击右上角的New repository 填写如下配置信息，然后Create创建仓库 2. 获取GitHub token值点击右上的头像，选择设置Setting 点击选择Developer settings 点击 Generate New token 填写如下配置信息，只要勾选repo选项即可，然后页面拉到底部点击Generate token 即可 此时会跳转到带有token的页面，将token值复制记录下来，之后用PicGo绑定GitHub图床时会利用到 0x003 PicGo 配置1. 绑定GitHub图床首先下载安装好PicGo软件，然后在右列表找到GitHub图床配置 1. 设定仓库名(必填)： 按照“GitHub账户名/仓库名的格式填写”，比如我的是：Luckyzmj/imgbed 2. 设定分支名(必填)： 仓库分支名填写”master”或者”main”，视情况而定。因为GitHub 官方表示,从2020年10月1日起,在该平台上创建的所有新的源代码仓库将默认被命名为”main”,而不是原先的”master”。 3. 设定Token(必填)： 将之前步骤的Token值复制粘贴到这里 4. 指定存储路径： 这个选项可以为空，如果想将图片上传到仓库的指定目录下，可以填写目录名加/，比如我的imgbed仓库下有个posts文件夹，需设置为 posts/ 5. 设定自定义域名： 这里统一用jsdelivr的CDN加速域名，在上传图片后成功后，PicGo会将“自定义域名+上传的图片名”生成的访问链接 自定义域名格式：https://cdn.jsdelivr.net/gh/GitHub账户名/仓库名 以我的格式为例：https://cdn.jsdelivr.net/gh/Luckyzmj/imgbed 配置完全部信息后，点击 设为默认图床，最后点击确定即可 2. 上传图片到图床在上传区上传图片，可支持本地图片上传(可多选图片)、剪贴板上传、URL上传等三种方式。上传图片成功后，选择你想要生成的图片链接格式 在图片区，可以看到成功上传的图片，选择相应的图片进行操作即可 3. PicGo 注意事项如果配置完PicGo后却上传图片失败，可以参考以下方法： 检查自定义域名是否正确 仓库名不要有空格 图片名字不要带有特殊符号，如：%、+、*、空格等 建议开启时间戳重命名，防止图片名字重复 上传图片间歇太短，需在PicGo设置中关闭Server选项 PicGo应用不稳定因素，需重启应用 参考文章 https://blog.csdn.net/sunhwee/article/details/100109956","categories":[{"name":"博客篇","slug":"博客篇","permalink":"http://www.luckyzmj.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"http://www.luckyzmj.cn/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"http://www.luckyzmj.cn/tags/GitHub%E5%9B%BE%E5%BA%8A/"}],"author":"Luckey"},{"title":"阿里云服务器部署Hexo博客","slug":"blog-aliyun","date":"2020-02-26T16:00:00.000Z","updated":"2022-04-07T04:13:22.473Z","comments":true,"path":"posts/19d2a4e6.html","link":"","permalink":"http://www.luckyzmj.cn/posts/19d2a4e6.html","excerpt":"","text":"前言 相信大部分人使用Hexo搭建个人博客都会部署到一些免费的代码托管平台上，但这些免费的平台总是差强人意，比如国外的GitHub平台虽然完全免费，但在国内访问加载速度非常慢，又或者是国内的码云平台免费版有许多功能被阉割掉了，比如不能自定义域名，不能每次自动刷新提交的代码，需要到码云平台上手动刷新，如此一来非常繁琐。 为了有效解决上诉的一些问题，有条件的话，不妨在自己的云服务器上搭建Hexo博客。 效果演示 这是Hexo博客部署到GitHub上的网站测速效果 这是Hexo博客部署到阿里云服务器后的网站测速效果 环境准备 本地环境：Windows 10 云服务器环境：阿里云ECS（CentOS7.x） 开始部署 本地环境搭建1.安装Git 到git官网上下载.exe文件,Download git,安装选项还是全部默认，最后一步添加路径时选择Use Git from the Windows Command Prompt。 Git下载地址 Git教程 2.安装Nodejs 到Node.js官网下载.exe文件，安装选项全部默认。安装好之后，按Win+R打开cmd命令提示符，输入node -v和npm -v，若出现版本号，则说明安装成功。 使用npm阿里的国内镜像进行加速下载 npm config set registry https://registry.npm.taobao.org 4.安装Hexo 先创建一个文件夹MyBlog，用来存放自己的博客文件，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash here打开）。 定位到该目录下，输入npm install -g hexo-cli安装Hexo。可能会有几个报错，不用理会。 npm install -g hexo-cli 安装完后输入hexo -v,若出现版本号则，说明安装成功。 接下来初始化一下hexo,即初始化我们的博客，输入hexo init初始化文件夹 hexo init MyBlog 新建完成后，指定文件夹MyBlog目录下有： node_modules: 依赖包 public：存放生成的页面 scaffolds：生成文章的一些模板 source：用来存放你的文章 themes：主题** _config.yml: 博客的配置文件** 输入hexo g生成静态网页，然后输入hexo s打开本地服务器预览 hexo g hexo s 生成ssh公钥在本地桌面点击右键Git Bash Here打开Git终端，执行如下命令`,一路回车 ssh-keygen -t rsa 这个时候它会告诉你已经生成了.ssh的文件夹。在git bash中输入 cat ~/.ssh/id_rsa.pub 输出的内容就是公钥信息了 阿里云服务器环境搭建安装Git yum install git 创建Git账户 adduser git 添加账户权限 chmod 740 /etc/sudoers vim /etc/sudoers 找到 ## Allow root to run any commands anywhere root ALL=(ALL) ALL 添加以下内容 git ALL=(ALL) ALL 保存退出并改回权限 chmod 400 /etc/sudoers 设置git账户密码 sudo passwd git 切换至git用户，创建 ~/.ssh 文件夹和 ~/.ssh/authorized_keys 文件，并赋予相应的权限 su git mkdir ~/.ssh vim ~/.ssh/authorized_keys # 然后将win10中生成的id_rsa.pub文件中的公钥复制到authorized_keys chmod 600 /home/git/.ssh/authorized_keys chmod 700 /home/git/.ssh 在本地Git终端中测试是否能免密登录git，其中SERVER为填写自己的云主机IP，执行输入yes后不用密码就说明好了 ssh -v git@SERVER 创建目录 #repo作为为Git仓库目录 mkdir /var/repo chown -R git:git /var/repo chmod -R 755 /var/repo #hexo作为网站根目录 mkdir /var/www/hexo chown -R git:git /var/www/hexo chmod -R 755 /var/www/hexo 然后创建一个裸的 Git 仓库 cd var/repo git init --bare hexoBlog.git 创建一个新的 Git 钩子，用于自动部署 在 /var/repo/hexoBlog.git 下，有一个自动生成的 hooks 文件夹。我们需要在里边新建一个新的钩子文件 post-receive。 vim /var/repo/hexoBlog.git/hooks/post-receive 按 i 键进入文件的编辑模式，在该文件中添加两行代码（将下边的代码粘贴进去)，指定 Git 的工作树（源代码）和 Git 目录（配置文件等） #!/bin/bash git --work-tree=/var/www/hexo --git-dir=/var/repo/hexoBlog.git checkout -f 然后，按 Esc 键退出编辑模式，输入”:wq” 保存退出。 修改文件权限，使得其可执行 chown -R git:git /var/repo/hexoBlog.git/hooks/post-receive chmod +x /var/repo/hexoBlog.git/hooks/post-receive 到此为止 Git 仓库就搭建完成了。 阿里云服务器配置Nginx用宝塔面板来一键部署Nginx Linux面板6.0安装命令(暂时仅兼容Centos7.x，其它系统版本请安装5.9稳定版)： yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; bash install.sh Linux面板6.0升级专业版 curl http://download.bt.cn/install/update6.sh|bash 安装完成后会显示面板后台地址·账号·密码。打开面板后台地址登陆面板，选择Nginx的部署方案，静静等待部署。 部署完成，点击网站-添加站点-输入域名(没有域名的输入自己的IP地址)-底部的PHP版本选择”纯静态”-提交。 网站创建完成后点击设置-配置文件 server { listen 80; # server_name 填写自己的域名 server_name luckyzmj.cn blog.luckyzmj.cn; index index.php index.html index.htm default.php default.htm default.html; # 这里root填写自己的网站根目录，修改为/var/www/hexo root /var/www/hexo; -保存 点击设置-网站目录，修改为/var/www/hexo ，保存 重启宝塔面板服务 service bt restart 本地Hexo部署到阿里云服务器进入到本地Hexo博客的文件夹MyBlog,右键点击Git Bash Here，输入命令 #定义邮箱(更换为你的邮箱地址就行) git config --global user.email \"you@example.com\" #定义名称(更换自定义一个名称就行) git config --global user.name \"Your Name\" 配置_config.yml,完成自动化部署 打开本地Hexo博客的文件夹MyBlog文件夹下的_config.yml, 找到deploy deploy: type: git #server改为你的服务IP地址或解析后的域名 #例如我改为repo: git@luckyzmj.cn:/var/repo/blog.git repo: git@server:/var/repo/blog.git branch: master 保存后，即可测试部署 再进入到本地Hexo博客的文件夹MyBlog,右键点击Git Bash Here，输入命令 hexo clean hexo g -d 不报错说明完成，打开浏览器输入你的域名或ip地址就可以看到你部署的Hexo博客了。 到此为止，我们已经成功部完成，并且访问自己的服务器端比访问Github快多了。 小贴士 在部署过程中，执行 hexo d发现部署老是出错，什么权限不允许之类的，这里我们需要检查我们在上述的git操作部署是否使用了git用户操作，若是没有，需要给相应的目录更改用户组 使用 chown -R git:git /var/repo/ 这条命令递归的将repo目录及其子目录用户组设置为git。 同时使用 chown -R git:git /var/www/hexo 这样即可解决此类问题。 还有一个问题就是绑定域名后不能访问。原因是在国内任何域名只要绑定到国内的服务器主机上都必须去工信部和公安部备案完后才能正常使用。如果是港澳台的服务器或者是国外的服务器则可以不需要备案。 参考文章 https://blog.csdn.net/weixin_33907511/article/details/91398208?utm_source=distribute.pc_relevant.none-task","categories":[{"name":"博客篇","slug":"博客篇","permalink":"http://www.luckyzmj.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.luckyzmj.cn/tags/Hexo/"},{"name":"阿里云","slug":"阿里云","permalink":"http://www.luckyzmj.cn/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"博客","slug":"博客","permalink":"http://www.luckyzmj.cn/tags/%E5%8D%9A%E5%AE%A2/"}],"author":"Luckey"},{"title":"个人博客搭建","slug":"Blog","date":"2019-08-27T03:41:03.000Z","updated":"2022-04-07T04:13:22.462Z","comments":true,"path":"posts/e3e08109.html","link":"","permalink":"http://www.luckyzmj.cn/posts/e3e08109.html","excerpt":"","text":"0x001 效果演示 0x002 简单介绍 前前后后大概花了一周多的时间，目前个人博客已经完善的差不多了，现在写个文章做个阶段总结，后续如果有更新的地方，会及时补充。本博客基于Hexo框架，采用hexo-theme-matery主题，在这里非常感谢作者洪卫的hexo-blog-fly博客开源，极大简化了构建博客的工作量和复杂度。在此开源博客的基础上做了改进，修复了一些bug，顺利搭建完成了我的个人博客。大家对此主题有兴趣的可以下载源代码，搭建属于自己的个性化博客。 个人博客 演示：http://luckyzmj.cn 0x003 Hexo 初级搭建 1. 安装GitGit是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git的作用是将本地的网页文件传到github上。 Git下载地址 Git教程 windows： 到git官网上下载.exe文件,Download git,安装选项还是全部默认，最后一步添加路径时选择Use Git from the Windows Command Prompt。 2. 安装node.jsHexo是基于node.js编写的，所以需要安装一下node.js和里面的npm工具。 windows： 到Node.js官网下载.exe文件，安装选项全部默认。安装好之后，按Win+R打开cmd命令提示符，输入node -v和npm -v，若出现版本号，则说明安装成功。 3. 添加npm国内源使用阿里的国内镜像进行加速下载 npm config set registry https://registry.npm.taobao.org 4. 安装Hexo前面git和nodejs安装好后，就可以安装hexo了，你可以先创建一个文件夹MyBlog，用来存放自己的博客文件，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash打开）。 比如我的博客文件都存放在E:\\MyBlog目录下。 在该目录下右键点击Git Bash Here，打开git的控制台窗口，以后我们所有的操作都在git控制台进行，就不用Windows自带的cmd了。 定位到该目录下，输入npm install -g hexo-cli安装Hexo。可能会有几个报错，不用理会。 npm install -g hexo-cli 安装完后输入hexo -v验证是否安装成功。 到此为止hexo就安装完了。 接下来初始化一下hexo,即初始化我们的网站，输入hexo init初始化文件夹 hexo init MyBlog 新建完成后，指定文件夹MyBlog目录下有： node_modules: 依赖包 public：存放生成的页面 scaffolds：生成文章的一些模板 source：用来存放你的文章 themes：主题** _config.yml: 博客的配置文件** 到此为止，本地的网站配置完成了。 输入hexo g生成静态网页，然后输入hexo s打开本地服务器 hexo g hexo s 5. 注册Github账号创建个人仓库接下来就去注册一个github账号，用来存放我们的网站。 打开https://github.com/，新建一个项目仓库New repository，如下所示： 然后如下图所示，输入自己的项目名字，后面一定要加.github.io后缀，README初始化也要勾上 要创建一个和你用户名相同的仓库，后面加.github.io，只有这样，将来要部署到GitHub page的时候，才会被识别，也就是http://xxxx.github.io，其中xxx就是你注册GitHub的用户名。例如我的：http://LuckyZmj.github.io 6. 生成SSH添加到GitHub生成SSH添加到GitHub，连接Github与本地。右键打开git bash here，然后输入下面命令： git config --global user.name \"注册GitHub用户名\" git config --global user.email \"注册GitHub的邮箱\" 用以下两条，检查一下你有没有输对 git config user.name git config user.email 然后创建SSH,一路回车 ssh-keygen -t rsa -C \"注册GitHub的邮箱\" 这个时候它会告诉你已经生成了.ssh的文件夹。在git bash中输入 cat ~/.ssh/id_rsa.pub 将输出的内容复制到框中，点击确定保存。 打开github，在头像下面点击settings，再点击SSH and GPG keys，新建一个SSH，名字随便取一个都可以，把你的id_rsa.pub里面的信息复制进去。如图： 在git bash输入ssh -T git@github.com，如果如下图所示，出现你的用户名，那就成功了。 ssh -T git@github.com 7. 将hexo部署到GitHub将hexo生成的文章部署到GitHub上，打开博客根目录下的_config.yml文件，这是博客的配置文件，在这里你可以修改与博客配置相关的各种信息。找到如下配置进行修改： deploy: type: git repository: https://github.com/LuckyZmj/LuckyZmj.github.io branch: master repository修改为你自己的github项目地址即可，就是部署时，告诉工具，将生成网页通过git方式上传到你对应的链接仓库中。 这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。 npm install hexo-deployer-git --save 然后就可以部署提交到github，过一会儿就可以在http://yourname.github.io 这个网站看到你的博客了 hexo clean hexo generate hexo deploy 其中 hexo clean清除了你之前生成的东西。 hexo generate，生成静态文章，可以用 hexo g缩写 ，hexo deploy部署文章，可以用hexo d缩写 注意deploy时可能要你输入username和password。 8. 写文章和发布文章首先在博客根目录下右键打开git bash here，安装一个扩展npm i hexo-deployer-git。 npm i hexo-deployer-git 然后输入hexo new post \"article title\"，新建一篇文章。 hexo new post \"article title\" 然后打开E:\\MyBlog\\source\\_posts的目录，可以发现下面多了一个文件夹和一个.md文件，一个用来存放你的图片等数据，另一个就是你的文章文件。 另外推荐直接使用有道云编写markdown文章，不仅可以实时预览，还可以快捷的生成markdown语法格式，具体效果如下图所示。 编写完markdown文件后，根目录下输入hexo g生成静态网页，然后输入hexo s可以本地预览效果，最后输入hexo d上传到github上。这时打开你的github.io主页就能看到发布的文章了。 到此为止，Hexo初级搭建就已经完成了。 0x004 Hexo 优化定制 1. Hexo相关目录文件1.1 博客目录构成介绍node_modules是node.js各种库的目录，public是生成的网页文件目录，scaffolds里面就三个文件，存储着新文章和新页面的初始设置，source是我们最常用到的一个目录，里面存放着文章、各类页面、图像等文件，themes存放着主题文件，一般也用不到。 我们平时写文章只需要关注source/_posts这个文件夹就行了。 - node_modules - public - scaffolds - source - _data - _posts - about - archives - categories - friends - tags - themes 1.2 hexo基本配置在文件根目录下的_config.yml，就是整个hexo框架的配置文件了。可以在里面修改大部分的配置。详细可参考官方的配置描述。 1.2.1 网站参数描述title网站标题subtitle网站副标题description网站描述author您的名字language网站使用的语言timezone网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。 其中，description主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。author参数用于主题显示文章的作者。 1.2.2 网址参数描述url网址root网站根目录 permalink文章的永久链接格式permalink_defaults永久链接中各部分的默认值 在这里，你需要把url改成你的网站域名。 permalink，也就是你生成某个文章时的那个链接格式。 比如我新建一个文章叫temp.md，那么这个时候他自动生成的地址就是http://yoursite.com/2018/09/05/temp。 以下是官方给出的示例，关于链接的变量还有很多，需要的可以去官网上查找永久链接 。 参数结果 :year/:month/:day/:title /2019/08/10/hello-world :year-:month-:day-:title.html 2019-08-10-hello-world.html :category/:titlefoo /bar/hello-world 2. 定制主题这里推荐作者洪卫的hexo-blog-fly博客主题，该主题是基于hexo-theme-matery优化的，需要把博客相关信息换成您自己的就可以部署了，极大简化了构建博客的工作量和复杂度。 2.1 简单使用方法 安装Git, 安装nodeJS，安装Hexo 你可以直接fork一份源码到你的仓库，clone到本地博客文件夹内 在本地博客仓库运行npm i命令安装依赖包 直接修改配置信息，改成自己的信息 运行命令hexo clean（清除生成文件），hexo g（生成网页）， hexo s（本地预览），hexo d（部署） 2.2 原主题特性: 简单漂亮，文章内容美观易读 Material Design 设计 响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现 首页轮播文章及每天动态切换 Banner 图片 瀑布流式的博客文章列表（文章无特色图片时会有 24 张漂亮的图片代替） 时间轴式的归档页 词云的标签页和雷达图的分类页 丰富的关于我页面（包括关于我、文章统计图、我的项目、我的技能、相册等） 可自定义的数据的友情链接页面 支持文章置顶和文章打赏 支持 MathJax TOC 目录 可设置复制文章内容时追加版权信息 可设置阅读文章时做密码验证 Gitalk、Gitment、Valine 和 Disqus 评论模块（推荐使用 Gitalk） 集成了不蒜子统计、谷歌分析（Google Analytics）和文章字数统计等功能 支持在首页的音乐播放和视频播放功能 2.3 新增加特性: 修改了原主题的一些很多bug 加入图片懒加载功能，在根目录配置文件开启和关闭 增加留言板功能 在关于板块,加入简历功能页 增加视听[视觉听觉影音]板块 支持emoji表情，用markdown emoji语法书写直接生成对应的能跳跃的表情。 增加网站运行时间显示 增加动漫模型 整体替换Banner图片和文章特色图片 增加分类相册功能 修改了一些控件的参数 修改部分样式,比如: 文章卡片,固定高度,使其不至于因为文章摘要的长短不同导致卡片大小不一使页面布局很不美观,类似的还有友链卡片,优化了页面内容布局,视觉更整齐美观 解决首页文章列表卡片上方 border-radius圆角失效的bug 添加页面樱花飘落动效 添加鼠标点击烟花爆炸动效 加入天气接口控件 加入鼠标点击文字特效 添加页面雪花飘落动效 添加在线聊天插件 调整线聊天插件参数，使之能够随着鼠标滑动位置自适应调整 持续更新… 2.4 切换主题如果想自己动手对hexo-theme-matery优化的话，可以修改Hexo根目录下的 _config.yml的 theme 的值 theme: hexo-theme-matery _config.yml 文件的其它修改建议: 请修改 _config.yml 的 url 的值为你的网站主 URL（如：http://xxx.github.io）。 建议修改两个 per_page 的分页条数值为 6 的倍数，如：12、18 等，这样文章列表在各个屏幕下都能较好的显示。 如果你是中文用户，则建议修改 language 的值为 zh-CN。 2.5 新建分类 categories 页categories 页是用来展示所有分类的页面，如果在你的博客 source 目录下还没有 categories/index.md 文件，那么你就需要新建一个，命令如下： hexo new page \"categories\" 编辑你刚刚新建的页面文件 /source/categories/index.md，至少需要以下内容： --- title: categories date: 2018-09-30 17:25:30 type: \"categories\" layout: \"categories\" --- 2.6 新建标签 tags 页tags 页是用来展示所有标签的页面，如果在你的博客 source 目录下还没有 tags/index.md 文件，那么你就需要新建一个，命令如下： hexo new page \"tags\" 编辑你刚刚新建的页面文件 /source/tags/index.md，至少需要以下内容： --- title: tags date: 2018-09-30 18:23:38 type: \"tags\" layout: \"tags\" --- 2.7 新建关于我 about 页about 页是用来展示关于我和我的博客信息的页面，如果在你的博客 source 目录下还没有 about/index.md 文件，那么你就需要新建一个，命令如下： hexo new page \"about\" 编辑你刚刚新建的页面文件 /source/about/index.md，至少需要以下内容： --- title: about date: 2018-09-30 17:25:30 type: \"about\" layout: \"about\" --- 2.8 新建留言板 contact 页（可选的）contact 页是用来展示留言板信息的页面，前提是已经开启了第三方评论系统才能显示。如果在你的博客 source 目录下还没有 contact/index.md 文件，那么你就需要新建一个，命令如下： hexo new page \"contact\" 编辑你刚刚新建的页面文件 /source/contact/index.md，至少需要以下内容： --- title: contact date: 2018-09-30 17:25:30 type: \"contact\" layout: \"contact\" --- 2.9 新建友情链接 friends 页（可选的）friends 页是用来展示友情链接信息的页面，如果在你的博客 source 目录下还没有 friends/index.md 文件，那么你就需要新建一个，命令如下： hexo new page \"friends\" 编辑你刚刚新建的页面文件 /source/friends/index.md，至少需要以下内容： --- title: friends date: 2018-12-12 21:25:30 type: \"friends\" layout: \"friends\" --- 同时，在你的博客 source 目录下新建 _data 目录，在 _data 目录中新建 friends.json 文件，文件内容如下所示： [{ \"avatar\": \"http://image.luokangyuan.com/1_qq_27922023.jpg\", \"name\": \"码酱\", \"introduction\": \"我不是大佬，只是在追寻大佬的脚步\", \"url\": \"http://luokangyuan.com/\", \"title\": \"前去学习\" }, { \"avatar\": \"http://image.luokangyuan.com/4027734.jpeg\", \"name\": \"闪烁之狐\", \"introduction\": \"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬\", \"url\": \"https://blinkfox.github.io/\", \"title\": \"前去学习\" }, { \"avatar\": \"http://image.luokangyuan.com/avatar.jpg\", \"name\": \"ja_rome\", \"introduction\": \"平凡的脚步也可以走出伟大的行程\", \"url\": \"https://me.csdn.net/jlh912008548\", \"title\": \"前去学习\" }] 2.10 一级菜单导航配置配置基本菜单导航的名称、路径url和图标icon 菜单导航名称可以是中文也可以是英文(如：Index或主页) 图标icon 可以在Font Awesome 中查找 menu: Index: url: / icon: fas fa-home Tags: url: /tags icon: fas fa-tags Categories: url: /categories icon: fas fa-bookmark Archives: url: /archives icon: fas fa-archive About: url: /about icon: fas fa-user-circle Friends: url: /friends icon: fas fa-address-book 2.11 二级菜单配置方法如果你需要二级菜单则可以在原基本菜单导航的基础上如下操作 在需要添加二级菜单的一级菜单下添加children关键字(如:About菜单下添加children) 在children下创建二级菜单的 名称name,路径url和图标icon. 注意每个二级菜单模块前要加 -. 注意缩进格式 menu: Index: url: / icon: fas fa-home Tags: url: /tags icon: fas fa-tags Categories: url: /categories icon: fas fa-bookmark Archives: url: /archives icon: fas fa-archive About: url: /about icon: fas fa-user-circle-o Friends: url: /friends icon: fas fa-address-book Medias: icon: fas fa-list children: - name: Musics url: /musics icon: fas fa-music - name: Movies url: /movies icon: fas fa-film - name: Books url: /books icon: fas fa-book - name: Galleries url: /galleries icon: fas fa-image 执行 hexo clean &amp;&amp; hexo g 重新生成博客文件。 2.12 代码高亮由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 hexo-prism-plugin 的 Hexo 插件来做代码高亮，安装命令如下： npm i -S hexo-prism-plugin 然后，修改 Hexo 根目录下 _config.yml 文件中 highlight.enable 的值为 false，并新增 prism 插件相关的配置，主要配置如下： highlight: enable: false prism_plugin: mode: 'preprocess' # realtime/preprocess theme: 'tomorrow' line_number: false # default false custom_css: 更多代码块优化详细内容请访问：http://luckyzmj.cn/posts/1b9a9e28.html 2.13 搜索本主题中还使用到了 hexo-generator-search 的 Hexo 插件来做内容搜索，安装命令如下： npm install hexo-generator-search --save 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： search: path: search.xml field: post 2.14 文章字数统计插件（建议安装）如果你想要在文章中显示文章字数、阅读时长信息，可以安装 hexo-wordcount 插件。 安装命令如下： npm i --save hexo-wordcount 然后只需在本主题下的 _config.yml 文件中，将各个文章字数相关的配置激活即可： postInfo: date: true update: false wordCount: false # 设置文章字数统计为 true. totalCount: false # 设置站点文章总字数统计为 true. min2read: false # 阅读时长. readCount: false # 阅读次数. 2.15 添加emoji表情支持（可选的）本主题新增了对emoji表情的支持，使用到了 hexo-filter-github-emojis 的 Hexo 插件来支持 emoji表情的生成，把对应的markdown emoji语法（::,例如：:smile:）转变成会跳跃的emoji表情，安装命令如下： npm install hexo-filter-github-emojis --save 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： githubEmojis: enable: true className: github-emoji inject: true styles: customEmojis: 2.16 添加 RSS 订阅支持（可选的）本主题中还使用到了hexo-generator-feed 的 Hexo 插件来做 RSS，安装命令如下： npm install hexo-generator-feed --save 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： feed: type: atom path: atom.xml limit: 20 hub: content: content_limit: 140 content_limit_delim: ' ' order_by: -date 执行 hexo clean &amp;&amp; hexo g 重新生成博客文件，然后在 public 文件夹中即可看到 atom.xml 文件，说明你已经安装成功了。 2.17 添加 DaoVoice 在线聊天功能（可选的）前往 DaoVoice 官网注册并且获取 app_id，并将 app_id 填入主题的 _config.yml 文件中。 2.18 添加 Tidio 在线聊天功能（可选的）前往 Tidio 官网注册并且获取 Public Key，并将 Public Key 填入主题的 _config.yml 文件中。 2.19 修改页脚页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 /layout/_partial/footer.ejs 文件中，包括站点、使用的主题、访问量等。 2.20 修改社交链接在主题的 _config.yml 文件中，默认支持 QQ、GitHub 和邮箱等的配置，你可以在主题文件的 /layout/_partial/social-link.ejs 文件中，新增、修改你需要的社交链接地址，增加链接可参考如下代码： &lt;% if (theme.socialLink.github) { %&gt; &lt;a href=\"&lt;%= theme.socialLink.github %&gt;\" class=\"tooltipped\" target=\"_blank\" data-tooltip=\"访问我的GitHub\" data-position=\"top\" data-delay=\"50\"&gt; &lt;i class=\"fab fa-github\"&gt;&lt;/i&gt; &lt;/a&gt; &lt;% } %&gt; 其中，社交图标（如：fa-github）你可以在 Font Awesome 中搜索找到。以下是常用社交图标的标识，供你参考： Facebook: fab fa-facebook Twitter: fab fa-twitter Google-plus: fab fa-google-plus Linkedin: fab fa-linkedin Tumblr: fab fa-tumblr Medium: fab fa-medium Slack: fab fa-slack Sina Weibo: fab fa-weibo Wechat: fab fa-weixin QQ: fab fa-qq Zhihu: fab fa-zhihu 注意: 本主题中使用的 Font Awesome 版本为 5.11.0。 2.21 修改打赏的二维码图片在主题文件的 source/medias/reward 文件中，你可以替换成你的的微信和支付宝的打赏二维码图片。 2.22 配置音乐播放器（可选的）要支持音乐播放，在主题的 _config.yml 配置文件中激活music配置即可 # 是否在首页显示音乐 music: enable: true title: #非吸底模式有效 enable: true show: 听听音乐 server: netease #require music platform: netease, tencent, kugou, xiami, baidu type: playlist #require song, playlist, album, search, artist id: 503838841 #require song id / playlist id / album id / search keyword fixed: false # 开启吸底模式 autoplay: false # 是否自动播放 theme: '#42b983' loop: 'all' # 音频循环播放, 可选值: 'all', 'one', 'none' order: 'random' # 音频循环顺序, 可选值: 'list', 'random' preload: 'auto' # 预加载，可选值: 'none', 'metadata', 'auto' volume: 0.7 # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效 listFolded: true # 列表默认折叠 提示： server可选netease（网易云音乐），tencent（QQ音乐），kugou（酷狗音乐），xiami（虾米音乐），baidu（百度音乐）。 type可选song（歌曲），playlist（歌单），album（专辑），search（搜索关键字），artist（歌手） id获取示例: 浏览器打开网易云音乐，点击我喜欢的音乐歌单，地址栏有一串数字，playlist的id即为这串数字。 2.23文章 Front-matter 介绍Front-matter 选项中的所有内容均为非必填的。但我仍然建议至少填写 title 和 date 的值。 配置选项 默认值 描述 title Markdown 的文件标题 文章标题，强烈建议填写此选项 date 文件创建时的日期时间 发布时间，强烈建议填写此选项，且最好保证全局唯一 author 根 _config.yml 中的 author 文章作者 img featureImages 中的某个值 文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: http://xxx.com/xxx.jpg top true 推荐文章（文章是否置顶），如果 top 值为 true，则会作为首页推荐文章 cover false v1.0.2版本新增，表示该文章是否需要加入到首页轮播封面中 coverImg 无 v1.0.2版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片 password 无 文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword 选项 toc true 是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项 mathjax false 是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行 summary 无 文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要 categories 无 文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类 tags 无 文章标签，一篇文章可以多个标签 keywords 文章标题 文章关键字，SEO 时需要 reprintPolicy cc_by 文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个 注意: 如果 img 属性不填写的话，文章特色图会根据文章标题的 hashcode 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图各有特色。 date 的值尽量保证每篇文章是唯一的，因为本主题中 Gitalk 和 Gitment 识别 id 是通过 date 的值来作为唯一标识的。 如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 _config.yml 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：开源中国在线工具、chahuo、站长工具。 您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则 以下为文章的 Front-matter 示例。最简示例 --- title: typora-vue-theme主题介绍 date: 2018-09-07 09:25:00 --- 最全示例 --- title: theme主题介绍 date: 2018-09-07 09:25:00 author: 赵奇 img: /source/images/xxx.jpg top: true cover: true coverImg: /images/1.jpg password: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92 toc: false mathjax: false summary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要 categories: Markdown tags: - Typora - Markdown --- 2.24 自定制修改在本主题的 _config.yml 中可以修改部分自定义信息，有以下几个部分： 菜单 我的梦想 首页的音乐播放器和视频播放器配置 是否显示推荐文章名称和按钮配置 favicon 和 Logo 个人信息 TOC 目录 文章打赏信息 复制文章内容时追加版权信息 MathJax 文章字数统计、阅读时长 点击页面的’爱心’效果 我的项目 我的技能 我的相册 Gitalk、Gitment、Valine 和 disqus 评论配置 不蒜子统计和谷歌分析（Google Analytics） 默认特色图的集合。当文章没有设置特色图时，本主题会根据文章标题的 hashcode 值取余，来选择展示对应的特色图 我认为个人博客应该都有自己的风格和特色。如果本主题中的诸多功能和主题色彩你不满意，可以在主题中自定义修改，很多更自由的功能和细节点的修改难以在主题的 _config.yml 中完成，需要修改源代码才来完成。以下列出了可能对你有用的地方：修改主题颜色 在主题文件的 /source/css/matery.css 文件中，搜索 .bg-color 来修改背景颜色： /* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */ .bg-color { background-image: linear-gradient(to right, #4cbf30 0%, #0f9d58 100%); } @-webkit-keyframes rainbow { /* 动态切换背景颜色. */ } @keyframes rainbow { /* 动态切换背景颜色. */ } body { /* background-color: #eaeaea; */ /* 增加背景壁纸*/ background: url(\"https://ae01.alicdn.com/kf/H18a4b998752a4ae68b8e85d432a5aef0l.png\"), url(\"http://luckyzmj.cn/img/yun.jpg\") 0px 0px; background-attachment: fixed; margin: 0; color: #34495e; } 2.25 修改 banner 图和文章特色图你可以直接在 /source/medias/banner 文件夹中更换你喜欢的 banner 图片，主题代码中是每天动态切换一张，只需 7 张即可。如果你会 JavaScript 代码，可以修改成你自己喜欢切换逻辑，如：随机切换等，banner 切换的代码位置在 /layout/_partial/bg-cover-content.ejs 文件的 &lt;script&gt;&lt;/script&gt; 代码中： $('.bg-cover').css('background-image', 'url(/medias/banner/' + new Date().getDay() + '.jpg)'); 在 /source/medias/featureimages 文件夹中默认有 24 张特色图片，你可以再增加或者减少，并需要在 _config.yml 做同步修改。 2.26 优化目录栏在 themes\\Matery\\layout\\_partial\\post-detail-toc.ejs，修改内容如下： .toc-widget { padding-left: 20px; width: 345px; background-color: rgb(255, 255, 255,0.7); border-radius: 10px; box-shadow: 0 10px 35px 2px rgba(0, 0, 0, .15), 0 5px 15px rgba(0, 0, 0, .07), 0 2px 5px -5px rgba(0, 0, 0, .1) !important; } #toc-content { margin-bottom: 20px; } 0x005 更多详细教程以下几篇文章都是基于Hexo框架和hexo-theme-matery主题优化的教程，大家如果遇到问题，可以参考其中的方法。 Hexo+Github博客搭建完全教程 hexo-theme-matery作者教程 Hexo+github搭建博客(超级详细版，精细入微) hexo（matery）背景、滚动条优化+增加点击跳评论","categories":[{"name":"博客篇","slug":"博客篇","permalink":"http://www.luckyzmj.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.luckyzmj.cn/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"http://www.luckyzmj.cn/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Github","slug":"Github","permalink":"http://www.luckyzmj.cn/tags/Github/"}],"author":"Luckey"}],"categories":[{"name":"感悟","slug":"感悟","permalink":"http://www.luckyzmj.cn/categories/%E6%84%9F%E6%82%9F/"},{"name":"框架","slug":"框架","permalink":"http://www.luckyzmj.cn/categories/%E6%A1%86%E6%9E%B6/"},{"name":"项目基础","slug":"项目基础","permalink":"http://www.luckyzmj.cn/categories/%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80/"},{"name":"中间件","slug":"中间件","permalink":"http://www.luckyzmj.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"总结","slug":"总结","permalink":"http://www.luckyzmj.cn/categories/%E6%80%BB%E7%BB%93/"},{"name":"java基础","slug":"java基础","permalink":"http://www.luckyzmj.cn/categories/java%E5%9F%BA%E7%A1%80/"},{"name":"linux","slug":"linux","permalink":"http://www.luckyzmj.cn/categories/linux/"},{"name":"工具","slug":"工具","permalink":"http://www.luckyzmj.cn/categories/%E5%B7%A5%E5%85%B7/"},{"name":"博客篇","slug":"博客篇","permalink":"http://www.luckyzmj.cn/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"},{"name":"前端篇","slug":"前端篇","permalink":"http://www.luckyzmj.cn/categories/%E5%89%8D%E7%AB%AF%E7%AF%87/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://www.luckyzmj.cn/tags/%E7%94%9F%E6%B4%BB/"},{"name":"spring","slug":"spring","permalink":"http://www.luckyzmj.cn/tags/spring/"},{"name":"springCloud","slug":"springCloud","permalink":"http://www.luckyzmj.cn/tags/springCloud/"},{"name":"java基础","slug":"java基础","permalink":"http://www.luckyzmj.cn/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"mybatis","slug":"mybatis","permalink":"http://www.luckyzmj.cn/tags/mybatis/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.luckyzmj.cn/tags/SpringBoot/"},{"name":"redis","slug":"redis","permalink":"http://www.luckyzmj.cn/tags/redis/"},{"name":"数据库","slug":"数据库","permalink":"http://www.luckyzmj.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"docker","slug":"docker","permalink":"http://www.luckyzmj.cn/tags/docker/"},{"name":"linux","slug":"linux","permalink":"http://www.luckyzmj.cn/tags/linux/"},{"name":"jvm","slug":"jvm","permalink":"http://www.luckyzmj.cn/tags/jvm/"},{"name":"java","slug":"java","permalink":"http://www.luckyzmj.cn/tags/java/"},{"name":"注解","slug":"注解","permalink":"http://www.luckyzmj.cn/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"设计","slug":"设计","permalink":"http://www.luckyzmj.cn/tags/%E8%AE%BE%E8%AE%A1/"},{"name":"算法","slug":"算法","permalink":"http://www.luckyzmj.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"多线程","slug":"多线程","permalink":"http://www.luckyzmj.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"基础","slug":"基础","permalink":"http://www.luckyzmj.cn/tags/%E5%9F%BA%E7%A1%80/"},{"name":"反射","slug":"反射","permalink":"http://www.luckyzmj.cn/tags/%E5%8F%8D%E5%B0%84/"},{"name":"序列化","slug":"序列化","permalink":"http://www.luckyzmj.cn/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"知识点自贴","slug":"知识点自贴","permalink":"http://www.luckyzmj.cn/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%E8%87%AA%E8%B4%B4/"},{"name":"idea","slug":"idea","permalink":"http://www.luckyzmj.cn/tags/idea/"},{"name":"swagger","slug":"swagger","permalink":"http://www.luckyzmj.cn/tags/swagger/"},{"name":"hexo-blog-lucky","slug":"hexo-blog-lucky","permalink":"http://www.luckyzmj.cn/tags/hexo-blog-lucky/"},{"name":"博客搭建教程","slug":"博客搭建教程","permalink":"http://www.luckyzmj.cn/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"},{"name":"Hexo","slug":"Hexo","permalink":"http://www.luckyzmj.cn/tags/Hexo/"},{"name":"渲染绕过","slug":"渲染绕过","permalink":"http://www.luckyzmj.cn/tags/%E6%B8%B2%E6%9F%93%E7%BB%95%E8%BF%87/"},{"name":"jQuery+CSS3","slug":"jQuery-CSS3","permalink":"http://www.luckyzmj.cn/tags/jQuery-CSS3/"},{"name":"粒子特效","slug":"粒子特效","permalink":"http://www.luckyzmj.cn/tags/%E7%B2%92%E5%AD%90%E7%89%B9%E6%95%88/"},{"name":"PicGo","slug":"PicGo","permalink":"http://www.luckyzmj.cn/tags/PicGo/"},{"name":"GitHub图床","slug":"GitHub图床","permalink":"http://www.luckyzmj.cn/tags/GitHub%E5%9B%BE%E5%BA%8A/"},{"name":"阿里云","slug":"阿里云","permalink":"http://www.luckyzmj.cn/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"博客","slug":"博客","permalink":"http://www.luckyzmj.cn/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Github","slug":"Github","permalink":"http://www.luckyzmj.cn/tags/Github/"}]}